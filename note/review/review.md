## 
> 基本数据类型是值拷贝，引用数据类型是地址拷贝
> 创建对象时会先加载类信息,分配空间，最后把地址分配给引用；对象的属性默认值遵守数组规则
> 方法区的常量池里存放字符，方法区里加载类的信息；调用带参数的方法时，需要对应参数列表的相同类型或兼容类型
> 重载：方法名相同，参数个数、类型、顺序三者必有一个不同
> 可变参数：java允许将同一个类中多个同名同功能但是参数不同的方法封装成一个方法 
> 形参列表要放在可变参数后；一个形参列表只有一个可变参数；可变参数可以和普通类型的参数放在一起
> 局部变量没有默认值，不可以被其他类使用，局部变量不可以重名；结束方法后，局部变量会被销毁，属性不会，局部变量不可以加修饰符 
> 构造器是完成对象的初始化，不是创建对象
> 在对象创建流程中，加载类信息（在堆中分配地址）-->默认初始化-->显式初始化-->构造器初始化-->将堆中的地址返回给引用
> this可以访问成员方法、构造器方法（this(参数列表)）
> this只能在类定义的内部使用，如果要访问构造器，必须放在第一条语句
> 创建子类对象，子类会先调用父类构造器（如果没有无参构造器，就必须在子类构造器中使用super指定父类构造器，否则编译不通过），完成父类的初始化，再去调用子类构造器
> 如果希望指定去调用父类的某个构造器，需要显式的调用
> 重写：子类的方法和父类的某个方法名、参数、返回值类型一样
> 子类的返回类型和父类一样，或是父类返回类型的子类
> 向上转型 Animal animal = new Cat();  向下转型 Cat cat=(Cat)animal;
> 向上转型 可以调用父类的所有成员，不能调用子类的特有成员 向下转型只能强转父类的引用不能强转父类的对象；向下转型后可以调用子类的所有成员
> 当调用对象方法时，该方法会和该对象的内存地址绑定，调用对象属性时没有动态绑定，哪里声明哪里使用
> == 判断基本类型是判断值是否相同 判断引用类型是判断地址是否相同
> equals 只能判断引用类型默认判断的是地址是否相同
> 对于基本类型 ==判断两个值是否相同，基本类型没有equals方法；对于引用类型，==判断连哥哥变量是否引用同一个对象，equals判断引用的对象是否等价
> hashcode() 根据不同的对象返回不同的整数；equals用来判断两个对象是否等价，等价的两个对象hash值一定相同，hash值相同的两个对象不一定是等价的（计算hash值具有随机性）；在重写equals时要重写hashCode方法，保证等价的两个对象等价
> HashMap和HashSet等集合类使用HashCode方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要对应的类重写hashCode方法
> toString() 默认返回全类名+@+哈希值的十六进制 当直接输出一个对象时会调用；子类重写方法，返回该对象的属性信息
> finalize 对象被回收时，系统自动调用finalize方法；对象没有任何引用时被jvm认为是垃圾

##
> 类加载时，静态方法会放在方法区中，静态变量在类加载时就生成了；jdk8以后放在堆中类对应的class对象中，通过反射机制加载一个class对象 
> 可以通过类名访问静态变量；静态变量的声明周期随着类加载开始，随着类消亡结束
> 静态方法结构信息存放在方法去，静态方法无法用this；静态方法中只允许访问静态变量和静态方法；非静态方法，两者都可以访问



> 代码块在加载类或创建对象时调用；无论调用哪个构造器，都会先去调用代码块中的内容；代码块调用顺序优先于构造器
> 静态代码块随着类的加载而执行，且执行一次；普通代码块每创建一个对象，就执行一次
> 类被加载的时机  创建对象实例、创建子类对象实例、使用类的静态成员
> 使用类的静态成员，普通代码块不会被执行；静态代码块/属性>普通代码块/属性>构造器
> 父类的静态代码块/属性>子类的静态代码块/属性>父类的普通代码块/属性>父类的构造器>子类的普通代码块/属性>子类构造器
> 静态代码块只能调用静态成员，普通代码块可以调用任意成员
> 单例模式
>
> final可以修饰类、属性、方法、局部变量
> 类不被继承、父类的方法不被子类重写、类的某个属性值不被修改、局部变量不被修改 可以用final修饰
> final修饰的属性被定义时必须赋初值；赋值的位置 定义时、构造器中、代码块中
> final修饰的属性是static时只能在定义时或静态代码块中赋值，不能在构造器中赋值
> final方法可以被继承不能被重写，一个类是final则方法不用final修饰 final不能修饰构造方法
> 包装类和String都是final；对于基本数据类型，final使数值不变 对于引用数据类型final使引用不变，不能引用其他对象，但是对象本身可以修改
> 
>
> 抽象类 当父类的某些方法，需要声明又不确定如何实现，可以声明为抽象方法；抽象类由子类继承并实现
> 抽象类不能被实例化，类包含抽象方法就必须声明为abstract，抽象类可以没有abstract方法
> abstract只能修饰类和方法；一个类继承了抽象类就必须实现抽象类的所有方法，除非自己也声明为抽象类
>
> 模板设计模式
>
> 接口中的抽象方法可以不加abstract；接口不能被实例化；抽象类实现接口，可以不用实现接口的方法
> 接口的属性是public static final ；接口中属性的访问 接口名.属性名；接口 like-a 继承 is-a
> 接口引用可以接受不同的对象；接口类型的变量可以指向实现了该接口的类的对象实例
>
> 内部类
> 局部内部类可以直接访问外部类所有成员包括私有，地位相当于局部变量，可以被final修饰，不能被修饰符修饰
> 外部类访问局部内部类要创建对象再访问，外部其他类不能访问局部内部类；其他类访问外部类成员 外部类名.this.成员
> 匿名内部类 没有类名、是一个对象（）；匿名内部类既是一个类的定义也是一个对象；可以直接访问外部类的所有成员包括私有的
> 外部其他类不能访问匿名内部类；其他类访问外部类成员 外部类名.this.成员
>
> 成员内部类可以直接访问外部类成员包括私有；可以添加修饰符；外部类访问内部类要创建对象
>
> 静态内部类可以直接访问外部类的所有静态成员，包括私有的，不能访问非静态成员；内部类如果想访问外部类成员，则可以使用（外部类名.成员）去访问
> 非静态内部类依赖于外部类的实例，即需要先创建外部类的实例才能用这个实例创建非静态内部类，静态内部类则不需要
>
> 枚举对象名要大写；使用enum实现枚举要把常量对象写在前面；enum开发一个枚举类时，默认继承enum类
> 使用enum关键字就不能继承其他类了；成员方法ordinal（返回当前对象的位置号从0开始）values（返回当前枚举类中的所有常量）valueOf（将字符串转换成枚举对象）compareTo（比较位置号）
>
> 注解
>
> 异常（error：jvm无法结局的问题 exception：其他因编程错误产生的一般性问题）；exception分为编译异常和运行异常
> 编译时异常是编译器要求必须处理的异常；程序员没有显式的处理异常，默认throws
> try-catch 异常发生了直接进入catch，try异常发生点后的代码不会执行
> throws 在方法声明处，后面跟异常类型 throw是手动生成异常对象的关键字，在方法体中，后面跟异常对象
>
> Integer 装箱（valueOf）与拆箱（intValue）；String->Integer parseInt(str)
> String不可以被继承；不可变（好处：可以缓存hash值、StringPool的需要、安全性、线程安全）
> StringBuffer、StringBuilder可变；String、StringBuffer（内部使用synchronized）线程安全StringBuilder线程不安全
> 字符串常量池中保存这所有的字符串字面量，这些字面量在编译时期就被确定，可以使用intern方法加入到常量池中
> 当一个字符串调用intern方法，如果StringPool中已经存在一个字符串值和该字符串相等，就会返回StringPool中字符串的引用；否则添加新字符串，返回新字符串的引用
>       