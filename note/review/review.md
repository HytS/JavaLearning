## 
> 基本数据类型是值拷贝，引用数据类型是地址拷贝
> 创建对象时会先加载类信息,分配空间，最后把地址分配给引用；对象的属性默认值遵守数组规则
> 方法区的常量池里存放字符，方法区里加载类的信息；调用带参数的方法时，需要对应参数列表的相同类型或兼容类型
> 重载：方法名相同，参数个数、类型、顺序三者必有一个不同
> 可变参数：java允许将同一个类中多个同名同功能但是参数不同的方法封装成一个方法 
> 形参列表要放在可变参数后；一个形参列表只有一个可变参数；可变参数可以和普通类型的参数放在一起
> 局部变量没有默认值，不可以被其他类使用，局部变量不可以重名；结束方法后，局部变量会被销毁，属性不会，局部变量不可以加修饰符 
> 构造器是完成对象的初始化，不是创建对象
> 在对象创建流程中，加载类信息（在堆中分配地址）-->默认初始化-->显式初始化-->构造器初始化-->将堆中的地址返回给引用
> this可以访问成员方法、构造器方法（this(参数列表)）
> this只能在类定义的内部使用，如果要访问构造器，必须放在第一条语句
> 创建子类对象，子类会先调用父类构造器（如果没有无参构造器，就必须在子类构造器中使用super指定父类构造器，否则编译不通过），完成父类的初始化，再去调用子类构造器
> 如果希望指定去调用父类的某个构造器，需要显式的调用
> 重写：子类的方法和父类的某个方法名、参数、返回值类型一样
> 子类的返回类型和父类一样，或是父类返回类型的子类
> 向上转型 Animal animal = new Cat();  向下转型 Cat cat=(Cat)animal;
> 向上转型 可以调用父类的所有成员，不能调用子类的特有成员 向下转型只能强转父类的引用不能强转父类的对象；向下转型后可以调用子类的所有成员
> 当调用对象方法时，该方法会和该对象的内存地址绑定，调用对象属性时没有动态绑定，哪里声明哪里使用
> == 判断基本类型是判断值是否相同 判断引用类型是判断地址是否相同
> equals 只能判断引用类型默认判断的是地址是否相同
> hashcode() 根据不同的对象返回不同的整数
> toString() 默认返回全类名+@+哈希值的十六进制 当直接输出一个对象时会调用；子类重写方法，返回该对象的属性信息
> finalize 对象被回收时，系统自动调用finalize方法；对象没有任何引用时被jvm认为是垃圾

##
> 类加载时，静态方法会放在方法区中，静态变量在类加载时就生成了；jdk8以后放在堆中类对应的class对象中，通过反射机制加载一个class对象 
> 可以通过类名访问静态变量；静态变量的声明周期随着类加载开始，随着类消亡结束
> 静态方法结构信息存放在方法去，静态方法无法用this；静态方法中只允许访问静态变量和静态方法；非静态方法，两者都可以访问


> 代码块在加载类或创建对象时调用；无论调用哪个构造器，都会先去调用代码块中的内容；代码块调用顺序优先于构造器
> 静态代码块随着类的加载而执行，且执行一次；普通代码块每创建一个对象，就执行一次
> 类被加载的时机  创建对象实例、创建子类对象实例、使用类的静态成员
> 使用类的静态成员，普通代码块不会被执行；静态代码块/属性>普通代码块/属性>构造器
> 父类的静态代码块/属性>子类的静态代码块/属性>父类的普通代码块/属性>父类的构造器>子类的普通代码块/属性>子类构造器
> 静态代码块只能调用静态成员，普通代码块可以调用任意成员