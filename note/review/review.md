## 
> 基本数据类型是值拷贝，引用数据类型是地址拷贝
> 创建对象时会先加载类信息,分配空间，最后把地址分配给引用；对象的属性默认值遵守数组规则  *
> 方法区的常量池里存放字符，方法区里加载类的信息；调用带参数的方法时，需要对应参数列表的相同类型或兼容类型
> 重载：方法名相同，参数个数、类型、顺序三者必有一个不同
> 可变参数：java允许将同一个类中多个同名同功能但是参数不同的方法封装成一个方法 
> 形参列表要放在可变参数后；一个形参列表只有一个可变参数；可变参数可以和普通类型的参数放在一起
> 局部变量没有默认值，不可以被其他类使用，局部变量不可以重名；结束方法后，局部变量会被销毁，属性不会，局部变量不可以加修饰符 
> 构造器是完成对象的初始化，不是创建对象
> 在对象创建流程中，加载类信息（在堆中分配地址）-->默认初始化-->显式初始化-->构造器初始化-->将堆中的地址返回给引用
> this可以访问成员方法、构造器方法（this(参数列表)）
> this只能在类定义的内部使用，如果要访问构造器，必须放在第一条语句
> 创建子类对象，子类会先调用父类构造器（如果没有无参构造器，就必须在子类构造器中使用super指定父类构造器，否则编译不通过），完成父类的初始化，再去调用子类构造器
> 如果希望指定去调用父类的某个构造器，需要显式的调用
> 重写：子类的方法和父类的某个方法名、参数、返回值类型一样
> 子类的返回类型和父类一样，或是父类返回类型的子类
> 向上转型 Animal animal = new Cat();  向下转型 Cat cat=(Cat)animal;
> 向上转型 可以调用父类的所有成员，不能调用子类的特有成员 向下转型只能强转父类的引用不能强转父类的对象；向下转型后可以调用子类的所有成员 *
> 当调用对象方法时，该方法会和该对象的内存地址绑定，调用对象属性时没有动态绑定，哪里声明哪里使用
> == 判断基本类型是判断值是否相同 判断引用类型是判断地址是否相同
> equals 只能判断引用类型默认判断的是地址是否相同
> 对于基本类型 ==判断两个值是否相同，基本类型没有equals方法；对于引用类型，==判断两个变量是否引用同一个对象，equals判断引用的对象是否等价
> hashcode() 根据不同的对象返回不同的整数；equals用来判断两个对象是否等价，等价的两个对象hash值一定相同，hash值相同的两个对象不一定是等价的（计算hash值具有随机性）；在重写equals时要重写hashCode方法，保证等价的两个对象等价
> HashMap和HashSet等集合类使用HashCode方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要对应的类重写hashCode方法
> toString() 默认返回全类名+@+哈希值的十六进制 当直接输出一个对象时会调用；子类重写方法，返回该对象的属性信息
> finalize 对象被回收时，系统自动调用finalize方法；对象没有任何引用时被jvm认为是垃圾
> clone()是Object类的protected方法，一个类不显式的重写clone方法，其他类就不能直接去调用该类实例的clone方法；如果一个类没有实现Cloneable接口又调用clone方法会抛出异常
> 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象
> 深拷贝 拷贝对象和原始对象的引用类型引用不同对象




##
> 类加载时，静态方法会放在方法区中，静态变量在类加载时就生成了；jdk8以后放在堆中类对应的class对象中，通过反射机制加载一个class对象 
> 可以通过类名访问静态变量；静态变量的声明周期随着类加载开始，随着类消亡结束
> 静态方法结构信息存放在方法区，静态方法无法用this；静态方法中只允许访问静态变量和静态方法；非静态方法，两者都可以访问



> 代码块在加载类或创建对象时调用；无论调用哪个构造器，都会先去调用代码块中的内容；代码块调用顺序优先于构造器
> 静态代码块随着类的加载而执行，且执行一次；普通代码块每创建一个对象，就执行一次
> 类被加载的时机  创建对象实例、创建子类对象实例、使用类的静态成员
> 使用类的静态成员，普通代码块不会被执行；静态代码块/属性>普通代码块/属性>构造器
> 父类的静态代码块/属性>子类的静态代码块/属性>父类的普通代码块/属性>父类的构造器>子类的普通代码块/属性>子类构造器
> 静态代码块只能调用静态成员，普通代码块可以调用任意成员
> 单例模式
>
> final可以修饰类、属性、方法、局部变量
> 类不被继承、父类的方法不被子类重写、类的某个属性值不被修改、局部变量不被修改 可以用final修饰
> final修饰的属性被定义时必须赋初值；赋值的位置 定义时、构造器中、代码块中
> final修饰的属性是static时只能在定义时或静态代码块中赋值，不能在构造器中赋值
> final方法可以被继承不能被重写，一个类是final则方法不用final修饰 final不能修饰构造方法
> 包装类和String都是final；对于基本数据类型，final使数值不变 对于引用数据类型final使引用不变，不能引用其他对象，但是对象本身可以修改 
> 
>
> 抽象类 当父类的某些方法，需要声明又不确定如何实现，可以声明为抽象方法；抽象类由子类继承并实现
> 抽象类不能被实例化，类包含抽象方法就必须声明为abstract，抽象类可以没有abstract方法
> abstract只能修饰类和方法；一个类继承了抽象类就必须实现抽象类的所有方法，除非自己也声明为抽象类
>
> 模板设计模式
>
> 接口中的抽象方法可以不加abstract；接口不能被实例化；抽象类实现接口，可以不用实现接口的方法
> 接口的属性是public static final ；接口中属性的访问 接口名.属性名；接口 like-a 继承 is-a
> 接口引用可以接受不同的对象；接口类型的变量可以指向实现了该接口的类的对象实例
>
> 内部类
> 局部内部类可以直接访问外部类所有成员包括私有，地位相当于局部变量，可以被final修饰，不能被修饰符修饰（局部内部类定义在外部类的局部位置，通常在方法中）
> 外部类访问局部内部类要创建对象再访问，外部其他类不能访问局部内部类；内部类如果需要访问外部类成员 外部类名.this.成员
> 匿名内部类 没有类名、是一个对象（）；匿名内部类既是一个类的定义也是一个对象；可以直接访问外部类的所有成员包括私有的 jdk底层创建了匿名内部类Outer$1，立刻创建了Outer$1实例并把地址返回给tiger   
> Ia tiger = new Ia(){...方法} tiger运行类型就是匿名内部类
> 外部其他类不能访问匿名内部类；内部类方法访问外部类成员 外部类名.this.成员；外部类和匿名内部类重名时，默认遵循就近原则
>
> 成员内部类可以直接访问外部类成员包括私有；可以添加修饰符；外部类访问内部类需要创建对象；外部其他类访问内部类ⅠOuter outer = new Outer();Inner inner=outer.new Inner() Ⅱ Inner inner=new Outer.new Inner() Ⅲ Inner inner =new Outer.getInstance()   getInstance(){return new Inner()}
>
> 静态内部类可以直接访问外部类的所有静态成员，包括私有的，不能访问非静态成员；内部类如果想访问外部类成员，则可以使用（外部类名.成员）去访问； 外部其他类访问内部类 Outer.Inner inner=new Outer.Inner()
> 非静态内部类依赖于外部类的实例，即需要先创建外部类的实例才能用这个实例创建非静态内部类，静态内部类则不需要(如果外部类成员和内部类成员同名，遵循就近原则，，如果想访问外部类成员，静态内部类方法访问外部类成员，类名.成员)
> 
>
> 枚举对象名要大写；使用enum实现枚举要把常量对象写在前面；enum开发一个枚举类时，默认继承enum类
> 使用enum关键字就不能继承其他类了；成员方法ordinal（返回当前对象的位置号从0开始）values（返回当前枚举类中的所有常量）valueOf（将字符串转换成枚举对象）compareTo（比较位置号）
>
> 注解
>
> 异常（error：jvm无法结局的问题 exception：其他因编程错误产生的一般性问题）；exception分为编译异常和运行异常（https://www.cnblogs.com/Qian123/p/5715402.html）
> 编译时异常是编译器要求必须处理的异常；程序员没有显式的处理异常，默认throws
> try-catch 异常发生了直接进入catch，try异常发生点后的代码不会执行
> throws 在方法声明处，后面跟异常类型 throw是手动生成异常对象的关键字，在方法体中，后面跟异常对象
>
> Integer 装箱（valueOf）与拆箱（intValue）；String->Integer parseInt(str)
> String不可以被继承；不可变（好处：可以缓存hash值、StringPool的需要、安全性、线程安全）；单个字符可以改变
> StringBuffer、StringBuilder可变；String、StringBuffer（内部使用synchronized）线程安全StringBuilder线程不安全
> 字符串常量池中保存这所有的字符串字面量，这些字面量在编译时期就被确定，可以使用intern方法加入到常量池中
> 当一个字符串调用intern方法（返回常量池的地址），如果StringPool中已经存在一个字符串值和该字符串相等，就会返回StringPool中字符串的引用；否则添加新字符串，返回新字符串的引用
> 常量相加，看的是池，变量相加，看的是堆 *；StringBuffer可以对字符串内容进行删减；是一个容器是final类；StringBuffer存放在父类的char[] value 中，只有在存储空间不够时才会扩容
> StringBuffer默认创建一个大小为16的char[]
> StringBuilder对象字符序列存放在父类的char[] value 字符序列存放在堆中
>
> 集合 Collection接口有两个子接口set和list(实现子类都是单列集合)，Map接口的实现子类是双列集合：list有序 set无序；Collection接口通过子接口set和list实现
> 迭代器遍历集合元素；List集合类元素有序，添加顺序和取出顺序一致且可重复；ArrayList可以加入多个null，线程不安全；
> 创建ArrayList对象时，使用无参构造器初始容量为0，第一次添加扩容为10，第二次扩容为1.5倍；如果使用指定大小的构造器，初始容量为指定大小，再扩容为1.5倍
> vector是线程安全的；如果无参默认10，扩容时按2倍扩容，如果指定大小每次按2倍扩；ArrayList增删效率低改查效率高vector增删效率高改查效率低
> set 添加顺序和取出顺序不一致，没有索引，取出顺序固定 不允许重复元素且只有一个null；遍历方式：迭代器、增强for

> HashSet的扩容：添加元素得到的hash值转成索引值，找到table，看索引位置是否存放元素，如果没有直接加入，如果有，调用equals比较，相同则放弃添加，不同则添加到最后；如果一条链表元素个数达到默认值（8）且table大小>=64就会树化；
> HashSet第一次添加时，table数组扩容到16，临界值时16*加载因子(0.75)=12;如果table数组达到临界值12就会继续扩容到16*2=32；当链表中的元素总和>12也会扩容

> LinkedHashSet 底层是一个LinkedHashMap，底层维护了一个数组table+双向链表；根据元素的hashcode值决定元素的存储位置，同时使用链表维护元素的次序；不允许添加重复元素；添加元素时，先求hash值，确定元素再table中的位置，再将要添加的元素加入到双向链表（如果已经存在，不添加）
> 扩容 添加第一次将table数组扩容到16，存放的节点类型时LinkedHashMap$Entry 数组是HashSet$Node[] 存放的元素是LinkedHashMap$Entry

> Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中；Map中的key和value不可以重复；key和value都可以为null，但是key中null只能有一个，value中null可以有多个
> Map存放数据的key-value示意图，一对k-v是放在一个Node中的，又因为Node实现了Entry接口，所以有些书也说一对k-v就是一个Entry
> HashMap底层机制：table――HashMap$Node--Map$Entry;(k,v)是一个Node实现了Map$Entry<k,v>;扩容机制和HashSet相同
> HashMap底层维护了Node类型的table，默认null；当创建对象时，将加载因子初始化为0.75；当添加k-v时，通过key的hash值得到table的索引，然后判断该索引处是否有元素，没有元素直接添加，如果有元素，判断该索引处key和准备添加的key是否相同，如果相同直接替换value，不同要继续判断是树还是链表并作出相应处理，如果添加时发现容量不够，则需要扩容
> 第一次添加时，需要扩容table到16，临界值是16*加载因子(0.75)=12;再扩容就是16*2=32；新的临界值是32*0.75=24；在java8中，如果一条链表的元素个数达到8并且table大小>=64就会进行树化，否则仍采用数组扩容机制
> hashtable的键值对都不能是null，hashtable是线程安全的，hashMap线程不安全；properties继承hashtable类实现了Map接口，也是一种键值对的形式来保存数据
>
> 如何选择集合实现类

> 泛型
> 
> https://www.cnblogs.com/Blue-Keroro/p/8875898.html
> 反射 每个类都有class对象，包含了与类有关的信息，当编译一个新类时，会产生一个同名的.class文件,该文件内容保存着Class对象；java反射机制可以动态的创建对象并调用其属性
> 类加载相当于Class对象的加载，类在使用时才动态加载到jvm中，也可以使用Class.forName("com.mysql.jdbc.Driver")来控制类的加载，该方法会返回一个Class对象
> 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来；getField访问公有的成员变量getDeclaredField 访问所有已声明的成员变量
> 从类中获取了一个方法后，使用invoke方法来调用这个方法