#
### jvm、jdk、jre
* jvm是运行java字节码的虚拟机，针对不同系统有特定的实现，目的是使用相同的字节码，它们都会给出相同的结果；字节码和不同系统的jvm实现是java语言的"一次编译，随处可以运行"的关键
* jdk:java sdk jre:java运行环境 jdk包括jre

### 什么是字节码，使用字节码的好处
* jvm可以理解的代码是字节码，它不面向任何特定的处理器，只面向虚拟机，并且字节码并不针对特定的机器
* .class->机器码，第一步是jvm类加载器先加载字节码文件，然后通过解释器解释执行，这种方式速度慢；为了调用热点代码引进了JIT编译器，jit属于运行时编译，第一次编译后，会将字节码对应的机器码保存下来

### java和c++的区别
* java不提供指针来直接访问内存，程序内存更安全
* java的类是单继承，c++支持多重继承；java的接口可以多重继承
* java有自动内存管理垃圾回收机制gc
* c++支持方法重载和操作符重载，java只支持方法重载
### 基本类型和包装类型的区别
> 包装类型可以用于泛型，基本类型不可以
> 基本数据类型的局部变量放在jvm栈中的局部变量表中，基本数据类型的成员变量（未被static修饰）放在java虚拟机的堆中，包装类型属于对象类型，几乎所有对象都放在堆中
> 基本数据类型有默认值，成员变量包装类型不赋值就是null
> 对于包装数据类型，==比较的是内存地址，对于基本数据类型比较的是值；所有整型包装对象之间值的比较，全部使用equals()
>
> 基本数据类型的成员变量如果没有被static修饰就是放在堆中
### 为什么说几乎所有对象都放在堆中
>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存 

### 包装类型的缓存机制
> java基本数据类型的包装类型的大部分都通过缓存机制提高性能；byte、short、Integer、Long默认创建了数值[-128,127]的相应类型的缓存数据,Character创建了[0，127]的缓存数据，Boolean直接返回true,false
> 如果超出对应范围仍然会去创建对象，缓存范围区间的大小只是性能和资源的博弈
> Float和Double没有实现缓存机制
### 所有整型包装类对象值之间的比较，全部使用equals方法
> 对于Integer var=..在-128-127之间的赋值，Integer对象会在IntegerCache.cache中产生，会复用已有对象，这个区间的Integer值可以使用==直接比较，在此区间之外的数据都会在堆上产生，并不会复用已有对象
>
### 自动拆箱和装箱
> 装箱调用了valueOf，拆箱调用了xxxValue；频繁的拆箱装箱影响性能

### 为什么浮点数运算的时候会有精度丢失的风险
> 无限循环的小数存储在计算机里会被截断，即十进制的浮点数无法转换成二进制小数

### 如何解决浮点数运算的精度丢失问题
> BigDecimal可以实现浮点数的运算，不会造成损失

### 超过 long 整型的数据应该如何表示
> BigInteger内部使用 int[] 数组来存储任意大小的整形数据。


### 对象实例和对象引用的区别
> 对象实例放在堆中，对象引用放在栈中，一个对象引用可以指向0或1个对象，一个对象可以有多个对象引用
### 对象相等和引用相等的区别
> 对象相等比较的是内存中存放的内容是否相等
> 引用相等比较内存地址是否相等

> 构造方法完成对象的初始化
> 父类的私有属性子类无法访问

### 多态特点
> 引用类型变量调用的方法属于哪个类，必须在程序运行期间才能确定
> 多态不能调用只在子类存在但父类不存在的方法

### 接口和抽象类的共同点和区别
#### 共同点
> 都不能被实例化；都可以包含抽象对象；都可以有默认实现的方法
#### 区别
> 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为；抽象类主要用于代码复用，强调的是所属的关系；
> 接口中的成员变量默认 public static final 不能被修改且有初值；抽象类的成员变量默认default，可在子类中被重新定义


### 深拷贝和浅拷贝
> 浅拷贝会在堆上创立一个新的对象；如果原对象内部的属性是引用类型，浅拷贝会直接复制内部对象的引用地址，即引用对象和原对象共用同一个内部对象
> 深拷贝会完全复制整个对象，包括这个对象的内部对象
> 引用拷贝就是两个不同的引用指向同一个对象


* 因为java只有值传递，所以，对于==来说，不管是基本数据类型还是引用数据类型，比较的都是值
* 类没有重新equals，通过equals比较两个对象等价于==比较两个对象；类重写equals，一般重写equals用于比较两个对象的属性是否相等  
* 两个对象的hashcode值相等不代表两个对象就相等；哈希值相等和equals返回true才代表两个对象相等

### 为什么重写equals()必须要重写hashcode()
> 如果重写equals没有重写hashcode，会导致equals判断的是相等的两个对象，hashcode值不相等

### String为什么是不可变的
> 保存字符串的数组被final修饰且为私有，并且String类没有提供修改这个字符串的方法
> String类被final修饰，不能被继承，避免子类破坏String不可变


* 字符串常量池主要目的是避免字符串的重新创建

### String s1=new String("abc") 创建了几个对象
> 会创建一个或两个
> 如果常量池不存在字符串对象abc，会在堆中创造两个字符串对象abc
> 如果常量池已存在字符串对象abc的引用，只会在堆中创建一个字符串对象abc

* intern() 将指定的字符串对象引用保存在常量池中，
* 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。final 修饰的基本数据类型和字符串变量。字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）
* 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。被 final 关键字修改之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

### checked Exception unchecked Exception有什么区别
> checked Exception是受检查异常，java代码在编译过程中，如果受检查异常没有被catch或throws处理的话，则无法通过编译；除了RuntimeException及其子类以外，其他的Exception类及其子类都是受检查异常
> java在编译时，不处理不受检查异常也可以通过编译；常见的有空指针、数组越界

### Throwable类常用方法有哪些
> String getMessage() 返回异常发生时的简要描述
> Stirng toString() 返回异常发生时的详细信息
> String getLocalizedMessage() 返回异常对象的本地化信息
> void printStackTrace() 在控制台上打印Throwable对象封装的异常信息

* 注意：不要在finally语句块中使用return，当try和finally语句中都存在return时，try中的return会被忽略，因为try中的return返回值会被暂存到一个本地变量中，当执行到finally中的return时，本地变量的值就变成了finally中的return值
* finally中的代码不一定会被执行，比如finally之前虚拟机被终止运行，则finally中的代码就不会执行；或者程序所在线程死亡、关闭cpu都会导致finally不被执行

### 如何使用try-with-resources代替try-catch-finally
### 异常的注意事项


* 编译器可以通过泛型参数可以指定传入的对象类型
### 泛型的使用方式
> 泛型类，泛型接口（实现泛型接口，不指定类型；实现泛型接口，指定类型）；泛型方法

* public static < E > void printArray( E[] inputArray ) 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>
* 注解的解析方法：编译期直接扫描（编译器在编译java代码的时候扫描对应的注解并处理，）；运行期通过反射处理（比如@Value@Component）

* spi:服务提供者的接口（专门提供给服务提供者或者扩展框架功能开发者使用的接口）
* spi将服务接口和具体的服务实现分离开
### spi和api的区别
> 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是api，这种接口和实现都是放在实现方
> 当接口存在于调用方这边时，就是spi，由接口调用方确定规则，然后由不同的厂商去根据这个规则对这个接口进行实现

* spi的缺点：需要遍历加载所有的实现类；当多个ServiceLoader同时load时，会有并发问题
* 序列化的主要目的是通过网络传输对象或者将对象存储到文件系统、数据库、内存中

### 如果有些字段不想进行序列化怎么办
> 不想进行序列化的变量，使用transient修饰
> transient：阻止实例中那些使用关键字修饰的变量序列化，当对象被反序列化时，被transient修饰的变量不会被持久化和恢复
> transient只能修饰变量；修饰的变量在反序列化后变量值会被置为类型的默认值

### IO流为什么要分为字节流和字符流
> 字符流是由java虚拟机将字节转换得到的，耗时多
> 当不清楚编码类型时，使用字节流的过程会乱码


* java中将实参传给方法的方式是值传递；如果参数是基本类型，传递的就是基本类型的拷贝，会创建副本；如果参数是引用类型，传递的就是实参所引用对象在堆中的地址的拷贝，同样也会创建副本


### 获取Class对象的四种方式
> 知道具体类的情况：（Class clunbarClass=TargetObject.class）但是一般不知道具体类，基本都是通过遍历包下面的类获取Class对象，通过此方式获取Class对象不会进行初始化
> 通过Class.forName()传入类的全路径获取 Class.forName("cn.javaguide.TargetObject")
> 通过对象实例instance.getClass()获取 TargetObject o=new TargetObject(); Class lc2=o.getClass()
> 通过类加载器xxClassLoader.loadClass()传入类路径获取 ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject") 通过类加载器获取Class对象不会进行初始化，即不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行

## java集合