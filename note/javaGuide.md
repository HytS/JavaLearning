#
##
> 包装类型可以用于泛型，基本类型不可以
> 成员变量包装类型不赋值就是null
> 基本数据类型的局部变量放在jvm栈中的局部变量表中，成员变量（未被static修饰）放在堆中，包装类型属于对象类型，几乎所有对象都放在堆中
### 为什么说几乎所有对象都放在堆中
>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存 

### 包装类型的缓存机制
> java基本数据类型的包装类型的大部分都通过缓存机制提高性能；byte、short、Integer、Long默认创建了数值[-128,127]的相应类型的缓存数据,Character创建了[0，127]的缓存数据，Boolean直接返回true,false
> 如果超出对应范围仍然会去创建对象，缓存范围区间的大小只是性能和资源的博弈
> Float和Double没有实现缓存机制
### 所有整型包装类对象值之间的比较，全部使用equals方法
> 对于Integer var=..在-128-127之间的赋值，Integer对象会在IntegerCache.cache中产生，会复用已有对象，这个区间的Integer值可以使用==直接比较，在此区间之外的数据都会在堆上产生，并不会复用已有对象
>
### 自动拆箱和装箱
> 装箱调用了valueOf，拆箱调用了xxxValue；频繁的拆箱装箱影响性能

### 为什么浮点数运算的时候会有精度丢失的风险
> 无限循环的小数存储在计算机里会被截断，即十进制的浮点数无法转换成二进制小数

### 如何解决浮点数运算的精度丢失问题
> BigDecimal可以实现浮点数的运算，不会造成损失

### 超过 long 整型的数据应该如何表示
> BigInteger内部使用 int[] 数组来存储任意大小的整形数据。