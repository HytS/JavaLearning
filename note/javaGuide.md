#
### jvm、jdk、jre
* jvm是运行java字节码的虚拟机，针对不同系统有特定的实现，目的是使用相同的字节码，它们都会给出相同的结果；字节码和不同系统的jvm实现是java语言的"一次编译，随处可以运行"的关键
* jdk:java sdk jre:java运行环境 jdk包括jre

### 什么是字节码，使用字节码的好处
* jvm可以理解的代码是字节码，它不面向任何特定的处理器，只面向虚拟机，并且字节码并不针对特定的机器
* .class->机器码，第一步是jvm类加载器先加载字节码文件，然后通过解释器解释执行，这种方式速度慢；为了调用热点代码引进了JIT编译器，jit属于运行时编译，第一次编译后，会将字节码对应的机器码保存下来

### java和c++的区别
* java不提供指针来直接访问内存，程序内存更安全
* java的类是单继承，c++支持多重继承；java的接口可以多重继承
* java有自动内存管理垃圾回收机制gc
* c++支持方法重载和操作符重载，java只支持方法重载
### 基本类型和包装类型的区别
> 包装类型可以用于泛型，基本类型不可以
> 基本数据类型的局部变量放在jvm栈中的局部变量表中，基本数据类型的成员变量（未被static修饰）放在java虚拟机的堆中，包装类型属于对象类型，几乎所有对象都放在堆中
> 基本数据类型有默认值，成员变量包装类型不赋值就是null
> 对于包装数据类型，==比较的是内存地址，对于基本数据类型比较的是值；所有整型包装对象之间值的比较，全部使用equals()

### 为什么说几乎所有对象都放在堆中
>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存 

### 包装类型的缓存机制
> java基本数据类型的包装类型的大部分都通过缓存机制提高性能；byte、short、Integer、Long默认创建了数值[-128,127]的相应类型的缓存数据,Character创建了[0，127]的缓存数据，Boolean直接返回true,false
> 如果超出对应范围仍然会去创建对象，缓存范围区间的大小只是性能和资源的博弈
> Float和Double没有实现缓存机制
### 所有整型包装类对象值之间的比较，全部使用equals方法
> 对于Integer var=..在-128-127之间的赋值，Integer对象会在IntegerCache.cache中产生，会复用已有对象，这个区间的Integer值可以使用==直接比较，在此区间之外的数据都会在堆上产生，并不会复用已有对象，推荐使用equals判断
>
### 自动拆箱和装箱
> 装箱：将基本数据类型用它们对应的包装类型包装起来
> 拆箱：将包装类型转换为基本数据类型
> 装箱调用了valueOf，拆箱调用了xxxValue；频繁的拆箱装箱影响性能

### 为什么浮点数运算的时候会有精度丢失的风险
> 计算机再表示一个数字时，宽度有限，无限循环的小数存储在计算机里会被截断，所以会导致小数精度发生损失，即十进制的浮点数无法转换成二进制小数

### 如何解决浮点数运算的精度丢失问题
> BigDecimal可以实现浮点数的运算，不会造成损失

### 超过 long 整型的数据应该如何表示
> BigInteger内部使用 int[] 数组来存储任意大小的整形数据。

### 成员变量和局部变量
> 成员变量：能被访问控制符修饰，是对象的一部分；会自动赋值
> 局部变量：不能被访问控制符和static修饰，随着方法的调用自动生成；不会自动赋值
> 存储方式：如果成员变量被static修饰，成员变量属于类，如果没有被static修饰则属于实例的
### 静态变量
> 被static修饰的变量，它可以被类的所有实例共享，，静态变量只会被分配一次内存
> 静态变量是通过类名访问，如果被private修饰就无法这样访问了
### 静态方法为什么不能调用非静态成员
>  静态方法属于类，在类加载时就会分配内存，可以通过类名直接访问；非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过实例对象去访问
> 在类的非静态成员不存在的时候静态方法已经存在了，此时调用不存在的非静态成员属于非法操作

### 重载和重写
> 重载：同样的一个方法可以根据输入不同的参数得出结果(方法名相同，参数类型、参数个数、参数顺序不同)
> 重载就是同一个类中多种同名方法根据不同传参来执行不同的逻辑处理
> 重写：当子类继承自父类的方法，输入一样的数据要做出不同的处理
> 方法名，参数列表必须相同；子类返回值类型小于父类，抛出异常小于父类。访问修饰符大于父类
> 父类方法修饰符为private、static、final修饰则子类不能重写；构造方法无法重写
> 如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改；如果是引用类型，重写时可以返回引用类型的子类

### 可变长参数
> 允许在调用方法时传入不定长度的参数
> 遇到方法重载时会优先固定参数
> java的可变参数编译后会转换成一个数组  
### 对象实例和对象引用的区别
> 对象实例放在堆中，对象引用放在栈中，一个对象引用可以指向0或1个对象，一个对象可以有多个对象引用
### 对象相等和引用相等的区别
> 对象相等比较的是内存中存放的内容是否相等
> 引用相等比较内存地址是否相等
> ==比较的是内存地址是否相等 equals比较的是内容
> 构造方法完成对象的初始化；构造方法不能重写可以重载
### 继承    
> 父类的私有属性和方法子类无法访问，只是拥有

### 多态特点
> 引用类型变量调用的方法属于哪个类，必须在程序运行期间才能确定
> 多态不能调用只在子类存在但父类不存在的方法

### 接口和抽象类的共同点和区别***
#### 共同点
> 都不能被实例化；都可以包含抽象对象；都可以有默认实现的方法
#### 区别
> 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为；抽象类主要用于代码复用，强调的是所属的关系；
> 接口中的成员变量默认 public static final 不能被修改且有初值；抽象类的成员变量默认default，可在子类中被重新定义，也可以重新赋值


### 深拷贝和浅拷贝****
> 浅拷贝会在堆上创立一个新的对象；如果原对象内部的属性是引用类型，浅拷贝会直接复制内部对象的引用地址，即引用对象和原对象共用同一个内部对象
> 深拷贝会完全复制整个对象，包括这个对象的内部对象
> 引用拷贝就是两个不同的引用指向同一个对象

### ==和equals的区别
* 因为java只有值传递，所以，对于==来说，不管是基本数据类型还是引用数据类型，比较的都是值，基本数据类型，--比较的是值，引用数据类型，==比较的是内存地址
* equals不能用于判断基本数据类型的变量，只能用于判断两个对象是否相等
* 类没有重写equals，通过equals比较两个对象等价于==比较两个对象，使用的默认是Object类equals方法  ；类重写equals，一般重写equals用于比较两个对象的属性是否相等  

* 哈希码的作用是确定该对象在哈希表中的索引位置

### 为什么要有hashcode
* 要以hashset如何检查重复引入：当把对象加入hashset中，hashset会先计算对象的hashcode来判断加入的位置，同时也会与其他对象的hashcode进行比较，如果没有相同的hashcode，hashset会先假设对象没有重复出现，但是如果发现相同的hashcode，会用equals进行检查hashcode相同的对象是否相同，如果相同，hashset不会让其加入成功，如果不同，会重新散列到其他位置  
* 添加元素进入hashSet的过程中，如果hashset在对比时，同样的hashcode有多个对象，会继续使用equals来判断是否真的相同

### 两个对象有相同的hashcode值，他们相等吗
* hashcode使用的哈希算法会让多个对象返回相同的哈希值，越糟糕的算法越容易碰撞
* 两个对象的hashcode值相等，那这两个值也不一定相等
* 两个对象的hashcode值相等不代表两个对象就相等；哈希值相等和equals返回true才代表两个对象相等
### 为什么重写equals()必须要重写hashcode()
* 两个相等的对象的hashcode值必须是相等的    
> 如果重写equals没有重写hashcode，会导致equals判断的是相等的两个对象，hashcode值不相等

### String、StringBuilder、StringBuffer区别
* 操作少量数据 String 线程安全
* 单线程操作字符串缓冲区下操作大量数据 StringBuilder
* 多线程操作字符串缓冲区下操作大量数据 StringBuilder 线程安全

### String为什么是不可变的
> final关键字修饰的数组保存字符串并不是String不可变的根本原因，因为这个数组保存的字符串是可变的
> 保存字符串的数组被final修饰且为私有，并且String类没有提供修改这个字符串的方法
> String类被final修饰，不能被继承，避免子类破坏String不可变

* 字符串对象通过+的字符串拼接方式，实际上是StringBuilder的append方法实现的，然后用toString得到String对象
* 在循环中使用+进行字符串拼接会造成‘创建过多的StringBuiler对象’
* 字符串常量池主要目的是避免字符串的重新创建

### String s1=new String("abc") 创建了几个对象
> 会创建一个或两个
> 如果常量池不存在字符串对象abc，会在堆中创造两个字符串对象abc
> 如果常量池已存在字符串对象abc的引用，只会在堆中创建一个字符串对象abc

### intern方法的作用
* intern() 将指定的字符串对象的引用保存在常量池中，分为两种情况：
* 如果常量池中保存了对应的字符串，直接返回该引用
* 如果常量池没有保存对应字符串，就在常量池创建一个指向该字符串对象的引用，并返回

### String类型的变量和常量做+运算时发生什么
* 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。
* 在编译过程中，javac会进行常量折叠的代码优化，常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中（String str3="str"+"ing" 优化为 String str3="string"），这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。但是并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：1、基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。2、final 修饰的基本数据类型和字符串变量。3、字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）
* 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。被 final 关键字修改之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。
* 对象引用和+的字符串的拼接方式，实际上是通过StringBuilder和append方法实现的，拼接完成后调用toString得到一个String对象

### checked Exception unchecked Exception有什么区别
> checked Exception是受检查异常，java代码在编译过程中，如果受检查异常没有被catch或throws处理的话，则无法通过编译；除了RuntimeException及其子类以外，其他的Exception类及其子类都是受检查异常
> java在编译时，不处理不受检查异常也可以通过编译；常见的有空指针错误、数组越界错误、参数错误、字符串转换为数字格式错误

### Throwable类常用方法有哪些
> String getMessage() 返回异常发生时的简要描述
> Stirng toString() 返回异常发生时的详细信息
> String getLocalizedMessage() 返回异常对象的本地化信息
> void printStackTrace() 在控制台上打印Throwable对象封装的异常信息

* 注意：不要在finally语句块中使用return，当try和finally语句中都存在return时，try中的return会被忽略，因为try中的return返回值会被暂存到一个本地变量中，当执行到finally中的return时，本地变量的值就变成了finally中的return值
* finally中的代码不一定会被执行，比如finally之前虚拟机被终止运行，则finally中的代码就不会执行；或者程序所在线程死亡、关闭cpu都会导致finally不被执行
### finally中的代码一定会被执行吗
不一定！比如说finally之前虚拟机被终止运行的话，finally中的代码不会被运行
或者程序所在线程死亡、关闭cpu

### 异常的注意事项
不要把异常定义为静态变量，这样会导致栈信息错乱；每次手动抛出异常都需要new一个异常对象抛出
使用日志打印异常之后就不要再抛出异常了（二者不要同时出现同一段代码逻辑中）

* 编译器可以通过泛型参数可以指定传入的对象类型
### 泛型的使用方式
> 泛型类，泛型接口（实现泛型接口，不指定类型；实现泛型接口，指定类型）；泛型方法
```
class GeneratorImpl<T> implements Generator<T>{
    @Override
    //不指定类型
    public T method() {
        return null;
    }
}
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}

```
* public static <E> void printArray( E[] inputArray ) 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>
* 注解的解析方法：编译期直接扫描（编译器在编译java代码的时候扫描对应的注解并处理，）；运行期通过反射处理（比如@Value@Component）

* spi:服务提供者的接口（专门提供给服务提供者或者扩展框架功能开发者使用的接口）
* spi将服务接口和具体的服务实现分离开
### spi和api的区别
> 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是api，这种接口和实现都是放在实现方
> 当接口存在于调用方这边时，就是spi，由接口调用方确定规则，然后由不同的厂商去根据这个规则对这个接口进行实现

* spi的缺点：需要遍历加载所有的实现类；当多个ServiceLoader同时load时，会有并发问题
* 序列化的主要目的是通过网络传输对象或者将对象存储到文件系统、数据库、内存中

### 如果有些字段不想进行序列化怎么办
> 不想进行序列化的变量，使用transient修饰
> transient：阻止实例中那些使用关键字修饰的变量序列化，当对象被反序列化时，被transient修饰的变量不会被持久化和恢复
> transient只能修饰变量；修饰的变量在反序列化后变量值会被置为类型的默认值

### IO流为什么要分为字节流和字符流
> 字符流是由java虚拟机将字节转换得到的，耗时多
> 当不清楚编码类型时，使用字节流的过程会乱码


* java中将实参传给方法的方式是值传递；如果参数是基本类型，传递的就是基本类型的拷贝，会创建副本；如果参数是引用类型，传递的就是实参所引用对象在堆中的地址的拷贝，同样也会创建副本


### 获取Class对象的四种方式
> 知道具体类的情况：（Class clunbarClass=TargetObject.class）但是一般不知道具体类，基本都是通过遍历包下面的类获取Class对象，通过此方式获取Class对象不会进行初始化
> 通过Class.forName()传入类的全路径获取 Class.forName("cn.javaguide.TargetObject")
> 通过对象实例instance.getClass()获取 TargetObject o=new TargetObject(); Class lc2=o.getClass()
> 通过类加载器xxClassLoader.loadClass()传入类路径获取 ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject") 通过类加载器获取Class对象不会进行初始化，即不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行

## java集合
### List、Set、Queue、Map
* List存储的元素有序、可重复
* Set存储的元素不可重复
* Queue按特定的排队规则确定先后顺序，存储的元素有序可重复
* Map使用键值对存储，key无序不可重复，value无序可重复

### 集合框架底层数据结构总结
List：ArrayList Object[] Vector Object[] LinkedList 双向链表
Set：1、HashSet（无序唯一） 基于HashMap实现，底层采用HashMap存储元素 2、LinkedHashSet 是HashSet的子类，其内部是通过LinkedHashMap来实现的，3、TreeSet（有序唯一）红黑树
Queue：1、priorityQueue Object[]数组实现二叉堆2、ArrayQueue Object[] 数组+双指针
Map：1、HashMap jdk1.8之前HashMap有数组+链表组成，数组是HashMap的主体，链表是为了解决哈希冲突而存在的；1.8之后解决哈希冲突有了较大变化，当链表长度>8（将链表转成红黑树前会判断，如果当前数组长度小于64，那么会先进行数组扩容，而不是转换为红黑树）2、LinkedHashMap 继承自HashMap，所以底层仍然是基于由数组和链表或红黑树组成，LinkedHashMap在上面的基础上，增加了一条双向链表 3、Hashtable 数组+链表组成，数组是Hashtable的主体，链表是为了解决哈希冲突存在的4、TreeMap 红黑树

### 如何选用集合
我们需要根据键值获取到元素值时就采用Map接口下的集合
    排序TreeMap   不排序 HashMap  保证线程安全 ConcurrentHashMap
我们只需要存放元素时，就选择Collection接口下的集合
    保证元素唯一时，选择Set接口的TreeSet、HashSet 不需要就选择List接口的ArrayList、LinkedList
### 为什么要使用集合
当我们要存储一组数据类型相同的数据是，数组有不足。java集合提高了灵活性

### ArrayList和Array区别
ArrayList允许使用泛型确保类型安全，Array不可以
ArrayList只允许存储对象，对于基础数据类型要使用对应的包装类，Array可以直接存储基本数据类型也可以存储对象
ArrayList创建时不需要指定大小，Array创建时必须指定大小
ArrayList支持插入删除操作，Array只是一个固定长度的数组，只能按下标访问元素

ArrayList可以添加null值，但是不建议添加；ArrayList中可以存储任何类型的对象

### LinkedList为什么不能实现RandomAccess接口
RandomAaccess时一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引访问元素），由于LinkedList底层是链表，内存地址不连续，只能通过指针来定位，故不能实现接口

RandomAccess是一个标识，标识实现这个接口的类具有随机访问功能

### ArrayList、LinkedList区别
都不能保证线程安全；ArrayList底层是Object[] LinkedList底层是双向链表


### Comparable和Comparator的区别
都是java中用于排序的接口；Comparable接口出自java.lang包，使用compareTo(Object obj)进行排序
Comparator接口出自java.util包，它有一个compare(Object obj1,Object obj2)进行排序
一般我们需要堆一个集合使用自定义排序时，我们就要重写compareTo、compare方法，当我们需要对某一个集合实现两种排序方式，我们可以重写compareTo方法和使用自制的Comparator方法（只能使用两个参数版的Collections.sort()）

### 无序性和不可重复性
无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的
不可重复性是指添加的元素按照equals判断时返回false，需要重写equals和hashcode

### HashSet、LinkedHashSet、TreeSet异同
都是Set接口的实现类，都能保证元素唯一，都不是线程安全
HashSet底层结构是哈希表（基于HashMap实现）LinkedHashSet底层结构是链表和哈希表 TreeSet底层结构是红黑树，元素是有序的，排序方式有自然排序和定制排序
HashSet用于不需要保证元素插入和取出顺序的场景 LinkedHashSet用于保证元素插入和取出顺序满足FIFO TreeSet用于支持对元素进行自定义排序规则的场景

### HashMap和Hashtable区别
HashMap非线程安全，Hashtable线程安全，因为Hashtable内部的方法基本上都经过synchronized的修饰
由于线程安全的关系，HashMap效率比Hashtable高
HashMap可以存储null的key和value，但null做键只能有一个，null做值可以有多个；Hashtable不允许有null键和null值，否则会抛出NullPointException
1、创建时如果不指定容量初始值，Hashtable默认初始大小为11，之后每次扩充，容量变为原来的2n+1;HashMap初始大小为16，之后每次扩容，容量变为原来的2倍
2、创建时如果指定容量初始值，那么Hashtable会直接使用给定的大小，而HashMap会将其扩充为2的幂次方大小
jdk8之后HashMap：当链表长度大于8，将链表转化为红黑树（将链表转化为红黑树前会判断，如果当前数组长度小于64，则会选择先对数组扩容，而不是转化为红黑树）Hashtable没有这样的机制

### HashMap和HashSet区别
HashSet底层基于HashMap实现；实现Set接口、仅存储对象、调用add()向set中添加元素、HashSet使用成员对象来计算hashcode值，对两个对象来说hashcode可能相等，所以equals用来判断对象的相等性
HashMap实现了Map接口、存储键值对、调用put向map中添加元素、HashMap使用键计算hashcode

### HashMap和TreeMap区别
实现NavigableMap接口让TreeMap有了对集合内元素的搜索能力
实现SortedMap接口让TreeMap有了对集合中的元素根据键排序的能力，默认是按key的升序排序，也可以指定排序的比较器

### HashSet如何检查重复
当把对象加入HashSet时，HashSet会先计算hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现，但是如果发现相同的hashcode值的对象，就会用equals进行检查hashcode值相同的对象是否真的相同，如果两者相同，HashSet就不会让加入操作成功
### HashMap的底层实现
jdk1.8之前：HashMap底层时数组和链表结合在一起的链表散列，HashSet通过key的hashcode经过扰动函数处理过后得到hash值，然后（n-1）&hash判断当前元素存放的位置（n是指数组长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同直接覆盖，不相同用拉链法解决

拉链法：创建一个数组，数组的每一格就是一个链表，若是遇到哈希冲突，则将冲突的值加入到链表中即可

jdk1.8之后，当链表长度大于8但是数组长度小于64会先进行数组扩容，而不是转化为红黑树

### HashMap的长度为什么是2的幂次方


### HashMap多线程操作导致死循环
由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置从而形成唤醒链表；
多线程下，建议使用ConcurrentHashMap


### HashMap为什么线程不安全
### HashMap常见的遍历方式


HashSet、TreeSet、ArrayList、LinkedList、HashMap、TreeMap都是线程不安全的

### java集合使用注意事项


### ArrayList可以添加null吗
ArrayList可以存储任何类型的对象，包括null，不建议添加null

### ArrayList和LinkedList区别
都不能保证线程安全；ArrayList底层使用的是 Object[] LinkedList使用的是双向链表

### ArrayList核心源码

### ArrayList的扩容机制
以无参构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，数组容量扩为10

### 什么是进程、线程
进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序是进程从创建、运行到消亡的过程

同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的pc、虚拟机栈和本地方法栈，所以系统在产生一个线程或是在各个线程之间切换工作时，负担要比进程小得多，所以线程被称为轻量级进程

java程序天生就是多线程程序
一个java程序的运行时main线程和多个其他线程同时运行

### 线程和进程的关系
线程是进程划分成的更小的运行单位，线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响，线程开销小，但不利于资源的管理和保护；而进程正相反

### 程序计数器为什么是私有的
为了线程切换后能恢复到正确的执行位置
pc的作用：1、字节码解释器通过改变pc来一次读取指令，从而实现代码的流程控制2、在多线程的情况下，pc用于记录当前线程执行位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了

需要注意，如果执行的是native方法，那么pc记录的是undefined地址，只有执行java代码时pc记录的才是下一条指令的地址

### 虚拟机栈和本地方法栈为什么是私有的
为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的

虚拟机栈：每个java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机栈中入栈和出栈的过程
本地方法栈：虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机使用到的native方法服务

堆和方法区是所有线程共享的资源，其中堆是最大的一块内存，主要用于存放新创建的对象（几乎所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

### 并发和并行的区别
并发：两个及两个以上的作业在同一时间段内执行
并行：两个及两个以上的作业在同一时刻执行

### 同步和异步的区别
同步：发出一个调用后，在没有得到结果之前，该调用就不可以返回，一直等待
异步：调用在发出之后，不用等待返回结果，该调用直接返回

### 为什么要使用多线程

### 使用多线程会带来什么问题
并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度，而且并发编程会遇到一些问题，比如死锁、内存泄漏

### 如何理解线程安全和不安全
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述
线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性
线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问可能会导致数据混乱、错误或者丢失

### 线程的生命周期和状态
初始态（线程被创建出来但没有调用start()）
运行态（线程调用了start()等待运行的状态）
阻塞态（等待锁释放）
等待状态（表示该进程需要等待其他线程多出一些特定动作）
超时等待状态（可以在指定的时间后自行返回而不是像等待状态那样一直等待）
终止状态（线程已经运行完毕）

线程在生命周期中并不是固定处于某一状态而是随着代码的执行在不同状态之间切换  

### 什么时线程上下文切换
线程在执行过程中会有自己的运行条件和状态（也称上下文）
当出现如下情况，线程会从占用cpu状态退出。
1、主动出让cpu2、时间片用完3、调用了阻塞类型的系统中断4、被终止或结束运行
这其中前3种都会发生线程切换，线程切换意味着需要保存当前进程的上下文，留待线程下次占用cpu时恢复现场，并加载下个将要占用cpu的线程上下文，这就是上下文切换

因为上下文切换每次都需要保存信息恢复信息，意味着效率会有损耗，如果频繁操作会导致效率低下

### 什么是线程死锁，如何避免死锁
多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放，由于线程被无限期的阻塞，所以程序不可能正常终止

预防死锁：破坏请求和保持条件（一次性申请所有资源）
破坏不剥夺条件（占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它所占有的资源）
破坏循环等待条件（靠按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放）

避免死锁：银行家算法

### sleep()和wait()的区别
共同点：两者都可以暂停线程的执行
区别：sleep没有释放锁，wait释放了锁
wait通常被用于线程间通信，sleep被用于暂停执行
wait被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify或者notifyAll；sleep调用后，线程会自然苏醒
sleep是Thread类的静态本地方法，wait是Object类的本地方法


### 为什么wait方法不在Thread中
wait是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁，每个对象都有对象锁，既然要释放当前线程占有的对象锁并让其进入等待状态，自然要操作对应对象而非当前线程

sleep是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁

### 可以直接调用Thread类的run方法吗
调用start方法方可启动线程并使线程进入就绪状态，直接执行run方法的话不会以多线程的方式执行

new一个Thread，线程进入新建状态，调用start方法，会启动一个线程并使线程进入就绪状态，当分配到时间片就可以开始运行了，start会执行相应准备工作，然后自动执行run方法的内容，这是真正的多线程工作；直接执行run方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作

### volatile
#### 如何保证变量的可见性
在java中，volatile可以保证变量的可见性，如果我们将变量声明为volatile，这就指示jvm，这个变量是共享且不稳定的，每次使用它都到主存中进行读取

volatile能保证数据的可见性，但是不能保证数据的原子性。synchronized两者都能保证

#### 如何禁止指令重排序
在java中，volatile除了可以保证变量的可见性，还可以防止jvm的指令重排序。如果我们将变量声明为volatile，在对这个变量进行读写操作的时候，会通过插入特定的内存屏障的方式来禁止指令重排序

jvm具有指令重排的特性，执行顺序会发生改变，导致一些问题

#### volatile可以保证原子性吗
volatile能保证变量的可见性，但不能保证对变量的操作是原子性的

### 什么是悲观锁
悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候都会出现问题，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到上个持有者释放，即共享资源一次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程
像java中的synchronized和ReentrantLock等独占锁就是悲观锁思想的实现

高并发场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统性能开销，并且，悲观锁会存在死锁问题

### 什么是乐观锁
乐观锁总是假设最好的情况，认为共享资源每次被访问时都不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源是否被其他线程修改了
在java中java.util.concurrent.atomic包下面的原子变量类就是用了乐观锁的一种实现方式CAS实现的

高并发场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更好，但是如果冲突频繁发生（写占比非常多），会频繁失败和重试，这样同样会非常影响性能

理论上来说：
悲观锁通常用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试的问题，也可以考虑使用乐观锁

乐观锁通常用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能；不过，乐观锁主要针对的对象是单个共享变量

### 如何实现乐观锁
乐观锁一般使用版本号机制或CAS算法实现，CAS算法相对来说多一点
版本号机制：一般在数据表中加上一个数据版本号version字段，表示数据被修改的次数。当数据被修改时version值+1.当线程A要更新数据值时，在读取数据的同时会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功

### 乐观锁存在那些问题


构造方法不能使用synchronized修饰。因为构造方法本身就属于线程安全的，不存在同步的构造方法一说

###  synchronized的底层原理
底层原理属于jvm层面的东西

synchronized同步语句块
    public class SynchronizedDemo {
        public void method() {
            synchronized (this) {
                System.out.println("synchronized 代码块");
            }
        }
    }

当执行monitorenter指令时，线程试图获得锁也就是获得对象监视器monitor的持有权
在java虚拟机中，Monitor是基于c++实现的，每个对象中都内置了一个ObjectMonitor对象，wait/notify等方法也依赖monitor对象，这也是为什么只有在同步的块或方法中才能调用wait/notify，否则抛出异常

在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为0则表示锁可以被获取，获取后将锁的计数器设为1
对象锁的拥有者线程才可以执行monitorexit指令来释放锁，在执行monitorexit后，将锁计数器设为0，表明锁被释放；如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止

ACC_SYNCHRONIZED标识了该方法是一个同步方法，jvm通过该标识来辨认一个方法是否声明为同步方法，从而执行相应的同步调用；如果是实例方法，jvm会尝试获取实例对象的锁，如果是静态方法，jvm会尝试获取当前class的锁

synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指向同步代码块开始的位置，monitorexit指向同步代码块结束位置
synchronized修饰的方法并没有monitorenter指令和monitorexit指令，使用ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法

### jdk1.6之后的synchronized底层做了那些优化
对锁的实现引入优化；锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级

### synchronized和volatile的区别
synchronized和volatile是两个互补的存在，不是对立的存在
volatile是线程同步的轻量级实现，所以volatile性能比synchronized好，但是volatile只能用于变量而synchronized可以修饰方法和代码块
volatile只能保证数据的可见性，但不能保证数据的原子性，synchronized两者都能保证
volatile主要用于解决变量在多个线程之间的可见性，而synchronized解决的是多个线程之间访问资源的同步性


### ReentrantLock

### ReentrantReadWritrLock
ReentrantReadWritrLock实现了ReadWriteLock，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全

### ThreadLocal用处
通常情况下，我们创建的变量是可以被任何一个线程访问并修改的，如果想实现每一个线程都有自己专属的本地变量该如何解决；ThreadLocal类就是解决这类问题
ThreadLocal类主要解决让每个线程绑定自己的值，可以将ThreadLocal类比喻成存放数据的盒子，盒子中可以存放每个线程的私有数据
如果创建了一个ThreadLocal变量，访问这个变量的每个线程都会有这个变量的本地副本。他们可以使用get()和set()获取默认值或将其值改为当前线程所存副本的值，从未避免线程安全的问题

### 如何使用ThreadLocal
Thread类中有一个threadLocals和inheritableThreadLocals变量，都是ThreadLocalMap类型的变量，默认这两个变量都是null，只有当前线程调用ThreadLocal类的set或get才创建他们，实际调用get和set时，调用的是ThreadLocalMap的set和get
ThreadLocal只是ThreadLocalMap的封装，传递了变量值；ThreadLocal类可以通过THread.currentThread()获取到当前线程对象，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象
每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key，Object对象为value的键值对

### ThreadLocal内存泄漏问题怎么导致
ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收时，key会被清理掉，value不会被清理掉
这样，ThreadLocalMap中就会出现key为null的entry，如果不做任何措施，value将永远无法被gc回收，这个时候就会出现内存泄漏。ThreadLocalMap实现中已经考虑这种情况，在调用set、get、remove等方法时，会清理掉key为null的记录，使用完ThreadLocal方法后最好手动调用remove()

如果一个对象只具有弱引用，那就类似于可有可无的生活用品，弱引用和软引用的区别在于：只具有弱引用的对象拥有更短暂的声明周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前那内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象

### 什么是线程池
线程池就是管理一系列线程的资源池，当有任务要处理时，直接从线程池中获取线程来处理，处理完后的线程并不会立即被销毁，而是等待下一个任务

### 为什么要用线程池
池化技术的思想主要是为了减少每次获取资源的消耗，提高资源的利用率

线程池提供了一种限制和管理资源的方式。每个线程池还维护一些基本统计信息
使用线程池的好处：降低资源消耗、提高响应速度、提高线程的可管理性

### 如何创建线程池
1、使用ThreadPoolExecutor构造函数创建 2、通过Executor框架的工具类Executors来创建

### 为什么不推荐使用内置线程池
线程资源必须通过线程池提供，不允许在应用中自行显式创建线程

为什么：使用线程池的好处是减少创建和销毁线程上所消耗的时间和系统资源开销，解决资源不足，如果不使用线程池，可能会造成系统创建大量同类线程而导致消耗完内存


