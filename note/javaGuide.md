#
##
> 包装类型可以用于泛型，基本类型不可以
> 成员变量包装类型不赋值就是null
> 基本数据类型的局部变量放在jvm栈中的局部变量表中，成员变量（未被static修饰）放在堆中，包装类型属于对象类型，几乎所有对象都放在堆中
### 为什么说几乎所有对象都放在堆中
>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存 

### 包装类型的缓存机制
> java基本数据类型的包装类型的大部分都通过缓存机制提高性能；byte、short、Integer、Long默认创建了数值[-128,127]的相应类型的缓存数据,Character创建了[0，127]的缓存数据，Boolean直接返回true,false
> 如果超出对应范围仍然会去创建对象，缓存范围区间的大小只是性能和资源的博弈
> Float和Double没有实现缓存机制
### 所有整型包装类对象值之间的比较，全部使用equals方法
> 对于Integer var=..在-128-127之间的赋值，Integer对象会在IntegerCache.cache中产生，会复用已有对象，这个区间的Integer值可以使用==直接比较，在此区间之外的数据都会在堆上产生，并不会复用已有对象
>
### 自动拆箱和装箱
> 装箱调用了valueOf，拆箱调用了xxxValue；频繁的拆箱装箱影响性能

### 为什么浮点数运算的时候会有精度丢失的风险
> 无限循环的小数存储在计算机里会被截断，即十进制的浮点数无法转换成二进制小数

### 如何解决浮点数运算的精度丢失问题
> BigDecimal可以实现浮点数的运算，不会造成损失

### 超过 long 整型的数据应该如何表示
> BigInteger内部使用 int[] 数组来存储任意大小的整形数据。


### 对象实例和对象引用的区别
> 对象实例放在堆中，对象引用放在栈中，一个对象引用可以指向0或1个对象，一个对象可以有多个对象引用
### 对象相等和引用相等的区别
> 对象相等比较的是内存中存放的内容是否相等
> 引用相等比较内存地址是否相等

> 构造方法完成对象的初始化
> 父类的私有属性子类无法访问

### 多态特点
> 引用类型变量调用的方法属于哪个类，必须在程序运行期间才能确定
> 多态不能调用只在子类存在但父类不存在的方法

### 接口和抽象类的共同点和区别
#### 共同点
> 都不能被实例化；都可以包含抽象对象；都可以有默认实现的方法
#### 区别
> 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为；抽象类主要用于代码复用，强调的是所属的关系；
> 接口中的成员变量默认 public static final 不能被修改且有初值；抽象类的成员变量默认default，可在子类中被重新定义


### 深拷贝和浅拷贝
> 浅拷贝会在堆上创立一个新的对象；如果原对象内部的属性是引用类型，浅拷贝会直接复制内部对象的引用地址，即引用对象和原对象共用同一个内部对象
> 深拷贝会完全复制整个对象，包括这个对象的内部对象
> 引用拷贝就是两个不同的引用指向同一个对象


* 因为java只有值传递，所以，对于==来说，不管是基本数据类型还是引用数据类型，比较的都是值
* 类没有重新equals，通过equals比较两个对象等价于==比较两个对象；类重写equals，一般重写equals用于比较两个对象的属性是否相等  
* 两个对象的hashcode值相等不代表两个对象就相等；哈希值相等和equals返回true才代表两个对象相等

### 为什么重写equals()必须要重写hashcode()
> 如果重写equals没有重写hashcode，会导致equals判断的是相等的两个对象，hashcode值不相等

### String为什么是不可变的
> 保存字符串的数组被final修饰且为私有，并且String类没有提供修改这个字符串的方法
> String类被final修饰，不能被继承，避免子类破坏String不可变


* 字符串常量池主要目的是避免字符串的重新创建

### String s1=new String("abc") 创建了几个对象
> 会创建一个或两个
> 如果常量池不存在字符串对象abc，会在堆中创造两个字符串对象abc
> 如果常量池已存在字符串对象abc的引用，只会在堆中创建一个字符串对象abc

* intern() 将指定的字符串对象引用保存在常量池中，
* 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。final 修饰的基本数据类型和字符串变量。字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）
* 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。被 final 关键字修改之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。