# java
### 变量、数据类型
* java整数类型默认int
* java浮点数类型默认double，若要声明为float，需要在数据后加F
#### 输入
* Scanner

### 类型转换
* 基本类型转String
```
int n1=100;
String str=n1+"";
```
* 基本数据类型的包装类
```
String str1="123";
int n2=Interge.parseInt(str1);

str1.charAt(0);//取得str1的第一个字符
```

### 数组与排序
#### 数组
* 数组是引用类型
* 数组的初始化
```
int a[]=new int[4];
int[] b=new int[5];
```
* 基本数据类型赋值是值拷贝，引用数据类型赋值是地址拷贝
### 类
* 创建对象时会先加载类信息，分配空间，最后把地址分配给引用
* 对象的属性默认值，遵守数组规则 int 0 char \u0000


### 方法详解

#### 方法的调用机制
* 运行方法时会生成一个独立空间（在栈中），不同于main空间，main也在栈中
* 方法执行完毕时，就会返回到调用方法的位置，然后独立空间销毁
* 方法不能嵌套定义
* 同一个类的方法可以直接调用，跨类的方法要创建对象才能访问

#### 细节
* 方法区里常量池里存放字符；方法区里加载类的信息
* 属性==成员变量==field
* 调用带参数的方法时，一定要对应着参数列表的相同类型或者兼容类型

### 重载
* 方法重载：允许同一个类中多个同名方法的存在，但要求形参列表不同
* 比如println就使用了重载，可以输出不同数据类型的数据
#### 方法重载细节
* 方法名必须相同；形参列表必须不同，顺序、数据类型、个数至少有一个不同
* 返回类型不是构成方法重载的条件

### 可变参数与作用域

#### 可变参数
* 可变参数：java允许将同一个类中多个同名同功能，但是参数个数不同的方法封装成一个方法
* 使用可变参数时可以把他们当作数组使用
* 可以接收多个int   int...表示接受多个参数

##### 可变参数细节
* 实参可以时0或者多个，可变参数的实参可以是数组
* 本质就是数组，可变参数可以和普通类型的参数一起放在
* 形参列表，但是可变参数要放在最后
* 一个形参列表只有一个可变参数

#### 作用域
* 局部变量：一般指在成员方法中定义的变量，局部变量没有默认值，不可以被其他类使用
* 全局变量：就是属性，作用域是整个类体，有默认值，可以被本类或其他类使用
* 属性和局部变量可以重名,访问时遵循就近原则
* 局部变量不可以重名
* 运行方法后，局部变量会被销毁，全局变量不会被销毁
* 属性可以加修饰符，局部变量不可以加修饰符
* 属性伴随着对象的创建而创建，伴随着对象的销毁而销毁，局部变量随着代码块的结束而销毁
* 全局变量可以在本类或其他类使用，局部变量只能在本类对应的方法中使用
         
### 构造器与对象创建

#### 构造器
* 构造器没有返回值，修饰符可以默认，方法名和类名一致
* 构造器的调用由系统完成
* 一个类可以定义多个不同的构造器，即构造器重载
* 构造器是完成对象的初始化，不是创建对象
* 在创建对象时，系统自动的调用该类的构造方法
* 如果没有定义构造器，就会默认构造一个无参构造器
* 自己定义了构造器就会覆盖了默认定义的无参构造器，若要使用默认的无参构造器，需要显式的定义
#### 对象创建流程
* 加载类信息只会加载一次，在堆中分配空间/地址，
* 进行默认初始化（即0和null），然后显式初始化，构造器初始化
* 再把堆中的地址返回给对象引用/对象名

### this
* jvm会给每个对象分配this
* 那个对象调用，this就表示那个对象
#### this的内存表示图

#### 细节
* this关键字可以用来访问本类的属性、方法、构造器
* this可以用来区分属性和局部变量
* this可以访问成员方法 this.方法名(参数列表)
* this访问构造器语法  this(参数列表)；只能在构造器中使用
* this不能在类定义的外部使用，只能在类定义的方法中使用
* 如果要访问构造器，必须放在第一条语句，必须放在构造器中
* this只能在类定义的内部使用

### 包
#### package
需要放在第一行
improt指令位置要放在package的下面，在类定义前面，可以有多句且没有顺序要求

### 封装
* 对属性进行封装，使得属性信息规范化

### 访问修饰符

> public 公开 都可以
> protected 受保护 同类、同包、子类可以
> 默认 没有修饰符 同类、同包可以  子类、不同包不可
> private 私有 只可同类

> 只有默认的和public可以修饰类
> 方法也同理


- 封装和继承
- 把属性和方法封装在一起
- 封装的步骤
- Ⅰ 将属性私有化；提供一个公共的set方法，用于对属性判断并赋值
- Ⅱ 提供一个公共的get方法，用于获取属性的值
```
public void setxxx(类型 参数名){
    属性=参数名；
}
public void getxxx(类型 参数名){
    return xx;
}

```

- 可以将构造器与set方法结合
  
### 继承
* 子类会自动拥有父类定义的属性方法
* 子类不能直接访问私有属性和方法，要通过父类提供公共的方法去访问
* 创建子类对象，子类会先调用父类的构造器，完成父类的初始化，再去调用子类的构造器
* 创建子类对象时，不管使用子类哪个构造器，默认情况都会先去调用父类的无参构造器，如果父类没有提供无参构造器，就必须在子类的构造器中用super指定使用父类的哪个构造器完成对父类的初始化，否则编译不通过。
* 比如默认构造器被覆盖，就要使用super(构造器参数)进行初始化

* super();默认调用父类的无参构造器，什么都不写，默认调用super()
* 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)
* super在使用时，需要放在构造器第一行
* super(),this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器中
* 子类的调用不限于直接父类，会往上追述到Object类   
* 子类最多只能继承一个父类，即单继承机制
* 子类和父类必须满足 is-a的逻辑关系,person is a music?

#### 继承的本质
* 按照查找关系来返回信息
* Ⅰ 查看子类是否有该属性
* Ⅱ 如果子类有，并且可以访问，则返回信息
* Ⅲ 如果子类没有就查看父类



### super
- 代表父类的引用，用于访问父类的属性方法构造器
- 不能访问父类的私有属性  super.属性名
- 不能访问父类的私有方法  super.方法名(参数列表)
- 访问构造器时，必须放在第一句  super(参数列表)

> detail
>> 好处：父类的属性由父类初始化，子类由子类初始化
>> 子类和父类的属性方法重名时，为了访问父类成员，需要用super进行访问，如果没有重名，super，this，直接访问的效果都是一样的
>> super的访问不限于直接父类，如果爷爷类和本类有同名的成员也可以使用super去访问爷爷类的成员；如果上级类中都有同名的成员，使用super访问就近原则

### super和this的区别
|区别点|this|super|
|:---|:---|:---|
|访问属性|访问本类属性，若无择从父类查找|从父类查找属性
|调用方法|访问本类的方法，若无则从父类查找|从父类查找方法
|调用构造器|调用本类构造器，必须放在构造器第一行|调用父类构造器，必须放在子类构造器第一行
|特殊|表示当前对象|子类访问父类的对象



- cal()找方法时，如果本类有，就调用，如果没有就去父类找
- this.cal() 同上
- super.cal() 直接查找父类，其他的规则一样
  - 

### 方法重写/覆盖
* 子类有个方法和父类某个方法名、返回类类型、参数一样，则说子类这个方法覆盖了父类的方法
  
> detail
> 子类的返回类型和父类一样，或者子类的返回类型时父类返回类型的子类
> 子类不能缩短父类的访问权限

* 重写和重载的比较
* 重写：覆盖掉  重载：
  

|名称|发生范围|方法名|形参列表|返回类型|修饰符|
|------|------|------|------|------|------|
|重载overload|本类|必须一样|类型、个数、顺序至少有一个不同|无要求|无要求
|重写override|父子类|必须一样|相同|子类和父类平级或者次于父类|子类方法不能缩小父类方法的访问范围


### 多态
* 解决代码复用性不高的问题
#### 方法的多态
* 通过不同的参数去调用不同的方法，体现多态（方法的重载）
* 重写体现多态：子类和父类各自执行各自的方法（）

#### 对象的多态
* 一个对象的编译类型和运行类型可以不一致
```
Animal animal=new Dog();//父类的引用可以指向子类的对象；编译类型是Animal，运行类型是Dog
animal=new Cat();//运行类型是Cat，编译类型还是Animal，访问属性看编译类型
animal.cry();//cry()方法跟着运行类型保持一致
```
* 编译类型在定义对象时就确定了
* 运行类型是可以变化的
* 编译类型看定义时=号的左边，运行类型看=号的右边

* 多态的前提：两个对象/类存在继承关系
##### 多态的向上转型
* 本质：父类的引用指向子类的对象
* 语法：父类类型 引用=new 子类类型();
* 特点：编译类型看左边，运行类型看右边，可以调用父类的所有成员，不能调用子类的特有成员，可以调用父类里有的在子类里重写的方法。最终运行效果看子类的具体实现
* 在编译阶段，能调用哪些成员由编译类型决定；但是调用成员方法的规则仍旧和方法调用规则一样；编译阶段由javac主导，运行阶段由java
* 方法的调用看运行类型

##### 向下转型
* 语法：子类类型 引用名=(子类类型)父类类型;
```
Cat cat=(Cat)animal;编译类型是Cat，运行类型也是Cat
```
* 只能强转父类的引用，不能强转父类的对象，对象无法改变
* 要求父类的引用必须指向的是当前目标类型的对象
```
//要求
Animal animal = new Cat();
Cat cat =(Cat)animal;//可以，子类父类可以互相转
Dog dog=(Dog)animal;//子类之间不可以互相转

```
* 向下转型后，可以调用子类类型中所有的成员 


##### 属性重写
* 属性的值看编译类型，属性没有重写问题
* instanceOf比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的子类型

##### java的动态绑定机制
* 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
* 当调用对象属性时，没有动态绑定，哪里声明，哪里使用


##### 多态数组√


##### 多态参数√
* 方法定义的形参类型为父类类型，实参类型为子类类型


### ==运算符和equals
> ==运算符
* 既可以判断基本类型，又可以判断引用类型
* 如果判断基本类型，判断的是值是否相同
* 如果判断引用类型，判断的是地址是否相同，即判定是不是同一个对象

> equals
* 是Object类中的方法，只能判断引用类型，默认判断的是地址是否相同，子类一般重写该方法，用于判断内容是否相同
* 重写equals


### hashcode|toString|finalize
#### hashcode()
* 可以当作地址看，但是不是地址
* 小结
* 提高具有哈希结构的容器的效率
* 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
* 两个引用，如果指向的是不同对象，则哈希值是不一样的
* 哈希值主要根据地址号来的，不能完全将哈希值等价于地址

* 面试常见问题：讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？


#### toString
* 返回全类名+@+哈希值的十六进制
* 
* 重写toString，输出对象的属性
* 直接输出一个对象，默认调用toString


##### finalize
* 垃圾回收期，当垃圾回收器确定不存在对该对象的更多引用时
* 对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法
* 什么时候被回收：当某个对象没有任何引用时，jvm就认为这个对象是一个垃圾对象,销毁对象前，会调用该对象的finalize方法
* 垃圾回收期机制的调用，是由系统来决定（有自己的算法），也可以通过system.gc()