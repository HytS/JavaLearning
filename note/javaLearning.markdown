# java
### 变量、数据类型
* java整数类型默认int
* java浮点数类型默认double，若要声明为float，需要在数据后加F
#### 输入
* Scanner

### 类型转换
* 基本类型转String
```
int n1=100;
String str=n1+"";
```
* 基本数据类型的包装类
```
String str1="123";
int n2=Interge.parseInt(str1);

str1.charAt(0);//取得str1的第一个字符
```

### 数组与排序
#### 数组
* 数组是引用类型
* 数组的初始化
```
int a[]=new int[4];
int[] b=new int[5];
```
* 基本数据类型赋值是值拷贝，引用数据类型赋值是地址拷贝
### 类
* 创建对象时会先加载类信息，分配空间，最后把地址分配给引用
* 对象的属性默认值，遵守数组规则 int 0 char \u0000
* 栈、堆、方法区

### 方法详解

#### 方法的调用机制
* 运行方法时会生成一个独立空间（在栈中），不同于main空间，main也在栈中
* 方法执行完毕时，就会返回到调用方法的位置，然后独立空间销毁
* 方法不能嵌套定义
* 同一个类的方法可以直接调用，跨类的方法要创建对象才能访问

#### 细节
* 方法区里常量池里存放字符；方法区里加载类的信息
* 属性==成员变量==field
* 调用带参数的方法时，一定要对应着参数列表的相同类型或者兼容类型

### 重载
* 方法重载：允许同一个类中多个同名方法的存在，但要求形参列表不同
* 比如println就使用了重载，可以输出不同数据类型的数据
#### 方法重载细节
* 方法名必须相同；形参列表必须不同，顺序、数据类型、个数至少有一个不同
* 返回类型不是构成方法重载的条件

### 可变参数与作用域

#### 可变参数
* 可变参数：java允许将同一个类中多个同名同功能，但是参数个数不同的方法封装成一个方法
* 使用可变参数时可以把他们当作数组使用
* 可以接收多个int   int...表示接受多个参数

##### 可变参数细节
* 实参可以时0或者多个，可变参数的实参可以是数组
* 本质就是数组，可变参数可以和普通类型的参数一起放在
* 形参列表，但是可变参数要放在最后
* 一个形参列表只有一个可变参数

#### 作用域
* 局部变量：一般指在成员方法中定义的变量，局部变量没有默认值，不可以被其他类使用
* 全局变量：就是属性，作用域是整个类体，有默认值，可以被本类或其他类使用
* 属性和局部变量可以重名,访问时遵循就近原则
* 局部变量不可以重名
* 运行方法后，局部变量会被销毁，全局变量不会被销毁
* 属性可以加修饰符，局部变量不可以加修饰符
* 属性伴随着对象的创建而创建，伴随着对象的销毁而销毁，局部变量随着代码块的结束而销毁
* 全局变量可以在本类或其他类使用，局部变量只能在本类对应的方法中使用
         
### 构造器与对象创建

#### 构造器
* 构造器没有返回值，修饰符可以默认，方法名和类名一致
* 构造器的调用由系统完成
* 一个类可以定义多个不同的构造器，即构造器重载
* 构造器是完成对象的初始化，不是创建对象
* 在创建对象时，系统自动的调用该类的构造方法
* 如果没有定义构造器，就会默认构造一个无参构造器
* 自己定义了构造器就会覆盖了默认定义的无参构造器，若要使用默认的无参构造器，需要显式的定义
#### 对象创建流程--面试
* 加载类信息只会加载一次，在堆中分配空间/地址，
* 进行默认初始化（即0和null），然后显式初始化(属性值赋值)，构造器初始化
* 再把堆中的地址返回给对象引用/对象名

### this
* jvm会给每个对象分配this
* 那个对象调用，this就表示那个对象
#### this的内存表示图

#### 细节
* this关键字可以用来访问本类的属性、方法、构造器
* this可以用来区分属性和局部变量 this.age
* this可以访问成员方法 this.方法名(参数列表) this.hello()
* this访问构造器语法  this(参数列表)；只能在构造器中使用 this("smith",20)
* this不能在类定义的外部使用，只能在类定义的方法中使用
* 如果要访问构造器，必须放在第一条语句，必须放在构造器中
* this只能在类定义的内部使用

### 包
#### package
需要放在第一行
improt指令位置要放在package的下面，在类定义前面，可以有多句且没有顺序要求

### 封装
* 封装是把抽象出来的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作
* 对属性进行封装，使得属性信息规范化

### 访问修饰符

> public 公开 都可以
> protected 受保护 同类、同包、子类可以
> 默认 没有修饰符 同类、同包可以  子类、不同包不可
> private 私有 只可同类

> 只有默认的和public可以修饰类
> 方法也同理


- 封装和继承
- 把属性和方法封装在一起
- 封装的步骤
- Ⅰ 将属性私有化；提供一个公共的set方法，用于对属性判断并赋值
- Ⅱ 提供一个公共的get方法，用于获取属性的值
```
public void setxxx(类型 参数名){
    属性=参数名；
}
public void getxxx(类型 参数名){
    return xx;
}

```

- 可以将构造器与set方法结合
  
### 继承
* 子类会自动拥有父类定义的属性方法
* 子类不能直接访问私有属性和方法，要通过父类提供公共的方法去访问
* 创建子类对象，子类会先调用父类的构造器，完成父类的初始化，再去调用子类的构造器
* 创建子类对象时，不管使用子类哪个构造器，默认情况都会先去调用父类的无参构造器，如果父类没有提供无参构造器，就必须在子类的构造器中用super指定使用父类的哪个构造器完成对父类的初始化，否则编译不通过。
* 比如默认构造器被覆盖(当新写了一个构造器，默认的无参构造器就被覆盖了)，就要在子类指定使用父类的那个构造器进行初始化（有参数的还是无参数的）

* super();默认调用父类的无参构造器，什么都不写，默认调用super()
* 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)
* super在使用时，需要放在构造器第一行，super只能放在构造器中
* super(),this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器中
* 子类的调用不限于直接父类，会往上追述到Object类   
* 子类最多只能继承一个父类，即单继承机制
* 子类和父类必须满足 is-a的逻辑关系,person is a music?

#### 继承的本质
* 按照查找关系来返回信息
* Ⅰ 查看子类是否有该属性
* Ⅱ 如果子类有，并且可以访问，则返回信息
* Ⅲ 如果子类没有就查看父类



### super
- 代表父类的引用，用于访问父类的属性方法构造器
- 不能访问父类的私有属性  super.属性名
- 不能访问父类的私有方法  super.方法名(参数列表)
- 访问构造器时，必须放在第一句  super(参数列表)

#### super细节
* 好处：父类的属性由父类初始化，子类由子类初始化
* 子类和父类的属性方法重名时，为了访问父类成员，需要用super进行访问,如果没有重名，super，this，直接访问的效果都是一样的
* 找方法cal()，如果本类有，就调用，如果没有就去父类找，如果父类没有就继续找父类的父类，如果找到了不能访问则报错
* this.cal() 同上
* super.cal() 直接查找父类，其他的规则一样
  
* super的访问不限于直接父类，如果爷爷类和本类有同名的成员也可以使用super去访问爷爷类的成员；如果上级类中都有同名的成员，使用super访问采用就近原则

### super和this的区别--面试
|区别点|this|super|
|:---|:---|:---|
|访问属性|访问本类属性，若无择从父类查找|从父类查找属性
|调用方法|访问本类的方法，若无则从父类查找|从父类查找方法
|调用构造器|调用本类构造器，必须放在构造器第一行|调用父类构造器，必须放在子类构造器第一行
|特殊|表示当前对象|子类访问父类的对象




### 方法重写/覆盖
* 子类有个方法和父类某个方法名、返回类类型、参数一样，则说子类这个方法覆盖了父类的方法
  
#### detail
> 子类的返回类型和父类一样，或者子类的返回类型时父类返回类型的子类
> 子类不能缩短父类的访问权限

* 重写和重载的比较
* 重写：覆盖掉  重载：允许本类中有同一个方法名不同参数的方法
  

|名称|发生范围|方法名|形参列表|返回类型|修饰符|
|------|------|------|------|------|------|
|重载overload|本类|必须一样|类型、个数、顺序至少有一个不同|无要求|无要求
|重写override|父子类|必须一样|相同|子类和父类平级或者次于父类|子类方法不能缩小父类方法的访问范围


### 多态
* 解决代码复用性不高的问题
#### 方法的多态
* 通过不同的参数去调用不同的方法，体现多态（方法的重载）
* 重写体现多态：子类和父类各自执行各自的方法（）

#### 对象的多态
* 一个对象的编译类型和运行类型可以不一致

```
Animal animal=new Dog();//父类的引用可以指向子类的对象；编译类型是Animal，运行类型是Dog
animal=new Cat();//运行类型是Cat，编译类型还是Animal，访问属性看编译类型
animal.cry();//cry()方法跟着运行类型保持一致，运行类型是Cat，执行Cat类中的cry方法
```


* 编译类型在定义对象时就确定了
* 运行类型是可以变化的
* 编译类型看定义时=号的左边，运行类型看=号的右边

* 多态的前提：两个对象/类存在继承关系
##### 多态的向上转型
* 本质：父类的引用指向子类的对象
* 语法：父类类型 引用=new 子类类型();//Aninaml animal=new Cat();
* 特点：编译类型看左边，运行类型看右边，可以调用父类的所有成员(需要遵守访问权限)，不能调用子类的特有成员，最终运行效果看子类的具体实现(即调用同方法时，从子类开始查找方法，然后调用，规则和方法调用规则一致).可以调用父类里有的在子类里重写的方法。
* 在编译阶段，能调用哪些成员由编译类型决定；但是调用成员方法的规则仍旧和方法调用规则一样；编译阶段由javac主导，运行阶段由java来做
* 方法的调用看运行类型

##### 向下转型
* 语法：子类类型 引用名=(子类类型)父类类型; 
```
Cat cat=(Cat)animal;编译类型是Cat，运行类型也是Cat
```
* 只能强转父类的引用，不能强转父类的对象，对象无法改变
* 要求父类的引用必须指向的是当前目标类型的对象（Animal animal=new Cat() 转型之前仍然指向Cat）
* 要求父类的类型原先就要是指向子类型（）
```
//要求
Animal animal = new Cat();//向上转型
Cat cat =(Cat)animal;//向下转型，可以，子类父类可以互相转
Dog dog=(Dog)animal;//子类之间不可以互相转

```
* 向下转型后，可以调用子类类型中所有的成员 


##### 属性重写
* 属性的值看编译类型，属性没有重写问题
* instanceOf比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的子类型

##### java的动态绑定机制
* 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
* 当调用对象属性时，没有动态绑定，哪里声明，哪里使用


##### 多态数组√
* 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
```
Person -name,age,say()  Student score  Teacher salary
Person[] person = new Person[5];
person[0]=new Person("jacl",15);
person[1]=new Student("sa",12,100);
person[i].say();//运行类型会根据实际情况（动态绑定机制）由jvm判断
//当要运行不是本类的方法可以向下转型转成对应的运行类型再运行方法
Student stu=(Student)Person[i]//向下转型
((Student)Person[i]).studey();
```

##### 多态参数√
* 方法定义的形参类型为父类类型，实参类型为子类类型
//showEmpAnnul(Emploee e);
//Worker tom=new Work();
//showEmpAnnul(tom);
//((Worker)e).work(); 向下转型

### ==运算符和equals
#### 介绍
> ==运算符
* 既可以判断基本类型，又可以判断引用类型
* 如果判断基本类型，判断的是值是否相同
* 如果判断引用类型，判断的是地址是否相同，即判定是不是同一个对象

> equals
* 是Object类中的方法，只能判断引用类型，默认判断的是地址是否相同，子类一般重写该方法，用于判断内容是否相同
* 重写equals

#### 面试提问方式
* ==和equals由什么区别

### hashcode|toString|finalize  面试
#### hashcode()
* 返回对象的哈希值，会根据不同的对象返回不同的整数
* 可以当作地址看，但是不是地址
##### 小结
* 提高具有哈希结构的容器的效率
* 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
* 两个引用，如果指向的是不同对象，则哈希值是不一样的
* 哈希值主要根据地址号来的，不能完全将哈希值等价于地址

##### 面试提问方式
* 面试常见问题：讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？


#### toString
* 默认返回全类名+@+哈希值的十六进制
* 子类往往重写toString，用于返回对象的属性信息
* 重写toString方法，打印对象或拼接对象时，都会调用该对象的toString形式
* 当直接输出一个对象时，toString方法会被默认调用


##### finalize
* 垃圾回收期，当垃圾回收器确定不存在对该对象的更多引用时
* 对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法
* 什么时候被回收：当某个对象没有任何引用时，jvm就认为这个对象是一个垃圾对象,销毁对象前，会调用该对象的finalize方法
* 垃圾回收期机制的调用，是由系统来决定（有自己的算法），也可以通过system.gc()