1. 谈下你对 Redis 的了解？
* 全称远程字典服务 remote dictionary server 是一个开源的使用ansi c编写的、支持网络、可基于内存也可持久化的日志型、k-v数据库，并提供多种语言的api
* redis和其他k-v缓存产品相比有一下特点：redis支持数据的持久化，可以将内存的数据保存在磁盘中，重启的时候可以再次加载使用；redis不仅支持k-v类型的数据，也支持set、list、zset、hash等类型的存储；redis支持数据的备份

2. Redis 一般都有哪些使用场景？
* 缓存、排行榜、计数器/限速器、好友关系、消息队列、Session共享
* 不适合的场景：数据量太大、数据访问频率非常低的业务都不适合，数据太大增加成本，访问频率低浪费资源

3. Redis 有哪些常见的功能？
* 数据缓存、分布式锁、支持数据持久化、支持事务、支持消息队列

4. Redis 支持的数据类型有哪些？

5. Redis 为什么这么快？

6. 什么是缓存穿透？怎么解决？

7. 什么是缓存雪崩？该如何解决？

8. 怎么保证缓存和数据库数据的一致性？

9.  Redis 持久化有几种方式？

10. Redis 内存淘汰策略有哪些？

11. Redis 常见性能问题和解决方案？

12. Redis的过期键的删除策略

13. 我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?

14. Hash 冲突怎么办？

15. 什么是 RDB 内存快照？

16. 在生成 RDB 期间，Redis 可以同时处理写请求么？

17. 如何实现数据尽可能少丢失又能兼顾性能呢？

18. 哈希槽又是如何映射到 Redis 实例上呢？

19. Redis如何做内存优化？

20. Redis线程模型

21. Redis事务及其相关面试题

22. Redis是单线程的，如何提高多核CPU的利用率？

23. 为什么要做Redis分区？

24. 你知道有哪些Redis分区实现方案？

25. Redis分区有什么缺点？

26. 如何解决 Redis 的并发竞争 Key 问题

27. 分布式Redis是前期做还是后期规模上来了再做好？为什么？

28. Redis相比Memcached有哪些优势？

29. 为什么要用 Redis 而不用 map/guava 做缓存?

30. 如何选择合适的持久化方式

31. Redis key的过期时间和永久有效分别怎么设置？

32. 双写一致性方案一：先删除缓存，后更新数据库

33. 双写一致性方案二：先更新数据库，后删除缓存

34. 什么是缓存预热?

35. 什么是缓存降级？

36. Redis真的是单线程？

37. Redis 6.0为何引入多线程？

38. Redis 6.0 多线程的实现机制？

39. Redis 6.0 采用多线程后，性能的提升效果如何？

40. Redis 6.0开启多线程后，是否会存在线程并发安全问题？

41. Redis 6.0 与 Memcached 多线程模型的对比

42. 介绍下Redis单副本

43. 介绍下Redis多副本（主从）

44. 介绍下Redis Sentinel（哨兵）

45. 介绍下Redis Cluster

46. 介绍下Redis自研

47. Redis高可用方案具体怎么实施？

48. 了解主从复制的原理吗？

49. 由于主从延迟导致读取到过期数据怎么处理？

50. 主从复制的过程中如果因为网络原因停止复制了会怎么样？

51. Redis主从架构数据会丢失吗，为什么？

52. 如何解决主从架构数据丢失的问题？

54. Redis哨兵是怎么工作的？

55. 故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？

56. 同步配置的时候其他哨兵根据什么更新自己的配置呢？

57. 为什么Redis哨兵集群只有2个节点无法正常工作？

58. Redis cluster中是如何实现数据分布的？这种方式有什么优点？

59. Redis cluster节点间通信是什么机制？

60. 什么是分布式锁？为什么用分布式锁？

61. 常见的分布式锁有哪些解决方案？

62. Redis实现分布式锁

63. RedLock的原理


# redis常见面试题
## redis基础
### 什么是redis
redis是一个基于c语言开发的开源数据库，与传统数据库不同的是redis的数据是存在内存中的，读写速度非常快，被广泛用于缓存方向。并且，redis存储的是kv键值对数据

### redis为什么那么快
内部做了许多的性能优化
1.redis基于内存，内存的访问速度是磁盘的上千倍
2.redis基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和io多路复用
3.redis内置了多种优化后的数据结构实现，性能非常高
![图片](https://javaguide.cn/assets/why-redis-so-fast-d3507ae8.png)


### 分布式缓存常见的技术选型方案有哪些
分布式缓存用的比较多的是memcached和redis。大部分都是使用redis做缓存

### redis和memcached的区别和共同点
共同点：
1.都是基于内存的数据库，一般都当作缓存使用
2.都有过期策略
3.两者的性能都非常高

区别：
1.redis支持更复杂的应用场景。redis不仅仅支持简单的kv类型的数据，同时还提供list、set、zset、hash等数据结构存储。memcached只支持最简单的kv数据类型
2.redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而memcached把数据全部存在内存中
3.redis有灾难恢复机制。因为可以把缓存中的数据持久化到磁盘上
4.redis在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，memcached在服务器内存使用完成后，会报异常
5.memcached没有原生的集群模式，需要依赖客户端来实现往集群中分片写入数据；redis目前原生支持cluster模式的
5.memcached没有原生的集群模式，需要依赖客户端来实现往集群中分片写入数据；redis目前原生支持cluster模式的
6.memcacahed是多线程，非阻塞io复用的网络模型；redis使用单线程的多路io复用的网络模型（redis6.0针对网络数据的写入引入了多线程）
7.redis支持发布订阅模型、lua脚本、事务等功能，memcached不支持
8.memcached过期数据的删除策略只用了惰性删除，redis同时使用了惰性删除和定期删除

### 为什么要用redis/为什么要用缓存
1、高性能
假如用户第一次访问数据库的某些数据，这个过程很慢，因为是从硬盘中读取，如果说，用户访问的数据是高频数据且不会经常改变，那么我们可以将数据放入缓存中。这样可以保证用户下一次再访问这些数据可以直接从缓存中获取
2、高并发
一般像mysql这类数据库的qps一般在1w左右，但是使用redis缓存轻易就能到10w+
qps：服务器每秒可以执行的查询次数

直接操作缓存能够承受的数据库的请求数量是远远大于直接访问数据库的，所以我们考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求就会直接到缓存而不用经过数据库，进而提高了系统整体的并发

## redis应用
### redis除了做缓存还能做什么
* 分布式锁：通过redis来做分布式锁是一种比较常见的方式，通常情况下，都是基于redission来实现分布式锁。
* 限流：一般通过redis+lua脚本实现限流
* 消息队列：redis自带的list数据结构可以作为一个简单的队列使用。redis5.0中增加的stream类型的数据结构更适合用来做消息队列。它比较类似kafka，有主题和消费组的概念，支持消息持久化和ack机制
* 延时队列：redission内置了延时队列
* 分布式Session：利用string或hash保存Sessin数据，所有的服务器都可以访问
* 复杂业务场景：通过redis以及redis扩展提供的数据结构，可以很方便的完成很多复杂的业务场景


### redis可以做消息队列吗？了解
可以做，但不建议
综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。


## redis数据结构
### redis常用数据结构
* 5种基础数据结构：Stirng、list（列表）、set（集合）、hash（散列）、Zset（有序结合）
* 3种特殊数据结构：HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）


### String的应用场景有那些
String是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片、序列化后的对象

### String还是Hash存储对象数据更好呢？
* String存储的是序列化后的对象数据，存放的是整个对象。Hash是对对象的每个字段单独存储，可以获取部分对象的信息，也可以修改或添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中个别字段信息，hash就很适合
* String存储相对来说更加节省内存，缓存相同数量的对象数据，String消耗的内存是hash的一半，并且，存储具有多层嵌套的对象时也方便许多。如果系统对性能和资源消耗非常敏感的话，String就很适合
大多数情况下，建议使用String来存储对象数据

### String的底层实现是什么
redis是基于c实现的，但redis的string类型的底层不是c中的字符串，是自己编写的sds（简易动态字符串）作为底层实现的
sds相比c的字符串有如下提升：
1.可以避免缓冲区溢出：c的字符串被修改时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。sds被修改时，会先根据len属性检查空间大小是否满足要求，如果不满足，先扩展至所需大小再进行修改
2.获取字符串长度的复杂度较低：c中的字符串长度时通过遍历计数实现的，时杂为O(n)，sds的长度获取直接读取len属性即可，时杂为O(1)
3.减少内存分配次数：为了避免修改字符串时，每次都需要重新分配内存，sds实现了空间预分配和惰性空间释放优化策略。当sds需要增加字符串时，redis会为sds分配好内存，根据算法分配多余内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当sds需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用
4.二进制安全：c的字符串以空字符作为字符串结束的标识，这样一些二进制文件可能包含空字符，c字符串无法正确保存。sds使用len属性判断字符是否结束


### 购物车信息用String还是Hash存储更好呢
由于购物车中的商品频繁修改和变动，购物车信息建议使用hash存储：
* 用户id为key
* 商品id为field，商品数量为value

![图片](https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png)

#### 用户购物车信息的维护具体怎么操作
* 用户添加商品就是网hash中增加field和value
* 查询购物车信息就是遍历对应的hash
* 更改商品数量直接修改对应的value值（直接set或做运算皆可）
* 删除商品就是删除hash中对应的field
* 清空购物车直接删除对应的key即可


### 使用redis实现一个排行榜怎么做


### Set的应用场景是什么
redis中Set是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似java的HashSet
Set的应用场景如下：
* 存放的数据不能有重复的场景：网站uv统计（数据量巨大的场景还是HyperLogLog更合适）、文章点赞、动态点赞
* 需要获取多个数据源交集、并集和差集：共同好友（交集）、共同粉丝（交集）、共同关注（交集）、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集）
* 需要随机获取数据源中的元素的场景：抽奖系统、随机点名


### 使用Set实现抽奖系统怎么做
如果想要使用Set实现一个简单的抽奖系统的话，直接使用以下几个命令就好
* SADD key member1 member2 ...:向指定集合添加一个或多个元素
* SPOP key count:随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景
* SRANDMEMBER key count:随机获取指定集合中指定数量的元素，适合允许重复中奖的场景

### 使用Bitmap统计活跃用户怎么做
Bitmap存储的是连续的二进制数字，通过Bitmap，只需要一个bit位来表示某个元素对应的值或者状态，key就是对应元素本身。我们直到8bit组成一个byte，所以Bitmap可以极大节省空间

可以将Bitmap看作是一个存储二进制数字的数组，数组中每个元素的下表叫offset（偏移量）

### 使用HyperLogLog统计页面uv怎么做
使用HyperLogLog统计页面uv主要需要用到下面这两个命令：
* PFADD key element1 element2 ...:添加一个或多个元素到HyperLogLog中
* PFCOUNT key1 key2:获取一个或多个HyperLogLog的唯一计数

1、将访问指定页面的每个用户id添加到HyperLogLog中
PFADD PAGE_1:uv user1 user2..usern
2、统计指定页面的uv
PFCOUNT PAGE_1:uv

## redis持久化机制
redis持久化机制（RDB持久化、AOF持久化、RDB和AOF混合持久化）

## redis线程模型
对于读写命令来说，redis一直是单线程模型。不过，在4.0之后引入多线程来执行大键值对的异步删除操作，6.0之后引入了多线程来处理网络请求（提高网络io读写性能）
### redis单线程模型
redis基于reactor模式设计开发了一套高效的事件处理模型（Netty的线程模型也基于reactor模式），这套事件处理模型对应的是redis中的文件事件处理器。由于文件事件处理器是单线程方式运行的，所以我们说redis是单线程模型

* 文件事件处理器使用io多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
* 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

虽然文件事件处理器以单线程方式运行，但通过使用io多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与redis服务器中其他同样以单线程方式运行地模块进行对接，这保持了redis内部单线程设计地简单性


#### 既然是单线程，那么怎么监听大量的客户端连接呢？
redis通过io多路复用程序来监听来自客户端的大量连接（或者说是监听多个socket），它会将感兴趣的事件及类型注册到内核中并监听每个事件是否发生
这样做的好处：io多路复用技术的使用让redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗

文件事件处理器主要包含4个部分：
* 多个socket（客户端连接）
* io多路复用技术（支持多个客户端连接的关键）
* 文件事件分派器（将socket关联到相应的事件处理器）
* 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

#### redis6.0之前为什么不使用多线程
redis4.0之后就已经加入了对多线程的支持；不过，redis4.0增加的多线程主要是针对一些大键值对的删除操作命令，使用这些命令就会使用主线程之外的其他线程来‘异步处理’

原因：
* 单线程编程容易且更易维护
* redis的性能瓶颈不在cpu，主要在内存和网络
* 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能

#### redis6.0之后为何引入多线程
redis6.0引入多线程主要是为了提高网络io读写性能，，因为这个是redis中的一个性能瓶颈
虽然，redis6.0引入多线程，但是redis的多线程只是在网络数据的读写这类耗时的操作上使用，执行命令仍然是单线程顺序执行。因此，不需要担心线程安全问题

redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要设置io线程数>1,需要修改redis配置文件redis.conf
io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程
另外：
* io-threads的个数一旦设置，不能通过config动态设置
* 当设置ssl后，io-threads将不工作

开启多线程后，默认只会使用多线程进入io写入writes，即发送数据给客户端，如果需要开启多线程io读取reads，同样需要修改redis配置文件redis.conf
io-threads-do-reads yes
开启多线程没有太大提升，不建议开启

#### redis后台线程
redis主要逻辑是单线程完成的，但实际还有一些后台线程用于执行一些比较耗时的操作：
* 通过bio_close_file后台线程来释放AOF/RDB等过程中产生的临时资源文件
* 通过bio_aof_fsync后台线程调用fsync函数将系统内核缓冲区还未同步到磁盘的数据强制刷到磁盘中（AOF文件）
* 通过bio_lazy_free后台线程放大对象占用的内存空间

### redis内存管理
#### redis给缓存数据设置过期时间有啥用？
一般情况下，我们设置保存的缓存数据有时候会设置一个过期时间，因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟out of memory
redis自带了给缓存数据设置过期时间的功能
expire key 60 # 数据在60s后过期
setex key 60 value # 数据在60s之后过期
ttl key # 查询数据还有多久过期

注意：redis中处理字符串类型有自己独有设置过期时间的命令setex外，其他方法都要依靠expire命令来设置过期时间。另外，persist命令可以移除一个键的过期时间
##### 过期时间除了有助于缓解内存的消耗，还有什么作用
很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，如果使用传统的数据库来处理，一般都是自己判断过期，这样更麻烦并且性能要差很多

#### redis是如何判断数据是否过期？
redis通过一个叫做过期词典（可以看作hash表）来保存数据过期的时间。过期词典的键指向redis数据库中的某个key，过期词典的值是一个long long 类型的整数，这个整数保存了key所指向的数据库键的过期时间 


#### 过期数据的删除策略
如果假设你设置了一批key只能存活1分钟，1分钟之后，redis是怎么对这批key进行删除的呢？
常用的过期数据的删除策略就两个
1.惰性删除：只会在取出key的时候对数据进行过期检查，这样对cpu最友好，但是可能会造成过多的过期key没有被删除
2.定期删除：每隔一段时间抽取一批key执行删除过期key操作。并且，redis底层会通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响
定期删除对内存更友好，惰性删除对cpu更友好。redis采用定期删除+惰性删除

仅仅通过给key设置过期时间还有问题，因为还是可能存在定期删除和惰性删除漏掉了很多过期key的情况/这样导致大量过期key堆积在内存里，然后就out of memory，可以通过redis内存淘汰机制解决问题

#### redis内存淘汰机制
volatile-lru:从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
volatile-ttl:从已设置过期时间的数据集挑选要过期的数据淘汰
volatile-random:从已设置过期时间的数据集中挑选任意数据淘汰
allkeys-lru:当内存不足以纳新写入数据时，在键空间内，移除最少使用的key
allkeys-random：从数据集中任意选择数据淘汰
no-eviction：禁止驱逐数据，也就是说当内存不足以纳新写入数据时，新写入数据会报错
volatile-lfu:从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
allkeys-lfu:当内存不足以纳新写入数据时，在键空间中，移除最不经常使用的key


## redis事务
### 什么是redis事务
redis事务提供了一种将多个命令请求打包的功能，然后再按顺序执行打包的所有命令，并且不会被中途打断
redis事务开发中用的少，功能比较鸡肋；除了不满足原子性和持久性，事务中的每条命令都与redis服务器进行网络交互，这是浪费资源的行为

### 如何使用redis事务
redis可以通过multi、exec、discard、watch等命令来实现事务功能
multi命令后可以输入多个命令，redis不会立即执行这些命令，而是将它们放到队列里，当调用了exec命令后，再执行所有命令
过程：1、开始事务（multi）2、命令入队（批量操作redis命令，fifo的顺序执行）3、执行事务（exec）
你可以通过discard命令取消一个事务，它会清空事务队列里保存的所有命令
你可以通过watch命令监听指定的key，当调用exec执行事务时，如果一个被watch监听的key被其他客户端/session修改的话，整个事务都不会被执行
如果watch和事务在同一个session中，并且被watch监视的key被修改的操作发生在事务内部，这个事务是可以被执行成功的
### redis事务支持原子性吗
redis的事务和平时理解的关系型数据库的事务不同。事务具有原子性、隔离性、持久性、一致性
原子性：事务是最小的执行单位，不允许分割。事务的原子性保证了事务要么全部完成，要么完全不起作用
隔离性：并发访问数据库，一个用户的事务不被其他事务干扰，各并发事务之间的数据库是独立的
持久性：一个事务被提交后，它对数据库的变化是持久的，即使数据库发生故障也不应该对其有影响
一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取结果是一致的
redis事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，redis事务不支持回滚操作。因此，redis事务不满足原子性（redis开发者认为没有必要实现回滚，命令执行错误应该在开发过程中发现而不是生产过程中）。

### redis事务支持持久性吗
redis不同于memcached的重要一点就是，redis支持持久化，而且提供了3中持久化方式：
* 快照（RDB）
* 只追加文件（AOF）
* RBD和AOF的混合持久化（4.0新增）

与RDB持久化相比，AOF持久化的实时性更好。在redis的配置文件中存在3种不同的AOF持久化方式，分别是：
appendfsync always # 每次有数据修改发生时都会调用fsync函数同步AOF文件，fsync完成后线程返回，这样会降低redis的速度
appendfsync everysec # 每秒调用fsync函数同步一次AOF
appendfsync no # 让os决定何时进行同步，一般为30s一次

AOF持久化策略为no、everysec时都会存在数据丢失的情况，always下基本可以满足持久性要求，但性能太差
因此，redis事务的持久性也是没有办法保证的


### 如何解决redis事务的缺陷
redis从2.6开始执行lua脚本，功能与事务相似。我们可以利用lua脚本来批量执行多条redis命令，这些命令会被提交到redis服务器一次性执行，减小网络开销

一段lua脚本执行过程不会有其他脚本或redis命令同时执行，保证了操作不会被其他指令插入或打扰

如果lua脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此，通过lua脚本来批量执行redis命令实际上也不完全满足原子性

如果想要让lua脚本全部执行，必须保证语句语法和命令都是对的

## redis性能优化
### 使用批量操作减少网络传输
一个redis命令的执行可以简化为4步：1、发送命令2、命令排队3、命令执行4、返回结果
其中，第1步和第4步耗费时间之和称为rtt（往返时间），也就是数据在网络上的传输时间
使用批量操作可以减少网络传输次数，进而减少网络开销
另外，除了能减少rtt之外，发送一次命令的socket io成本也较高，批量操作还可以减少socket io成本