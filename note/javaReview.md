创建对象时会先加载类信息，分配空间，最后把地址分配给引用；对象的属性默认值遵守数组规则

重载：允许同一个类中存在多个同名方法，但要求形参个数、类型、顺序选一个不同

可变参数：java允许将同一个类中多个同名同功能参数不同的方法封装为一个方法；实参可以是0个或1个，实参可以是数组；可变参数要放在形参列表中的最后；一个形参列表只有一个可变参数

成员变量可以加修饰符，可以在本类及其他类中使用，有默认值，属性伴随着对象的创建而创建，随着对象的销毁而销毁
局部变量不可以加修饰符，只能在本类的方法中，无默认值，局部变量随着代码块的结束而销毁

* 构造器是完成对象的初始化，不是创造对象；
* 创建对象：加载类信息只会加载一次，在堆中分配空间，进行默认初始化，显式初始化，构造器初始化，再把堆中的地址返回给对象引用

jvm会给每个对象分配this，哪个对象调用，this就代表那个对象
this只能在类定义的内部使用；this只要访问构造器就必须放在第一句

子类不能直接访问父类的私有属性和方法，需要通过父类提供的公共方法去访问
创建子类对象时，会先访问父类构造器，完成父类初始化，再去访问子类构造器
在创建子类对象时，不管调用子类哪个构造器，默认调用父类的无参构造器，如果父类没有无参构造器，需要在调用子类构造器时使用super指定使用父类的哪个构造器完成父类的初始化；super在使用时需要放在构造器第一行
super的访问不限于直接父类，如果爷爷类和本类有重名的方法和属性，也可以使用super去访问爷爷类的成员

重写时，子类不能缩小父类的访问权限，子类的返回值只能和父类相同或是父类的返回类型的子类

访问属性需要看编译类型
父类的向上引用 Animal animal = new Cat()
可以调用父类的所有成员，不能调用子类的特有成员
在编译阶段，能调用那些成员由编译类型决定；方法的调用看运行类型

父类的向下引用 Cat cat = (Cat)animal
只能强制转换父类的引用，不能强转父类的对象，对象不能改变；
要求父类的引用必须指向的是当前目标类型的对象
子类之间不能相互转换；向下转型后，可以调用子类的所有成员

属性的值看编译类型，属性没有重写问题
动态绑定机制：当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定；当调用对象属性时，没有动态绑定，哪里声明哪里使用

两个引用，如果指向同一个对象，哈希值一定一样，如果指向不同对象，哈希值不一样
哈希值根据地址得来，不等同于地址

当输出一个对象时，默认调用toString
对象被回收时，系统自动调用finalize；当对象没有引用时，jvm就认为这个对象是垃圾对象

静态变量是该类所有对象共享的变量
类加载时类方法会放在方法区；静态变量在类加载时就生成了，无论是否创建对象，静态变量都已经存在
静态变量在jdk8以前放在方法区中，8以后的版本放在堆中类对应的class对象中，通过反射加载class对象
访问静态变量：类名.静态变量
静态变量的生命周期随类加载而开始，随类销毁而结束

静态方法和普通方法随着类的加载而加载，都是把结构信息放在方法区
静态方法中无this参数，普通方法中隐含着this参数
静态方法可以通过类名和对象名调用，普通方法只能通过对象名调用
静态方法不允许使用和对象有关的关键字（this,super），普通方法可以
静态方法中只能访问静态变量和静态方法

main方法由虚拟机调用，java虚拟机调用main时不用创建对象
main方法接收String类型的数组参数
main方法中可以直接调用main所在类的静态变量和方法，但是不能直接访问非静态成员

代码块只有方法体，在类加载时或创建对象时，被隐式调用；
[static]{}静态代码块 {}普通代码块
代码块的调用顺序在构造器之前
静态代码块随着类加载只执行一次，普通代码块每创建一个对象就加载一次
类加载的时机：1、创建对象实例时2、创建子类对象实例时，父类也会被加载3、使用类的静态成员时
创建一个对象，类的调用顺序：1、调用静态代码块和静态属性初始化（二者优先级相同）2、调用普通代码块和普通属性初始化3、构造器
构造器的最前面隐含了super和调用普通代码块，静态相关的代码块和属性初始化在类加载时就执行完成了
创建一个子类，调用顺序：父类静态代码块、子类静态代码块、父类普通代码块、父类构造器、子类普通代码块、子类构造器

单例模式

final可以修饰类、方法、属性和局部变量；被final修饰，不可以继承父类、不可以重写父类的方法、不可以修改类的属性值和局部变量；

final修饰属性时必须赋初值，并且不能修改；赋值的位置：定义时、构造器、代码块；
final类不能继承，但是可以实例化对象
如果类没有被final修饰但是有final方法，则可以继承但是不能重写；如果一个类被final修饰，就没有必要再修饰为final方法
final不能修饰构造方法；final和static一起修饰不会导致类加载；
包装类都是final，String也是final

抽象类：当父类需要声明但是又不知如何实现时，可以将其声明为抽象方法，类为抽象类
抽象类的价值多用于设计，让子类继承并实现抽象类；抽象类不能被实例化
抽象类可以没有抽象方法，一旦包含抽象方法就要声明为抽象类
abstract只能修饰方法和类，不能修饰属性和其他的
抽象方法不能有主体；如果一个类继承了抽象类就必须实现抽象类的所有方法，除非该类声明为抽象类
抽象方法不能用final、static、private修饰，因为这些关键字与重写违背


接口：给出一些没有实现的方法，封装到一起，到某个类要使用时再具体实现
jdk8之后，接口里可以有静态方法、默认方法，即在接口中可以有方法的具体实现
在接口中，抽象方法可以不加abstract；接口不能实例化；一个普通类实现接口必须要实现接口里所有方法；抽象类实现接口可以不实现方法；
接口里的属性是 public static final； 访问接口属性：接口名.属性名
一个接口不能继承类，可以继承接口；

多态参数：接口引用可以接受不同的对象
接口类型的变量(if)可以指向实现了该接口(IF)的类的对象实例（IF if = new Cat() if=new Dog()）

