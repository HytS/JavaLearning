创建对象时会先加载类信息，分配空间，最后把地址分配给引用；对象的属性默认值遵守数组规则

重载：允许同一个类中存在多个同名方法，但要求形参个数、类型、顺序选一个不同

可变参数：java允许将同一个类中多个同名同功能参数不同的方法封装为一个方法；实参可以是0个或1个，实参可以是数组；可变参数要放在形参列表中的最后；一个形参列表只有一个可变参数

成员变量可以加修饰符，可以在本类及其他类中使用，有默认值，属性伴随着对象的创建而创建，随着对象的销毁而销毁
局部变量不可以加修饰符，只能在本类的方法中，无默认值，局部变量随着代码块的结束而销毁

* 构造器是完成对象的初始化，不是创造对象；
* 创建对象：加载类信息只会加载一次，在堆中分配空间，进行默认初始化，显式初始化，构造器初始化，再把堆中的地址返回给对象引用

jvm会给每个对象分配this，哪个对象调用，this就代表那个对象
this只能在类定义的内部使用；this只要访问构造器就必须放在第一句

子类不能直接访问父类的私有属性和方法，需要通过父类提供的公共方法去访问
创建子类对象时，会先访问父类构造器，完成父类初始化，再去访问子类构造器
在创建子类对象时，不管调用子类哪个构造器，默认调用父类的无参构造器，如果父类没有无参构造器，需要在调用子类构造器时使用super指定使用父类的哪个构造器完成父类的初始化；super在使用时需要放在构造器第一行
super的访问不限于直接父类，如果爷爷类和本类有重名的方法和属性，也可以使用super去访问爷爷类的成员

重写时，子类不能缩小父类的访问权限，子类的返回值只能和父类相同或是父类的返回类型的子类

访问属性需要看编译类型
父类的向上引用 Animal animal = new Cat()
可以调用父类的所有成员，不能调用子类的特有成员
在编译阶段，能调用那些成员由编译类型决定；方法的调用看运行类型

父类的向下引用 Cat cat = (Cat)animal
只能强制转换父类的引用，不能强转父类的对象，对象不能改变；
要求父类的引用必须指向的是当前目标类型的对象
子类之间不能相互转换；向下转型后，可以调用子类的所有成员

属性的值看编译类型，属性没有重写问题
动态绑定机制：当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定；当调用对象属性时，没有动态绑定，哪里声明哪里使用

两个引用，如果指向同一个对象，哈希值一定一样，如果指向不同对象，哈希值不一样
哈希值根据地址得来，不等同于地址

当输出一个对象时，默认调用toString
对象被回收时，系统自动调用finalize；当对象没有引用时，jvm就认为这个对象是垃圾对象

静态变量是该类所有对象共享的变量
类加载时类方法会放在方法区；静态变量在类加载时就生成了，无论是否创建对象，静态变量都已经存在
静态变量在jdk8以前放在方法区中，8以后的版本放在堆中类对应的class对象中，通过反射加载class对象
访问静态变量：类名.静态变量
静态变量的生命周期随类加载而开始，随类销毁而结束

静态方法和普通方法随着类的加载而加载，都是把结构信息放在方法区
静态方法中无this参数，普通方法中隐含着this参数
静态方法可以通过类名和对象名调用，普通方法只能通过对象名调用
静态方法不允许使用和对象有关的关键字（this,super），普通方法可以
静态方法中只能访问静态变量和静态方法

main方法由虚拟机调用，java虚拟机调用main时不用创建对象
main方法接收String类型的数组参数
main方法中可以直接调用main所在类的静态变量和方法，但是不能直接访问非静态成员

代码块只有方法体，在类加载时或创建对象时，被隐式调用；
[static]{}静态代码块 {}普通代码块
代码块的调用顺序在构造器之前
静态代码块随着类加载只执行一次，普通代码块每创建一个对象就加载一次
类加载的时机：1、创建对象实例时2、创建子类对象实例时，父类也会被加载3、使用类的静态成员时
创建一个对象，类的调用顺序：1、调用静态代码块和静态属性初始化（二者优先级相同）2、调用普通代码块和普通属性初始化3、构造器
构造器的最前面隐含了super和调用普通代码块，静态相关的代码块和属性初始化在类加载时就执行完成了
创建一个子类，调用顺序：父类静态代码块、子类静态代码块、父类普通代码块、父类构造器、子类普通代码块、子类构造器

单例模式

final可以修饰类、方法、属性和局部变量；被final修饰，不可以继承父类、不可以重写父类的方法、不可以修改类的属性值和局部变量；

final修饰属性时必须赋初值，并且不能修改；赋值的位置：定义时、构造器、代码块；
final类不能继承，但是可以实例化对象
如果类没有被final修饰但是有final方法，则可以继承但是不能重写；如果一个类被final修饰，就没有必要再修饰为final方法
final不能修饰构造方法；final和static一起修饰不会导致类加载；
包装类都是final，String也是final

抽象类：当父类需要声明但是又不知如何实现时，可以将其声明为抽象方法，类为抽象类
抽象类的价值多用于设计，让子类继承并实现抽象类；抽象类不能被实例化
抽象类可以没有抽象方法，一旦包含抽象方法就要声明为抽象类
abstract只能修饰方法和类，不能修饰属性和其他的
抽象方法不能有主体；如果一个类继承了抽象类就必须实现抽象类的所有方法，除非该类声明为抽象类
抽象方法不能用final、static、private修饰，因为这些关键字与重写违背


接口：给出一些没有实现的方法，封装到一起，到某个类要使用时再具体实现
jdk8之后，接口里可以有静态方法、默认方法，即在接口中可以有方法的具体实现
在接口中，抽象方法可以不加abstract；接口不能实例化；一个普通类实现接口必须要实现接口里所有方法；抽象类实现接口可以不实现方法；
接口里的属性是 public static final； 访问接口属性：接口名.属性名
一个接口不能继承类，可以继承接口；

多态参数：接口引用可以接受不同的对象
接口类型的变量(if)可以指向实现了该接口(IF)的类的对象实例（IF if = new Cat() if=new Dog()）

内部类可以直接访问私有属性
局部内部类定义在外部类的局部位置上，通常在方法或代码块中，并有类名；可以访问外部类的所有成员；不可以添加访问修饰符，地位上是局部变量；局部内部类访问外部类成员：直接访问；外部类访问局部内部类成员：先创建对象再访问（必须再作用域内）；外部其他类不能访问局部内部类
外部类名.this.成员：其他类访问外部类成员

匿名内部类定义在外部类的局部位置（new 类或接口(参数列表){};） 本质是类；没有类名；是个对象
匿名内部类访问外部类成员：直接访问；外部其他类访问内部类：不能访问


成员内部类：定义在外部类的成员位置，不用static修饰；可以直接访问外部类的所有成员；可以添加任何一个修饰符；
成员内部类访问外部类：直接访问 外部类访问内部类：创建对象再访问（也可以写个返回内部类对象的方法）

静态内部类：定义在外部类成员位置并用static修饰；可以直接访问外部类的静态成员，不可以访问非静态成员，可以添加任意访问修饰符，不可以直接访问非静态成员
静态内部类访问外部类：直接访问静态成员；外部类访问静态内部类：创建对象，再访问
静态内部类访问外部其他类：外部类名.成员名

自定义枚举：不需要提供set方法，因为枚举对象是只读、对枚举对象使用final+static修饰、枚举对象名通常大写表示
自定义步骤：构造器私有化、本类内部创造一组对象、对外暴露对象（public static final）、提供get方法
enum枚举类
使用enum实现枚举类，用enum代替class，常量名(实参列表)，多个常量用,间隔
如果使用enum实现枚举，要将定义常量对象写在最前面；使用enum开发一个枚举类会默认继承enum类
枚举对象必须放在枚举类的行首；如果使用无参构造器创建枚举对象，则实参和小括号可以省略

枚举成员方法（values：返回枚举类中所有常量；valueOf：将字符串转换为枚举对象，字符串必须为已有的常量名；compareTo：比较枚举常量的位置）


编译异常：如果不处理，程序无法通过；运行异常：不检查异常，由程序逻辑错误引起的
异常处理机制：try-catch、throws（抛出异常）；如果没有显式处理异常，默认是throws
throws：抛出异常交给调用者来处理
try-catch：异常发生，后面的代码不会执行；异常不发生，执行try语句代码；可以有多个catch语句，捕获不同异常（要求父类异常在后，子类异常在前）
如果出现异常，try后的语句不会执行，直接执行catch语句代码

throws异常处理：如果语句执行中可能出现某种异常，但不能确定如何处理异常，显式声明将异常抛出，表明该方法不对异常进行处理，由方法的调用者进行处理
throws后面的异常类型可以是方法中产生的异常类型也可以是它的父类
运行时异常，程序中没有处理默认throws处理
子类重写父类方法时，所抛出的异常类型要么和父类一致要么是父类异常的子类
在throws过程中，如果有try-catch，则不必throws

自定义异常：当程序中出现某些错误，但错误信息并没在Throwable子类中，这时可以自己设计异常类
一般下，自定义异常继承RuntimeException，把自定义异常做成运行时异常，可以使用默认处理机制
throws在方法声明处添加异常类型；throw在方法体中添加异常对象

装箱：基本类型――>包装类型  拆箱 包装类型-->基本类型；jdk5之前是手动装箱拆箱；jdk5之后是自动装箱（valueOf），自动拆箱（xxValue）;
只要是基本数据类型，==判断的就是值是否相同

Integer->String toString()

String 调用intern()时，如果常量池中包含一个等于该String对象的字符串，则返回池中的字符串，否则将该String对象添加到对象池中，并返回此对象的引用；intern()返回的是常量池的地址

常量相加，发生在池中；变量相加，发生在堆中
String、StringBuffer、StringBuilder是final，不能被继承
String的字符串存放在 final char value[],地址不可以修改
StringBuffer的字符内容放在char value[]中，所有变化不用每次改变地址来完成，效率高于String
StringBuilder字符序列放在堆中 

String保存的是字符串常量，StringBuffer保存的是字符串变量；StringBuffer每次更新的是内容，不是内存地址
StringBuffer()创建了一个大小为16的char[];构造器也可以指定数组大小，参数可以是数字或者是字符串（字符串长度+16）

String->StringBuffer append(),StringBuffer构造器
StringBuffer->String String构造器，toString()
StringBuffer线程安全，StringBuilder线程不安全
对字符串需要大量操作时，不用String

Collection接口实现遍历：迭代器遍历（所有实现Collection接口的类都有一个Iterator()方法用于返回一个Iterator接口的对象，即一个迭代器）
Iterator对象称为迭代器，用于遍历Collection中的元素

迭代器的运行原理
Iterator i=col.iterator()//获取迭代器
while(i.hasNext()){//判断是否还有下一个元素，如果有返回true
    System.out.println(i.next())//下移并将下移后集合位置的元素返回
}

