java中可以使用set classpath指定java类的运行路径
## 数据类型
### 基本数据类型
int、char、short、byte、float、double、long long声明的数据加L；float加F；boolean不能与其他类型相互转换
### 引用数据类型
## 内存
### 方法区
栈：方法在栈中执行，没运行一个方法就在栈中单独开一个空间
堆：存储数组和对象，new出来的对象放在堆中
方法区：存储可以运行的class文件
arr=null;数组不会存储数组的内存地址

javaBean可以理解为实体类，成员变量声明为private，内部实现get、set方法

## 类
创建对象时会加载类的信息，分配内存，最后把地址分配给引用；方法区的常量池中存放字符信息，方法区中加载类的信息
### 对象
对象使用前必须实例化，所有对象名称放在栈中（栈中存放对象的地址），真正的对象放在堆中（堆中存放对象属性信息），每个实例化的对象都会占据自己的堆、栈内存空间；类中的全部属性必须封装，封装后的属性必须通过setter和getter方法访问；
#### 匿名对象
一般匿名对象只使用一次，而且匿名对象只在堆内存中开辟空间，不存在栈的引用（new Person("aaa").tell();该对象使用一次后就等待被gc回收）；通常作为其他实例化对象的参数传递；

### 对象数组
数组中包含同一类型的对象，数组要先开辟空间，并且数组中每一个对象都要实例化；
### 内存区域
栈内存：存放所有对象名称
堆内存：保存每个对象的具体内容
全局数据区：保存static类型的属性
全局代码区：保存所有方法的定义

### 作用域
成员变量可以添加访问修饰符，可以在本类及其他类中使用，有默认值，属性随着对象创建而创建，随着对象的销毁而销毁；局部变量不能加访问修饰符，无默认值，只能在本类中使用，局部变量随着代码块的结束而结束；局部变量在栈上分配，必须初始化才能使用，若未初始化，则赋予默认值；局部变量只在声明它的方法、构造方法、语句块中可见；静态变量指在类中定义的变量，随着类的加载而加载，可以加访问修饰符，所有对象实例共享一个静态变量，静态变量与类相关，多个线程访问静态变量会有数据一致性问题，建议采用同步措施；
### 构造器
默认有无参构造器，如果声明了一个新的构造器，就会覆盖默认的无参构造器；构造器是完成对象的初始化，不是创造对象；
创造对象：加载类信息只会加载一次，在堆中分配空间，默认初始化，显式初始化，构造器初始化，将堆中的地址分配给引用
#### 构造方法的私有化
在类内部去实例化对象，然后返回给static修饰的instance（被static修饰后不受实例化对象的限制，可以通过类名访问），又因为类中的属性必须封装，所以通过静态方法getInstance()方法返回instance（因为instance是静态属性所以要声明为静态方法）；
### this、super
this指代这个对象；this只能出现在构造器的第一行；可以使用this()调用无参构造器；this调用构造方法一定要留一个出口，即程序中至少存在一个构造方法是不使用this调用其他构造方法的，一般将无参构造方法当作出口，即无参构造器最好不要去调用其他构造方法；

### 访问修饰符
public 本类、同包的类、不同包的子类、其他包的类  protected：本包的类和不同包的子类 default：本包的其他类 private：同类
private、protected不能修饰类；类和接口不能被private修饰；子类和父类不在同一个包内，在子类中，子类实例可以访问从父类继承的protected方法，不能访问父类实例的protected方法；只有内部类才能用private、protected修饰
父类声明为public的方法，子类也要声明为public；父类声明为protected的方法，子类要么声明为protected要么public

## 特性
### 封装、继承、多态
#### 继承
子类可以继承父类的私有成员，但是不能直接访问父类的私有属性和方法，需要通过父类提供的getter访问；子类不可以继承父类的构造器，只是显式/隐式的调用；创建子类对象时会先访问父类构造器，完成父类初始化，再去访问子类构造器
在创建子类对象时，无论调用哪个子类构造器都默认调用父类的无参构造器，如果父类没有无参构造器，则需要在子类构造器中用super调用相应的父类构造器完成父类的初始化
不同包下的类需要先导包才能使用，如果某个类使用不同包下的相同类名，而这时默认只能导入一个类的包，则另一个类要全名访问；如果父类的构造器带有参数，则在子类构造器中需要用super显式的调用构造器并附带参数；如果父类构造器没有参数，子类构造器不需要使用super调用父类构造器
#### 多态
向上转型：子类对象->父类对象 Animal ani=new Cat()（可以调用父类的所有成员，不可以调用子类的特有成员）; 向下转型：父类对象->子类对象 Cat cat =(Cat)ani;父类引用可以指向子类对象，子类引用不能指向父类对象
父类引用不能调用没有在父类定义的方法，如果要调用子类定义的其他的方法，需要使用子类实例，可以使用向下转型；在进行向下转型之前需要进行向上转型，如果A类实例化后，直接让B类指向A会在运行时出现异常（B extend A）；一旦发生对象的向上转型后，调用的方法就是被子类重写的方法；
通过子类实例化的对象同时是子类和父类的实例；如果使用父类实例化本类对象，就一定不是子类实例；要调用各个子类自己的方法就需要向下转型；
父类的引用可以指向子类的对象；访问属性要看编译类型；在编译阶段，能调用那些成员取决于编译类型，方法的调用取决于运行类型；向上转型时会遗失除与父类公有的其他方法；只能强制转换父类的引用，不能强制转换父类的对象；
子类之间不能互相转型，向下转型后，可以访问子类的所有成员；属性的值看编译类型；动态绑定机制：调用对象方法时，该方法会和该对象的运行地址绑定，调用属性时，哪里声明们那里使用
## final
final修饰的变量为常量，final修饰的方法不可以被重写；final修饰的类不可以被继承，final修饰的属性一定要赋值，赋值后不可以更改；final修饰的引用变量指的是地址不能变，地址指向的内容可以改变；常量在编译阶段会把使用常量的地方换成真实的字面量；全局变量：public static final;
final可以修饰类、方法、属性，被final修饰，不可以继承父类、不可以重写父类方法、不可以修改类的属性值和局部变量；final赋值位置：构造器、代码块、定义时；final类不能被继承，但是可以实例化对象；如果类没有被final修饰但是又final方法，可以被继承但是不能被重写；如果一个类被final修饰，就没必要再修饰final方法；final不能修饰构造方法；final和static一起修饰不会导致类加载；包装类都是final，String也是final
## 重写、重载
### 重写
同名但是功能不同的方法；声明为final的方法不能被重写；声明为static不能被重写，但是可以被声明；子类和父类在一个包内，子类可以重写除private和final之外的所有方法。子类和父类不在一个包内，只能重写父类声明为protected和public的非final的方法；子类重写不能缩小访问权限；
方法重写时从private变成default不算方法重写；
重写的方法可以抛出任何非强制异常，无论被重写的方法是否抛出异常。但是不能抛出新的强制性异常，或者比重写方法声明范围更广的强制性异常
重写时，子类不能缩小父类的访问权限，子类的访问类型只能是和父类相同或父类访问类型的子类；
### 重载
在同一个类中，同名但不同参数的方法是重载
#### 可变参数
java运行同一个类中同名同功能不同参数的方法封装为一个方法，实参参数可有可无，可变参数要放在形参列表的最后；一个形参列表只有一个可变参数

## ==、equals、hashcode、toString、finalize
==判断基本数据类型是否相等；equals比较引用数据类型是否相等；==和equals比较的都是值，==比较的是值，equals比较的是地址；toString返回的是全类名+@+哈希值的十六进制，一般用来返回对象的属性信息；hashcode：根据对象不同返回不同的数值，两个引用指向同一个对象则哈希值相等；finalize：对象被回收时，系统调用finalize，对象没有引用时，系统认为对象是垃圾
toString方法的基本作用是给子类继承，子类对象调用可以返回自己的地址；对象内容比较时建议使用equals

## 包
一个类要被外包访问，此类一定要定义成public class；一个类文件中有一个public class；如果一个类声明为public class，则类名和文件名要一致；如果使用class声明一个类，则类名和文件名可以不一致；如果一个类只在本包内访问不被外包访问，声明为class即可，若要被外包访问，声明为public class；
如果一个程序同时导入两个包的同名类，在使用时必须明确的写出完整的"包.类名称"
静态导入：如果一个类的方法全部都是静态方法，导入的时候直接使用"import.static 包.类"方式导入；
使用静态导入后，静态方法就不需要通过"类.静态方法()"调用了
### jar命令的使用
把*.class文件压缩成jar文件；当用户得到一个jar文件后，可以设置classpath的方式在系统中注册jar文件；
主要参数：c（创建新的文档）v（生成详细的输出信息）f（指定存档的文件名）


## 静态变量、方法
### 静态变量
静态变量是本类所有对象共有的变量；类加载时类方法会放在方法区，静态变量在类加载时就已经存在，无论是否创建对象；静态变量在jdk8以前放在方法区，8之后放在堆中类对应的class对象中，通过反射加载class对象；方法区的静态方法区
表示对象行为且要访问对象属性，建议声明为实例方法，该方法以执行一个单一功能为目的，声明为静态方法；静态方法中不允许使用和对象有关的关键字；
static不能调用任何非static类型内容，因为在程序中所有属性和方法必须在对象开辟堆内存之后才可以调用，而static类型的方法在对象未被实例化时就可以被类名调用；
main方法由虚拟机调用；jvm调用main时不用创建对象；main方法中可以直接调用main所在类的静态变量和方法，但不能直接访问非静态成员
### 引用传递
在对象引用传递中，一个类可以接收本类对象的实例，而且接收完后，可以方便的通过此对象对私有属性进行访问；

## 代码块
代码块只有方法体，在类加载和创建对象时被隐式调用；代码块的调用顺序在构造器之前；静态代码块只随着类加载而加载一次，普通代码块创建一个对象就创建一次；类加载的时机：1、创建对象实例时2、创建子类对象实例时，会加载父类3、使用类的静态成员时
静态代码块作用：如果在系统启动时需要对静态资源进行初始化，建议使用静态代码块完成数据的初始化
创建一个对象调用的顺序：静态代码块和静态属性初始化、普通代码块和属性初始化、构造器；构造器的最前面隐含了super和调用普通代码块，静态代码块和静态属性的初始化早在类加载时就完成了
创建一个子类，调用顺序：父类静态代码块，父类普通代码块，子类静态代码块，父类构造器，子类普通代码块，子类构造器
普通代码块：直接在方法中定义的代码块
构造块：直接写在类中的代码块;构造块优先于构造方法；
静态代码块  优先于代码块运行，而且不管多少个对象产生，静态代码块只执行一次
静态代码块>构造块>普通代码块
## 接口、抽象类
### 接口
给出一些没有实现的方法封装到一起，到特定的类中需要使用时再具体实现；jdk8之后可以在接口中有具体实现；在接口中，抽象方法不声明为abstract；一个普通类实现接口，需要实现接口中所有方法，否则就要声明为抽象类；接口可以继承接口，不可以继承类；
接口的抽象方法必须声明为public，即便不声明为public，也是默认为public；接口由全局变量和公共的抽象方法组成；在java中一个接口不允许继承抽象类，但是一个接口可以继承多个接口
接口访问属性：接口名.属性；接口属性类型 public static final；一个类实现多个接口，接口的规范不能冲突，多个接口有相同的静态方法不冲突；一个类实现接口又继承父类，父类中有和接口同样的方法，默认使用父类的;一个类实现多个接口，多个接口有同名的方法不冲突，可以让类重写该方法；接口中的方法必须是抽象方法，接口中成员变量必须用final和static修饰；接口中的方法被隐式的定义为public abstract；
#### 接口为什么不能实例化
实例化的意义就是jvm在堆中开辟一块空间用于存放对象；接口中存放的是静态属性和方法声明；接口中的数据都放在代码区和静态数据区，堆中没有数据需要存放；接口的多态：接口类型的变量可以指向实现接口的类的对象实例（IF if=new Cat()）
### 抽象类
一个类没有足够的信息去描述对象；抽象类不能被实例化，要被继承；使用场景：当子类需要完成一定功能，而每个子类功能又不同，可以将方法定义为抽象方法；构造方法和静态方法不能定义为抽象；抽象类可以没有抽象方法，类一旦包含抽象方法就要定义为抽象类；抽象类可以定义构造方法；
abstract只能修饰方法和类；如果一个类继承了抽象类，就要实现抽象类的所有方法，除非声明为抽象类；抽象方法不能用final、static、private修饰；
### 接口和抽象类的区别
抽象类可以有静态代码块，接口不可以有；抽象类中普通方法必须有实现，抽象方法必须没有实现，接口中普通方法不能有实现，jdk8中static和默认方法必须有实现；抽象类中的抽象方法不能用private修饰，接口中默认控制符是public；抽象类中访问控制符无限制；一个接口可以包含多个抽象类，一个抽象类可以包含多个接口；抽象类是包含抽象方法的类，接口是抽象方法和全局常量的集合；抽象类可以实现多个接口，接口可以继承多个接口，不可以继承多个抽象类；抽象类由抽象方法、构造方法、普通方法、常量、变量组成，接口由常量和抽象方法组成；（jdk1.8之后接口定义普通方法和静态方法，要定义普通方法必须使用default，）
一个类不要去继承已经实现好的类，要么继承抽象类，要么实现接口，如果接口和抽象类都可以使用的话，优先使用接口
## 内部类**8
内部类唯一好处就是可以方便的访问外部类的私有属性（通过将内部类拿到外面去），同时外部类也可以访问内部类的私有属性；使用static修饰内部类可以使内部类变成外部类，使用static修饰的内部类不能访问非static的外部类属性；在外部访问内部类：外部类.内部类 内部类对象=外部类实例.new 内部类();首先要找到外部类实例对象，才能通过外部类实例化对象去实例化内部类对象（Outer out=new Outer(); Outer.Inner in= out.new Inner()）；
在方法中定义的内部类不能访问方法的参数，如果方法中的参数想要被访问，就要在参数前加final（1.8之后可以不加final）；
内部类可以直接访问私有属性；局部内部类定义在类中的局部位置，通常在方法和代码块中，可以访问外部类的所有成员，不可以添加访问修饰符；局部内部类访问外部类成员：直接访问；外部类访问局部内部类成员：先创建对象再访问；外部类其他类不能访问局部内部类；其他类访问外部类成员 外部类.this.成员变量
匿名内部类定义在外部类的局部位置（new 类或接口(参数){};），本质是没有名字的局部内部类，是一个对象；匿名内部类产生的对象类型是new的对象的子类类型；
成员内部类定义在外部类的成员位置，可以直接访问外部类的所有成员，不用static修饰，可以添加任何一个修饰符；Outer.Inner inner = new Outer().new Inner(); 成员内部类可以访问外部类的静态成员；成员内部类访问外部类：直接访问；成员内部类访问外部类方法和属性：外部类.this.成员方法/属性
静态内部类定义在外部类成员位置并用static修饰，可以直接访问外部类的静态成员，不可以访问非静态成员，可以添加任意访问修饰符；静态内部类可以直接访问外部类的静态成员，不可以访问非静态成员；

## 枚举
枚举是一种特殊的类，enum定义的枚举类继承了Enum类；枚举是final类，构造器是私有的，对外不能创建对象，枚举类的第一行默认都是罗列枚举对象的名称的；枚举类有自己的构造方法，变量，方法；枚举类只能使用private修饰，所以外部无法调用，枚举类可以有抽象方法和具体方法，如果枚举类包含抽象方法，则枚举类的每个实例都必须实现抽象方法；
自定义枚举：枚举对象需要使用static+final修饰，对象名要大写；自定义步骤：私有化构造器、本类创造一组对象】对外暴露对象、提供get方法
enum枚举类：如果使用enum实现枚举，需要将定义常量对象写在最前面，使用enum开发一个枚举类会默认继承Enum类
枚举对象必须放在枚举类的行首，如果使用无参构造器创建枚举对象，则实参和小括号可以省略；
## 异常
throw用于抛出异常，throws用于在方法声明处指定可能会抛出异常的类型；编译异常：如果不处理，程序无法通过；运行异常：不检查异常，由程序逻辑错误引起的；异常处理机制：如果没有显式处理异常，默认是throws

throws异常处理：如果语句执行中可能出现某种异常，但是不能确定如何处理异常，显式声明将异常抛出，表明该方法不对异常进行处理，由方法的调用者进行处理；throws后跟的可以是异常和异常类型的父类；
在主方法中使用throws，所以在主方法中可以不再使用trycatch语句进行异常的捕捉和处理；异常产生时会由系统产生一个异常类的实例化对象；
运行时异常，程序中没有处理默认throws；子类重写父类方法，子类返回的异常和父类相同或是父类异常的子类；
在throws过程中，有try-catch就不需要throws；自定义异常：当程序中出现错误，但错误信息不在Throwable类中，自己可以设计异常类，自定义异常继承RunTimeException，把自定义异常做成运行时异常可以使用throws在方法声明处添加异常类型
虽然RuntimeException的异常可以不用try-catch处理，但是如果出现异常，就肯定会导致程序中断，所以建议最好使用try-catch
### RuntimeException和Exception的区别
RuntimeException是Exception的子类；Exception定义了必须处理的异常，RuntimeException定义的异常可以选择性的处理；
## 包装类
## String、StringBuffer、StringBuilder
### 创建字符串的方式
通过new创建的字符串对象，每一次new都会申请一个内存空间，内容相同，地址不同；以""方式给出的字符串，只要字符相同，无论出现几次，jvm只会建立一个String对象，在常量池中维护；
每个String对象都是存放在堆内存中；一个字符串就是一个String类的匿名对象；匿名对象就是开辟了堆内存并且可以直接使用的对象；String str1="hello" 在堆中开辟好的堆内存的使用权给了str1；String类所采用的模式是共享设计模式；使用new创建String类对象（String str1=new String("hello")），无论如何都会再开辟一个新空间，所以相当于开辟了两个空间，但是真正使用的只是用new开辟的空间，另一个是垃圾空间
字符串内容不可以更改，实际上是通过内存地址的'断开-连接'变化完成的，本身字符串内容没有变化；字符串的内容不可以改变，能改变的是其内存地址的指向；String作为类的属性存在时，可以改变类的属性内容；
#### 直接赋值和构造方法赋值的区别
直接赋值：只会开辟一片内存，并且会保存在对象池之中以供下次重复使用
构造方法：会开辟两片空间，其中有一块成为垃圾，并且不会自带入池，但是用户可以使用intern手动入池
#### 共享设计模式
在jvm底层实际上会有一个对象池（不一定只保存String对象），当代码中使用直接赋值的方式定义了一个String类对象时，会将字符串对象所使用的匿名对象入池保存，而后如果有其他String类对象也使用直接赋值的方式，并且设置了同样的内容时，那么就不会开辟新的堆内存空间，而是使用已有的对象进行分配

String调用intern()时，如果常量池中包含一个和Stirng对象内容相同的字符串，则返回池中的字符串，如果没有，将该String对象添加到对象池中，并返回此对象的引用；intern()返回的是常量池的地址
常量相加，发生在池中；变量相加，发生在堆中；
String、Stringxx都是final，不能被继承；String的字符串放在final char value[]，地址不能被修改；StringBuffer的字符内容放在char value[] ,所有变化不用依赖每次改变地址来完成；StringBuffer字符放在堆中
String创建的字符串放在常量池中，new创建的字符串在堆中；在堆中生成对象时不会检测该对象是否存在，因此通过new创建的对象，一定是不同的对象；对于字符串的+运算，当编译成class文件时，会自动编译成StringBuffer来进行字符串的连接操作；contact是通过复制数组再通过char数组进行拼接生成一个新的对象，地址会变动
Stringxx可以修饰字符串而不是创建新的对象；在使用StringBuffer时，每次都是对StringBuffer对象本身进行操作，不是产生新对象；StringBuilder不是线程安全，不能同步访问；String保存的是字符串常量，StringBuffer保存的是字符串变量，StringBuffer每次更新的是内容，不是内存地址；StringBuffer()创建了一个大小为16的char[]，参数可以是长度或字符串（总长度=字符串的长度+16）


### 如果自己写一个String类会发生什么
自己写一个String类，会加载不进内存；基于jvm双亲委派机制，类加载器会收到加载器的请求，会把这个请求委派给它的父类加载器。只有父类加载器自己无法完成加载请求时，子类才会自己加载。这样自定义的String类的加载请求就会到达最顶层的Bootstrap ClassLoader启动类加载器，启动类加载器加载的是系统的String对象，用户编写的java.lang.String不会被加载；
不可以自定义以java开头的类，要么由于类加载器的双亲委派机制不能加载进内存，要么即使使用自定义的类加载器去强行加载，也会收到SecurityException

## 多线程
### 进程与线程
进程是程序的一次动态执行过程；进程和线程都是实现并发的一个基本单位。多线程是指一个进程在执行过程中可以产生多个更小的线程，这些线程可以同时存在、同时运行；
### 线程的实现
#### 继承Thread类
一个类只要继承了Thread类，就称作多线程操作类，在Thread子类中，必须重写run()，此方法为线程主体；
如果想要正确的启动线程，不能直接调用run(),应该调用从Thread类中继承的start()；在线程启动时调用的是start()，实际上调用的是run()的主体
Q:启动线程为什么不能直接使用run
A:线程的运行需要本机os支持
如果一个类通过继承Thread类来实现，那么只能调用一次start()，如果调用多次，会抛出异常
#### 实现Runnable接口
实现Runnable接口依旧要依靠Thread类完成启动，在Thread类中提供了public Thread(Runnable target)和public Thread(Runnable target,String name)两种构造方法，这两种构造方法可以接收Runnable的子类实例对象；
#### Thread类和Runnable接口的区别
如果一个类继承Thread类，则不适合多个线程共享资源，而是实现Runnable接口，可以实现共享资源；
#### 多线程的两种实现方式和区别
多线程的两种实现方式都需要一个线程的主类，而这个类可以实现Runnable接口或者继承Thread类，不管哪种方式都需要在子类重写run()
Thread类是Runnable的子类，使用Runnable可以避免单继承的局限，实现资源共享；
继承Thread类
MyThread my=new MyThread();
my.start()
实现Runnable接口
MyThread my=new MyThread();
new Thread(my).start
#### 利用Callable接口实现多线程
Runnable接口中的run()不能返回操作结果，1.5之后提供了一个Callable接口，接口中有一个call()，call可以实现线程操作数据的返回，返回的数据类型由Callable接口上的泛型类型动态决定；
FutureTask实现了RunnableFuture接口，RunnableFuture实现类Future和Runnable接口；FutureTask是Runnable的子类，FutureTask类可以接收Callable接口实例；
### 线程的状态
创建、就绪（线程启动时就进入就绪状态）、运行（就绪状态的线程被调用获取处理器资源时，线程就进入运行状态）、阻塞（可执行状态下调用sleep(),wait(),suspend()，线程进入阻塞态，阻塞时线程不能进入排队队列）、死亡（线程调用stop()或run()）
### 线程操作的线管方法
如果没有为一个线程指定名称，系统会在使用时为线程分配一个名称（Thread-xx）；java中所有线程都是同时启动的；java每次运行至少启动2个线程（一个是main线程，一个是垃圾收集线程）；每当使用java命令执行一个类时，都会启动一个jvm，每一个jvm就是os中启动一个进程；
start()可以通知cpu这个线程已经准备好启动，等待分配cpu资源；主线程可能比其他线程先执行完；
join()可以让线程强制执行，在线程强制执行期间，其他线程无法运行，必须等该线程完成后；
在java程序中，只要前台有一个线程在运行，整个java进程都不会消失
并不一定是线程的优先级高就一定会先执行，哪个线程先执行将由cpu的调度决定；主方法的优先级是NORM_PRIORITY；
yield()将一个线程的操作暂时让给其他线程执行；
### 同步和死锁
#### 使用同步解决问题
解决资源共享的同步操作，可以使用同步代码块和同步方法
##### 同步代码块
synchronized(同步对象){}；在使用同步代码块时必须指定一个需要同步的对象，但一般都将当前对象（this）设置为同步对象
##### 同步方法
可以使用synchronized关键字将方法声明为同步方法
#### 死锁
两个线程都在等待彼此先完成，造成了程序的停滞状态
多个线程共享同一资源时需要同步，过多的同步会造成死锁；
#### 多个线程访问同一资源时需要考虑那些情况 ，会带来哪些问题
1、多个线程访问同一资源时，考虑数据操作的安全性问题，一定要使用同步操作，同步有同步代码块和同步方法；
2、过多的同步会带来死锁
### 生产者和消费者
notify会唤醒第一个等待的线程执行；notifyAll会唤醒所有的等待线程；
#### 加入同步、等待和唤醒
#### sleep和wait的区别
sleep是Thread类定义的static方法，表示线程休眠，将执行机会让给其他线程，但是监控状态依旧保持，休眠时间到即会自动恢复
wait是Object类定义的方法，表示线程等待，一直到执行了notify或notifyAll后才结束等待

## 泛型
泛型的基本原理是通过一个标识表示类中某个属性的类型或者某个方法的返回值及参数类型；
在泛型的指定中是无法指定基本数据类型的，必须设置成一个类，这样在设置数字时就必须使用包装类；
加入泛型最大的好处就是避免类转换异常；在泛型应用中，最好在声明类对象时指定好其内部的数据类型，如Info<String>,否则会出现不安全警告；就算没有指定泛型程序也可以正常运行，而所有统一使用Object进行接收，在定义的时候将泛型擦除；
### 通配符
在进行引用传递的泛型类型必须匹配才可以传递，否则无法传递；？表示可以接收此类型的任意泛型对象，但是使用？接收泛型对象时，不能设置泛型指定的内容，可以设置null值；
#### 受限泛型
<? extends T>表示该通配符所代表的类型是T类型的子类；<? super T>表示该通配符代表的类型是T类型的父类；
泛型不具有继承性，<?> 支持任意泛型类型 <? extends A> 支持A类和A的子类 <? super A> 支持A类和A的父类，不限于直接父类
泛型在类声明和实例化时要指定好需要的类型；泛型可以包装只要编译正常，运行时不会抛出类型异常；如果在创建对象时没有指定类型，默认Object；自定义泛型接口，泛型接口的类型在继承接口或实现接口时确定；自定义泛型方法，可以定义在普通类中，也可以定义在泛型类中，当泛型方法被调用时，类型被确定
### 泛型与子类继承的限制
子类的泛型类型无法使用父类的泛型类型接收，比如Info<String>不能使用Info<Object>接收；泛型中无法向上转型
### 泛型接口
public interface Info<T>{}
泛型接口定义完成后，就要定义此接口的子类，有两种方式，一种是直接在子类之后声明泛型，一种是直接在子类实现的接口中明确给出泛型基础
### 泛型方法
泛型方法的定义与其所在类是否是泛型类没有关系；public <T> T name(T var){}



## Iterator
Iterator it=col.Iterator();
while(it.hasNext()){System.out.println(i.next());}
hasNext()用于判断结合是否还有下一个元素可以访问
next()返回迭代器的下一个元素，并将迭代器的指针移到下一个位置
## ArrayList、vector、LinkedList
ArrayList等同于vector，ArrayList线程不安全，但效率高；创建ArrayList时，如果使用无参构造器，则elementData容量为0，第一次添加扩容为10，再次添加扩容为上次的1.5倍，如果使用指定大小的构造器，elementData容量为指定大小，扩容时为上次的1.5倍；
vector底层是对象数组，线程安全，效率低；vector类的操作方法有synchronized；扩容：如果无参，初始为10，然后2被扩容。如果指定大小按2倍扩容

## Set
set接口无序（添加和取出的顺序不一致），但是取出的顺序是固定的，没有索引，不允许重复元素，最多包含一个null；
set接口的遍历方式：迭代器、增强for；不能使用索引的方式获取元素
### HashSet
底层是HashMap，可以存放null，但是只能有一个；不保证元素有序，元素不重复，线程不安全；如果多个线程同时修改HashSet，最终结果不确定；
扩容：添加一个元素时，会将hash值转化为索引值，找到存储数据表table，查看索引值处是否存在元素，如果不存在元素则插入数据，如果有元素存在，使用equals比较，相同则不添加，不同则添加到最后；当链表长度>8且table大小>=64会进行树化
HashSet底层机制：第一次添加元素时，table数组扩容到16，临界值为16*0.75=12；当table大小达到12时，会按2倍扩容为32，新的临界值为32*0.75=24；HashSet扩容，当链表中元素总和>12时也会扩容

### LinkedHashSet
LinkedHashSet是HashSet的子类，LinkedHashSet的底层是LinkedHashMap，底层维护了一个table数组和双向链表；LinkedHashSet根据元素的hashcode决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序存储的；LinkedHashSet不允许添加重复元素
添加元素时，先求hash值再求索引，确定该元素在hashtable表上的位置，然后将添加的元素加入双向链表（如果已经存在就不添加）；添加第一次，将table扩容到16，存放的节点类型时LinkedHashMap$Entry
## Map
Map和Collection并列存在，用于保存具有映射关系的key-value；map中的kv可以是任何类型的数据，保存在HashSet$Node对象中；map中的key不可以重复，value可以重复，key和value都可以是null，key只能有一个null，value可以有很多null；一对kv是放在node中的

### HashMap
HashMap是一个散列表，存储的内容是键值对映射；HashMap实现类Map接口，根据键的hash值存储数据，最多允许一条记录的键为null，不支持线程同步，HashMap的key和value类型可以相同也可以不同；

HashMap底层维护了node类型的table数组，默认null，当创建对象时，将加载因子初始化为0.75，当添加kv时，通过key的hash值得到table的索引，然后判断索引处是否有元素，如果没有元素直接添加，如果有元素，继续判断该索引处的key和要添加的key是否相同，如果相同直接替换value，如果不同还要判断是树结构还是链表结构；如果添加时发现容量不够还要扩容；

第一次添加时，table扩容为16，临界值为12，再次扩容为32，临界值为24；在java8中，如果数组长度达到8且链表元素个数>=64，就会树化，否则使用数组扩容机制

### Hashtable
Hashtable存放的元素是键值对，hashtable的键值对不能都是null；hashtable线程安全，hashmap线程不安全。
properties继承Hashtable类实现Map接口，使用键值对的形式保存数据，properties可以从xx.properties文件中加载数据到properties类对象并进行读取和修改；



## 反射
基本概念：使用反射机制可以构造类对象，动态获取当前class的信息比如方法的信息、注解信息、方法的参数、属性
实现反射的类库：construct、field、method分别获取类的构造方法、成员变量、方法信息
### 反射机制
反射机制允许程序在执行期借助ReflectionAPI取得任何类的内部信息，并能操作对象的属性及方法；加载完类后，在堆中产生了一个class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息，通过这个对象得到类的结构，称之为反射
在运行时可以完成：判断任意一个对象所属的类，构造任意一个类的对象，得到任意一个类所具有的成员变量和方法，调用任意一个对象的成员变量和方法，生成动态代理
### java程序在计算机的三个阶段
代码阶段：java字节码通过类加载器加载成class对象；class类/加载阶段：class对象表示某个类加载后在堆中的对象；
runtime运行阶段
### class类
class类继承Object，class对象是系统创建的，不是new出来的，对于某个类的class对象，在内存中只有一份，因此类只加载一次，每个类的实例都会记得自己是由哪个class实例生成的；通过class可以完整的得到一个类的完整结构，class对象存放在堆中，类的字节码二进制数据放在方法区；
#### 获取Class对象
Class.forName() 
### 类加载
Dog dog=new Dog()是静态加载；反射是动态加载，只有动态加载该类时，才会报错；静态加载：编译时加载相关的类，如果没有就报错；动态加载：运行时加载需要的类，如果运行时不用该类，则不报错
#### 类加载的时机
new创建对象时；当子类被加载时，父类也被加载；调用类中的静态成员时；通过反射加载；
#### 加载的过程


### 反射技术的应用
jdbc加载驱动器连接，class.forName运用了反射技术；spring框架用反射来实例化对象；自定义注解生效（反射+aop）；第三方核心的框架；动态代理的场景

## io

# javaweb


