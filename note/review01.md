java中可以使用set classpath指定java类的运行路径
## 数据类型
### 基本数据类型
int、char、short、byte、float、double、long long声明的数据加L；float加F；boolean不能与其他类型相互转换
### 引用数据类型
## 内存
### 方法区
栈：方法在栈中执行，没运行一个方法就在栈中单独开一个空间
堆：存储数组和对象，new出来的对象放在堆中
方法区：存储可以运行的class文件
arr=null;数组不会存储数组的内存地址

javaBean可以理解为实体类，成员变量声明为private，内部实现get、set方法

## 类
创建对象时会加载类的信息，分配内存，最后把地址分配给引用；方法区的常量池中存放字符信息，方法区中加载类的信息
### 对象
对象使用前必须实例化，所有对象名称放在栈中（栈中存放对象的地址），真正的对象放在堆中（堆中存放对象属性信息），每个实例化的对象都会占据自己的堆、栈内存空间；类中的全部属性必须封装，封装后的属性必须通过setter和getter方法访问；
#### 匿名对象
一般匿名对象只使用一次，而且匿名对象只在堆内存中开辟空间，不存在栈的引用（new Person("aaa").tell();该对象使用一次后就等待被gc回收）；通常作为其他实例化对象的参数传递；

### 对象数组
数组中包含同一类型的对象，数组要先开辟空间，并且数组中每一个对象都要实例化；
### 内存区域
栈内存：存放所有对象名称
堆内存：保存每个对象的具体内容
全局数据区：保存static类型的属性
全局代码区：保存所有方法的定义

### 作用域
成员变量可以添加访问修饰符，可以在本类及其他类中使用，有默认值，属性随着对象创建而创建，随着对象的销毁而销毁；局部变量不能加访问修饰符，无默认值，只能在本类中使用，局部变量随着代码块的结束而结束；局部变量在栈上分配，必须初始化才能使用，若未初始化，则赋予默认值；局部变量只在声明它的方法、构造方法、语句块中可见；静态变量指在类中定义的变量，随着类的加载而加载，可以加访问修饰符，所有对象实例共享一个静态变量，静态变量与类相关，多个线程访问静态变量会有数据一致性问题，建议采用同步措施；
### 构造器
默认有无参构造器，如果声明了一个新的构造器，就会覆盖默认的无参构造器；构造器是完成对象的初始化，不是创造对象；
创造对象：加载类信息只会加载一次，在堆中分配空间，默认初始化，显式初始化，构造器初始化，将堆中的地址分配给引用
#### 构造方法的私有化
在类内部去实例化对象，然后返回给static修饰的instance（被static修饰后不受实例化对象的限制，可以通过类名访问），又因为类中的属性必须封装，所以通过静态方法getInstance()方法返回instance（因为instance是静态属性所以要声明为静态方法）；
### this、super
this指代这个对象；this只能出现在构造器的第一行；可以使用this()调用无参构造器；this调用构造方法一定要留一个出口，即程序中至少存在一个构造方法是不使用this调用其他构造方法的，一般将无参构造方法当作出口，即无参构造器最好不要去调用其他构造方法；

### 访问修饰符
public 本类、同包的类、不同包的子类、其他包的类  protected：本包的类和不同包的子类 default：本包的其他类 private：同类
private、protected不能修饰类；类和接口不能被private修饰；子类和父类不在同一个包内，在子类中，子类实例可以访问从父类继承的protected方法，不能访问父类实例的protected方法；只有内部类才能用private、protected修饰
父类声明为public的方法，子类也要声明为public；父类声明为protected的方法，子类要么声明为protected要么public

## 特性
### 封装、继承、多态
#### 继承
子类可以继承父类的私有成员，但是不能直接访问父类的私有属性和方法，需要通过父类提供的getter访问；子类不可以继承父类的构造器，只是显式/隐式的调用；创建子类对象时会先访问父类构造器，完成父类初始化，再去访问子类构造器
在创建子类对象时，无论调用哪个子类构造器都默认调用父类的无参构造器，如果父类没有无参构造器，则需要在子类构造器中用super调用相应的父类构造器完成父类的初始化
不同包下的类需要先导包才能使用，如果某个类使用不同包下的相同类名，而这时默认只能导入一个类的包，则另一个类要全名访问；如果父类的构造器带有参数，则在子类构造器中需要用super显式的调用构造器并附带参数；如果父类构造器没有参数，子类构造器不需要使用super调用父类构造器
#### 多态
向上转型：子类对象->父类对象 Animal ani=new Cat()（可以调用父类的所有成员，不可以调用子类的特有成员）; 向下转型：父类对象->子类对象 Cat cat =(Cat)ani;父类引用可以指向子类对象，子类引用不能指向父类对象
父类引用不能调用没有在父类定义的方法，如果要调用子类定义的其他的方法，需要使用子类实例，可以使用向下转型；在进行向下转型之前需要进行向上转型，如果A类实例化后，直接让B类指向A会在运行时出现异常（B extend A）；一旦发生对象的向上转型后，调用的方法就是被子类重写的方法；
通过子类实例化的对象同时是子类和父类的实例；如果使用父类实例化本类对象，就一定不是子类实例；要调用各个子类自己的方法就需要向下转型；
父类的引用可以指向子类的对象；访问属性要看编译类型；在编译阶段，能调用那些成员取决于编译类型，方法的调用取决于运行类型；向上转型时会遗失除与父类公有的其他方法；只能强制转换父类的引用，不能强制转换父类的对象；
子类之间不能互相转型，向下转型后，可以访问子类的所有成员；属性的值看编译类型；动态绑定机制：调用对象方法时，该方法会和该对象的运行地址绑定，调用属性时，哪里声明们那里使用
## final
final修饰的变量为常量，final修饰的方法不可以被重写；final修饰的类不可以被继承，final修饰的属性一定要赋值，赋值后不可以更改；final修饰的引用变量指的是地址不能变，地址指向的内容可以改变；常量在编译阶段会把使用常量的地方换成真实的字面量；全局变量：public static final;
final可以修饰类、方法、属性，被final修饰，不可以继承父类、不可以重写父类方法、不可以修改类的属性值和局部变量；final赋值位置：构造器、代码块、定义时；final类不能被继承，但是可以实例化对象；如果类没有被final修饰但是又final方法，可以被继承但是不能被重写；如果一个类被final修饰，就没必要再修饰final方法；final不能修饰构造方法；final和static一起修饰不会导致类加载；包装类都是final，String也是final
## 重写、重载
### 重写
同名但是功能不同的方法；声明为final的方法不能被重写；声明为static不能被重写，但是可以被声明；子类和父类在一个包内，子类可以重写除private和final之外的所有方法。子类和父类不在一个包内，只能重写父类声明为protected和public的非final的方法；子类重写不能缩小访问权限；
方法重写时从private变成default不算方法重写；
重写的方法可以抛出任何非强制异常，无论被重写的方法是否抛出异常。但是不能抛出新的强制性异常，或者比重写方法声明范围更广的强制性异常
重写时，子类不能缩小父类的访问权限，子类的访问类型只能是和父类相同或父类访问类型的子类；
### 重载
在同一个类中，同名但不同参数的方法是重载
#### 可变参数
java运行同一个类中同名同功能不同参数的方法封装为一个方法，实参参数可有可无，可变参数要放在形参列表的最后；一个形参列表只有一个可变参数

## ==、equals、hashcode、toString、finalize
==判断基本数据类型是否相等；equals比较引用数据类型是否相等；==和equals比较的都是值，==比较的是值，equals比较的是地址；toString返回的是全类名+@+哈希值的十六进制，一般用来返回对象的属性信息；hashcode：根据对象不同返回不同的数值，两个引用指向同一个对象则哈希值相等；finalize：对象被回收时，系统调用finalize，对象没有引用时，系统认为对象是垃圾
toString方法的基本作用是给子类继承，子类对象调用可以返回自己的地址；对象内容比较时建议使用equals

## 包
一个类要被外包访问，此类一定要定义成public class；一个类文件中有一个public class；如果一个类声明为public class，则类名和文件名要一致；如果使用class声明一个类，则类名和文件名可以不一致；如果一个类只在本包内访问不被外包访问，声明为class即可，若要被外包访问，声明为public class；
如果一个程序同时导入两个包的同名类，在使用时必须明确的写出完整的"包.类名称"
静态导入：如果一个类的方法全部都是静态方法，导入的时候直接使用"import.static 包.类"方式导入；
使用静态导入后，静态方法就不需要通过"类.静态方法()"调用了
### jar命令的使用
把*.class文件压缩成jar文件；当用户得到一个jar文件后，可以设置classpath的方式在系统中注册jar文件；
主要参数：c（创建新的文档）v（生成详细的输出信息）f（指定存档的文件名）


## 静态变量、方法
### 静态变量
静态变量是本类所有对象共有的变量；类加载时类方法会放在方法区，静态变量在类加载时就已经存在，无论是否创建对象；静态变量在jdk8以前放在方法区，8之后放在堆中类对应的class对象中，通过反射加载class对象；方法区的静态方法区
表示对象行为且要访问对象属性，建议声明为实例方法，该方法以执行一个单一功能为目的，声明为静态方法；静态方法中不允许使用和对象有关的关键字；
static不能调用任何非static类型内容，因为在程序中所有属性和方法必须在对象开辟堆内存之后才可以调用，而static类型的方法在对象未被实例化时就可以被类名调用；
main方法由虚拟机调用；jvm调用main时不用创建对象；main方法中可以直接调用main所在类的静态变量和方法，但不能直接访问非静态成员
### 引用传递
在对象引用传递中，一个类可以接收本类对象的实例，而且接收完后，可以方便的通过此对象对私有属性进行访问；

## 代码块
代码块只有方法体，在类加载和创建对象时被隐式调用；代码块的调用顺序在构造器之前；静态代码块只随着类加载而加载一次，普通代码块创建一个对象就创建一次；类加载的时机：1、创建对象实例时2、创建子类对象实例时，会加载父类3、使用类的静态成员时
静态代码块作用：如果在系统启动时需要对静态资源进行初始化，建议使用静态代码块完成数据的初始化
创建一个对象调用的顺序：静态代码块和静态属性初始化、普通代码块和属性初始化、构造器；构造器的最前面隐含了super和调用普通代码块，静态代码块和静态属性的初始化早在类加载时就完成了
创建一个子类，调用顺序：父类静态代码块，父类普通代码块，子类静态代码块，父类构造器，子类普通代码块，子类构造器
普通代码块：直接在方法中定义的代码块
构造块：直接写在类中的代码块;构造块优先于构造方法；
静态代码块  优先于代码块运行，而且不管多少个对象产生，静态代码块只执行一次
静态代码块>构造块>普通代码块
## 接口、抽象类
### 接口
给出一些没有实现的方法封装到一起，到特定的类中需要使用时再具体实现；jdk8之后可以在接口中有具体实现；在接口中，抽象方法不声明为abstract；一个普通类实现接口，需要实现接口中所有方法，否则就要声明为抽象类；接口可以继承接口，不可以继承类；
接口的抽象方法必须声明为public，即便不声明为public，也是默认为public；接口由全局变量和公共的抽象方法组成；在java中一个接口不允许继承抽象类，但是一个接口可以继承多个接口
接口访问属性：接口名.属性；接口属性类型 public static final；一个类实现多个接口，接口的规范不能冲突，多个接口有相同的静态方法不冲突；一个类实现接口又继承父类，父类中有和接口同样的方法，默认使用父类的;一个类实现多个接口，多个接口有同名的方法不冲突，可以让类重写该方法；接口中的方法必须是抽象方法，接口中成员变量必须用final和static修饰；接口中的方法被隐式的定义为public abstract；
#### 接口为什么不能实例化
实例化的意义就是jvm在堆中开辟一块空间用于存放对象；接口中存放的是静态属性和方法声明；接口中的数据都放在代码区和静态数据区，堆中没有数据需要存放；接口的多态：接口类型的变量可以指向实现接口的类的对象实例（IF if=new Cat()）
### 抽象类
一个类没有足够的信息去描述对象；抽象类不能被实例化，要被继承；使用场景：当子类需要完成一定功能，而每个子类功能又不同，可以将方法定义为抽象方法；构造方法和静态方法不能定义为抽象；抽象类可以没有抽象方法，类一旦包含抽象方法就要定义为抽象类；抽象类可以定义构造方法；
abstract只能修饰方法和类；如果一个类继承了抽象类，就要实现抽象类的所有方法，除非声明为抽象类；抽象方法不能用final、static、private修饰；
### 接口和抽象类的区别
抽象类可以有静态代码块，接口不可以有；抽象类中普通方法必须有实现，抽象方法必须没有实现，接口中普通方法不能有实现，jdk8中static和默认方法必须有实现；抽象类中的抽象方法不能用private修饰，接口中默认控制符是public；抽象类中访问控制符无限制；一个接口可以包含多个抽象类，一个抽象类可以包含多个接口；抽象类是包含抽象方法的类，接口是抽象方法和全局常量的集合；抽象类可以实现多个接口，接口可以继承多个接口，不可以继承多个抽象类；抽象类由抽象方法、构造方法、普通方法、常量、变量组成，接口由常量和抽象方法组成；（jdk1.8之后接口定义普通方法和静态方法，要定义普通方法必须使用default，）
一个类不要去继承已经实现好的类，要么继承抽象类，要么实现接口，如果接口和抽象类都可以使用的话，优先使用接口
## 内部类**8
内部类唯一好处就是可以方便的访问外部类的私有属性（通过将内部类拿到外面去），同时外部类也可以访问内部类的私有属性；使用static修饰内部类可以使内部类变成外部类，使用static修饰的内部类不能访问非static的外部类属性；在外部访问内部类：外部类.内部类 内部类对象=外部类实例.new 内部类();首先要找到外部类实例对象，才能通过外部类实例化对象去实例化内部类对象（Outer out=new Outer(); Outer.Inner in= out.new Inner()）；
在方法中定义的内部类不能访问方法的参数，如果方法中的参数想要被访问，就要在参数前加final（1.8之后可以不加final）；
内部类可以直接访问私有属性；局部内部类定义在类中的局部位置，通常在方法和代码块中，可以访问外部类的所有成员，不可以添加访问修饰符；局部内部类访问外部类成员：直接访问；外部类访问局部内部类成员：先创建对象再访问；外部类其他类不能访问局部内部类；其他类访问外部类成员 外部类.this.成员变量
匿名内部类定义在外部类的局部位置（new 类或接口(参数){};），本质是没有名字的局部内部类，是一个对象；匿名内部类产生的对象类型是new的对象的子类类型；
成员内部类定义在外部类的成员位置，可以直接访问外部类的所有成员，不用static修饰，可以添加任何一个修饰符；Outer.Inner inner = new Outer().new Inner(); 成员内部类可以访问外部类的静态成员；成员内部类访问外部类：直接访问；成员内部类访问外部类方法和属性：外部类.this.成员方法/属性
静态内部类定义在外部类成员位置并用static修饰，可以直接访问外部类的静态成员，不可以访问非静态成员，可以添加任意访问修饰符；静态内部类可以直接访问外部类的静态成员，不可以访问非静态成员；

## 枚举
### 定义一个枚举类型
enum Color{RED,BLUE;} 取出一个枚举内容:COLOR.RED；枚举数据也可以使用‘枚举类型名称.values()’的形式将枚举类型变为对象数组的形式，然后使用foreach进行输出；在switch中进行判断时，不可以在每个枚举类型值前加枚举类型名，否则编译器报错；
### Enum
枚举名.values()表示得到全部枚举的内容；Enum类提供的name()和ordinal()取得名称和编号；使用Enum.valueOf(Color.class,"RED")也能找到枚举对象；
枚举类也可以实现一个接口，但是因为接口中会存在抽象方法，所以枚举类中的每个对象都必须分别实现此抽象方法；

枚举是一种特殊的类，enum定义的枚举类继承了Enum类；枚举是final类，构造器是私有的，对外不能创建对象，枚举类的第一行默认都是罗列枚举对象的名称的；枚举类有自己的构造方法，变量，方法；枚举类只能使用private修饰，所以外部无法调用，枚举类可以有抽象方法和具体方法，如果枚举类包含抽象方法，则枚举类的每个实例都必须实现抽象方法；
自定义枚举：枚举对象需要使用static+final修饰，对象名要大写；自定义步骤：私有化构造器、本类创造一组对象】对外暴露对象、提供get方法
enum枚举类：如果使用enum实现枚举，需要将定义常量对象写在最前面，使用enum开发一个枚举类会默认继承Enum类
枚举对象必须放在枚举类的行首，如果使用无参构造器创建枚举对象，则实参和小括号可以省略；
## 异常
throw用于抛出异常，throws用于在方法声明处指定可能会抛出异常的类型；编译异常：如果不处理，程序无法通过；运行异常：不检查异常，由程序逻辑错误引起的；异常处理机制：如果没有显式处理异常，默认是throws

throws异常处理：如果语句执行中可能出现某种异常，但是不能确定如何处理异常，显式声明将异常抛出，表明该方法不对异常进行处理，由方法的调用者进行处理；throws后跟的可以是异常和异常类型的父类；
在主方法中使用throws，所以在主方法中可以不再使用trycatch语句进行异常的捕捉和处理；异常产生时会由系统产生一个异常类的实例化对象；
运行时异常，程序中没有处理默认throws；子类重写父类方法，子类返回的异常和父类相同或是父类异常的子类；
在throws过程中，有try-catch就不需要throws；自定义异常：当程序中出现错误，但错误信息不在Throwable类中，自己可以设计异常类，自定义异常继承RunTimeException，把自定义异常做成运行时异常可以使用throws在方法声明处添加异常类型
虽然RuntimeException的异常可以不用try-catch处理，但是如果出现异常，就肯定会导致程序中断，所以建议最好使用try-catch
### RuntimeException和Exception的区别
RuntimeException是Exception的子类；Exception定义了必须处理的异常，RuntimeException定义的异常可以选择性的处理；
## 包装类
## String、StringBuffer、StringBuilder
### 创建字符串的方式
通过new创建的字符串对象，每一次new都会申请一个内存空间，内容相同，地址不同；以""方式给出的字符串，只要字符相同，无论出现几次，jvm只会建立一个String对象，在常量池中维护；
如果要改变String的内容，则改变的是String的引用地址；在String中的替换是replaceAll()，在StringBuffer中替换是replace()；delete()删除指定范围的字符串；indexOf(String str)查找指定的内容是否存在；
StringBuffer类提供的方法都是同步方法，属于安全的线程操作，而StringBuilder类的方法都属于异步方法，属于非线程安全的操作
每个String对象都是存放在堆内存中；一个字符串就是一个String类的匿名对象；匿名对象就是开辟了堆内存并且可以直接使用的对象；String str1="hello" 在堆中开辟好的堆内存的使用权给了str1；String类所采用的模式是共享设计模式；使用new创建String类对象（String str1=new String("hello")），无论如何都会再开辟一个新空间，所以相当于开辟了两个空间，但是真正使用的只是用new开辟的空间，另一个是垃圾空间
字符串内容不可以更改，实际上是通过内存地址的'断开-连接'变化完成的，本身字符串内容没有变化；字符串的内容不可以改变，能改变的是其内存地址的指向；String作为类的属性存在时，可以改变类的属性内容；
#### 直接赋值和构造方法赋值的区别
直接赋值：只会开辟一片内存，并且会保存在对象池之中以供下次重复使用
构造方法：会开辟两片空间，其中有一块成为垃圾，并且不会自带入池，但是用户可以使用intern手动入池
#### 共享设计模式
在jvm底层实际上会有一个对象池（不一定只保存String对象），当代码中使用直接赋值的方式定义了一个String类对象时，会将字符串对象所使用的匿名对象入池保存，而后如果有其他String类对象也使用直接赋值的方式，并且设置了同样的内容时，那么就不会开辟新的堆内存空间，而是使用已有的对象进行分配

String调用intern()时，如果常量池中包含一个和Stirng对象内容相同的字符串，则返回池中的字符串，如果没有，将该String对象添加到对象池中，并返回此对象的引用；intern()返回的是常量池的地址
常量相加，发生在池中；变量相加，发生在堆中；
String、Stringxx都是final，不能被继承；String的字符串放在final char value[]，地址不能被修改；StringBuffer的字符内容放在char value[] ,所有变化不用依赖每次改变地址来完成；StringBuffer字符放在堆中
String创建的字符串放在常量池中，new创建的字符串在堆中；在堆中生成对象时不会检测该对象是否存在，因此通过new创建的对象，一定是不同的对象；对于字符串的+运算，当编译成class文件时，会自动编译成StringBuffer来进行字符串的连接操作；contact是通过复制数组再通过char数组进行拼接生成一个新的对象，地址会变动
Stringxx可以修饰字符串而不是创建新的对象；在使用StringBuffer时，每次都是对StringBuffer对象本身进行操作，不是产生新对象；StringBuilder不是线程安全，不能同步访问；String保存的是字符串常量，StringBuffer保存的是字符串变量，StringBuffer每次更新的是内容，不是内存地址；StringBuffer()创建了一个大小为16的char[]，参数可以是长度或字符串（总长度=字符串的长度+16）

### 如果自己写一个String类会发生什么
自己写一个String类，会加载不进内存；基于jvm双亲委派机制，类加载器会收到加载器的请求，会把这个请求委派给它的父类加载器。只有父类加载器自己无法完成加载请求时，子类才会自己加载。这样自定义的String类的加载请求就会到达最顶层的Bootstrap ClassLoader启动类加载器，启动类加载器加载的是系统的String对象，用户编写的java.lang.String不会被加载；
不可以自定义以java开头的类，要么由于类加载器的双亲委派机制不能加载进内存，要么即使使用自定义的类加载器去强行加载，也会收到SecurityException

## 常用类库
### Runtime
Runtime类表示运行时操作类，是一个封装了jvm进程的类，每一个jvm都对应着一个Runtime类的实例，此实例由jvm运行时为其实例化，在jdk文档中不会找到有关Runtime构造方法的定义，因为Runtime构造方法是私有的(单例模式)
取得一个Runtime实例 Runtime run=Runtime.getRuntime();
#### 得到jvm的内存空间信息
java的内存组成有两部分：一部分是堆内存，堆内存由两部分组成：1、年轻代（主要用于产生新对象）与旧生代（存放应用程序中声明周期最长的存活对象）2、存活空间（存放每次垃圾回收后存活的对象），另一部分是非堆内存，
#### 什么是gc，如何处理
GC指的是释放无用的内存空间；GC会由系统不定期的回收或者调用Runtime类的gc方法手工回收；
### 国际化程序
#### 实现思路
可以根据不同的资源文件（属性文件），所有的资源文件以'key=value'的形式出现，在程序执行中根据key找到value并将value的内容呈现；具体实现：根据Locale类所指定的区域码，然后ResourceBundle类所指定的区域码找到相应的资源文件，如果资源文件中存在动态文本，则使用MessageFormat进行格式化
#### ResourceBundle类
主要作用是读取属性文件，读取属性文件时，可以直接指定属性文件的名称，也可以根据Locale指定的区域码来选取指定的资源文件；如果要使用ResourceBundle对象，则通过ResourceBundle类中的静态方法getBundle取得；
#### 处理动态文本
如果输出消息中多了动态文本，则必须使用占位符表示出动态文本的位置，占位符使用"{编号}"的格式出现，使用占位符后，程序可以直接通过MessageFormat对信息进行格式化，为占位符动态设置文本；
### System类
System类中方法都是静态的；在实际的开发中，垃圾内存的释放基本上都是由系统自动完成的；finalize()方法抛出的是Throwable异常，所以在调用此方法时不一定会在程序运行中产生错误，也有可能产生jvm错误；
对象的生命周期：一个类加载后要进行初始化，然后进行对象的实例化，当一个对象不再使用时就要等待被垃圾收集，之后对象终结，被程序卸载
### 对象克隆技术
直接使用Object类中的clone(),因为clone是受保护的类型，所以在子类中要重写此方法，而且在重写时要扩大访问权限，这样才能被外部调用；但是具体的克隆方法还在Object类中，重写时只需要调用Object类的clone即可；
### Comparable接口
在Arrays类定义的sort方法，存在一个针对于对象数组的排序的操作支持，但是如果要使用这个方法，必须结合比较器来完成；
String、Integer都实现了Comparable接口，这些类的对象数组都可以使用Arrays.sort()进行对象数组排序；
#### 请解释Comparable和Comparator的区别
如果对象数组要进行排序，那么必须设置排序规则，二者都可以实现；Comparable是一个类定义时实现好的接口，这样，此类的对象数组就可以进行排序，在Comparable接口定义下有一个public int compareTo()
Comparator是专门定义一个指定类的比较规则，里面有int compare(),public boolean equals()
### 正则表达式
#### Pattern类和Matcher类
如果想在程序中应用正则表达式，必须依靠Pattern类和Matcher类；
## 多线程
### 进程与线程
进程是程序的一次动态执行过程；进程和线程都是实现并发的一个基本单位。多线程是指一个进程在执行过程中可以产生多个更小的线程，这些线程可以同时存在、同时运行；
### 线程的实现
#### 继承Thread类
一个类只要继承了Thread类，就称作多线程操作类，在Thread子类中，必须重写run()，此方法为线程主体；
如果想要正确的启动线程，不能直接调用run(),应该调用从Thread类中继承的start()；在线程启动时调用的是start()，实际上调用的是run()的主体
Q:启动线程为什么不能直接使用run
A:线程的运行需要本机os支持
如果一个类通过继承Thread类来实现，那么只能调用一次start()，如果调用多次，会抛出异常
#### 实现Runnable接口
实现Runnable接口依旧要依靠Thread类完成启动，在Thread类中提供了public Thread(Runnable target)和public Thread(Runnable target,String name)两种构造方法，这两种构造方法可以接收Runnable的子类实例对象；
#### Thread类和Runnable接口的区别
如果一个类继承Thread类，则不适合多个线程共享资源，而是实现Runnable接口，可以实现共享资源；
#### 多线程的两种实现方式和区别
多线程的两种实现方式都需要一个线程的主类，而这个类可以实现Runnable接口或者继承Thread类，不管哪种方式都需要在子类重写run()
Thread类是Runnable的子类，使用Runnable可以避免单继承的局限，实现资源共享；
继承Thread类
MyThread my=new MyThread();
my.start()
实现Runnable接口
MyThread my=new MyThread();
new Thread(my).start
#### 利用Callable接口实现多线程
Runnable接口中的run()不能返回操作结果，1.5之后提供了一个Callable接口，接口中有一个call()，call可以实现线程操作数据的返回，返回的数据类型由Callable接口上的泛型类型动态决定；
FutureTask实现了RunnableFuture接口，RunnableFuture实现类Future和Runnable接口；FutureTask是Runnable的子类，FutureTask类可以接收Callable接口实例；
### 线程的状态
创建、就绪（线程启动时就进入就绪状态）、运行（就绪状态的线程被调用获取处理器资源时，线程就进入运行状态）、阻塞（可执行状态下调用sleep(),wait(),suspend()，线程进入阻塞态，阻塞时线程不能进入排队队列）、死亡（线程调用stop()或run()）
### 线程操作的线管方法
如果没有为一个线程指定名称，系统会在使用时为线程分配一个名称（Thread-xx）；java中所有线程都是同时启动的；java每次运行至少启动2个线程（一个是main线程，一个是垃圾收集线程）；每当使用java命令执行一个类时，都会启动一个jvm，每一个jvm就是os中启动一个进程；
start()可以通知cpu这个线程已经准备好启动，等待分配cpu资源；主线程可能比其他线程先执行完；
join()可以让线程强制执行，在线程强制执行期间，其他线程无法运行，必须等该线程完成后；
在java程序中，只要前台有一个线程在运行，整个java进程都不会消失
并不一定是线程的优先级高就一定会先执行，哪个线程先执行将由cpu的调度决定；主方法的优先级是NORM_PRIORITY；
yield()将一个线程的操作暂时让给其他线程执行；
### 同步和死锁
#### 使用同步解决问题
解决资源共享的同步操作，可以使用同步代码块和同步方法
##### 同步代码块
synchronized(同步对象){}；在使用同步代码块时必须指定一个需要同步的对象，但一般都将当前对象（this）设置为同步对象
##### 同步方法
可以使用synchronized关键字将方法声明为同步方法
#### 死锁
两个线程都在等待彼此先完成，造成了程序的停滞状态
多个线程共享同一资源时需要同步，过多的同步会造成死锁；
#### 多个线程访问同一资源时需要考虑那些情况 ，会带来哪些问题
1、多个线程访问同一资源时，考虑数据操作的安全性问题，一定要使用同步操作，同步有同步代码块和同步方法；
2、过多的同步会带来死锁
### 生产者和消费者
notify会唤醒第一个等待的线程执行；notifyAll会唤醒所有的等待线程；
#### 加入同步、等待和唤醒
#### sleep和wait的区别
sleep是Thread类定义的static方法，表示线程休眠，将执行机会让给其他线程，但是监控状态依旧保持，休眠时间到即会自动恢复
wait是Object类定义的方法，表示线程等待，一直到执行了notify或notifyAll后才结束等待

## 泛型
泛型的基本原理是通过一个标识表示类中某个属性的类型或者某个方法的返回值及参数类型；
在泛型的指定中是无法指定基本数据类型的，必须设置成一个类，这样在设置数字时就必须使用包装类；
加入泛型最大的好处就是避免类转换异常；在泛型应用中，最好在声明类对象时指定好其内部的数据类型，如Info<String>,否则会出现不安全警告；就算没有指定泛型程序也可以正常运行，而所有统一使用Object进行接收，在定义的时候将泛型擦除；
### 通配符
在进行引用传递的泛型类型必须匹配才可以传递，否则无法传递；？表示可以接收此类型的任意泛型对象，但是使用？接收泛型对象时，不能设置泛型指定的内容，可以设置null值；
#### 受限泛型
<? extends T>表示该通配符所代表的类型是T类型的子类；<? super T>表示该通配符代表的类型是T类型的父类；
泛型不具有继承性，<?> 支持任意泛型类型 <? extends A> 支持A类和A的子类 <? super A> 支持A类和A的父类，不限于直接父类
泛型在类声明和实例化时要指定好需要的类型；泛型可以包装只要编译正常，运行时不会抛出类型异常；如果在创建对象时没有指定类型，默认Object；自定义泛型接口，泛型接口的类型在继承接口或实现接口时确定；自定义泛型方法，可以定义在普通类中，也可以定义在泛型类中，当泛型方法被调用时，类型被确定
### 泛型与子类继承的限制
子类的泛型类型无法使用父类的泛型类型接收，比如Info<String>不能使用Info<Object>接收；泛型中无法向上转型
### 泛型接口
public interface Info<T>{}
泛型接口定义完成后，就要定义此接口的子类，有两种方式，一种是直接在子类之后声明泛型，一种是直接在子类实现的接口中明确给出泛型基础
### 泛型方法
泛型方法的定义与其所在类是否是泛型类没有关系；public <T> T name(T var){}
如果可以通过泛型方法返回泛型类的实例化对象，则必须在方法的返回类型处明确的指定泛型标识
如果有一个方法与要求传入的泛型对象的泛型类型是一致的，也可以通过泛型方法指定；
### 泛型数组
使用泛型方法时，也可以传递或返回一个泛型数组
## IO
### File
实例化File必须设置好路径；File类的对象实例化完成后，可以使用createNewFile()创建一个新文件，但是该方法用了throws，所以在使用时必须和trycatch一起处理；exist()判断文件是否存在，delete()删除文件；mkdir()创建文件夹；
### RandomAccessFile
可以对文件内容进行操作，此类属于随机读取类，可以随机读取一个文件指定位置的数据；如果使用rw的方式声明RandomAccessFile对象时，如果写入的对象不存在，系统将自动创建；读取时所有字符串只能按照byte数组的方式读取出来，而且所有的长度是8位；
### 字节流和字符流
io包中流的操作分为字节流和字符流，字节流输出主要使用OutputStream类，输入使的是InputStream类，在字符流中输出使用的是writer类，输入使用的是reader类
#### 字节流
字节流主要操作byte类型数据；如何增加换行？（直接将字符串要换行处加入一个"\r\n"）;文件读到末尾了，则返回的内容为-1；
#### 字符流
一个字符等于两个字节；
#### 字节流和字符流的区别
字节流在操作的时候不会用到缓冲区（内存），是对文件本身进行操作，字符流在操作时用到缓冲区，通过缓冲区再操作文件；使用字节流更好，因为所有文件在硬盘存储或在传输的时候都是以字节的方式进行的，而字符是只有在内存中才会形成；
#### 类拷贝操作
### 转换流-OutputStreamWriter类和InputStreamReader类
OutputStreamWriter是Writer的子类，将输出的字符流变成字节流；InputStreamReader是Reader的子类，将输入的字节流变成字符流；以文件操作为例，在内存中的字符数据需要通过OutputStreamWriter变成字节流才能保存在文件中，读取时，需要将字节流通过InputStreamReader变成字符流；
### 内存操作流
针对内存操作提供了两组类：1、字节内存流：ByteArrayInputStream（内存字节输入流）、ByteArrayOutputStream（内存字节输出流）2、字符内存流：CharArrayReader（内存字符输入流）CharArrayWriter（内存字符输出流）
字节内存流和字符内存流的区别是操作数据类型，字节内存流操作使用byte数据类型，字符内存流操作使用char数据类型；
ByteArrayInputStream将内容写到内存中，ByteArrayOutputStream将内存中的数据输出；
### 管道流
主要作用是进行两个线程间的通信，分为管道输入流PipeInputStream和管道输出流PipeOutputStream;如果想进行管道输出，则必须把输出流接到输入流上；
### 打印流
OutputStream只能输出字节数据；打印流包含字节打印流和字符打印流，打印流可以打印任何类型的数据类型；PrintStream是OutputStream的子类，
### System类对io的支持
定义了out、in、err三个常量；System.out是PrintStream的对象，PrintStream是OutputStream的子类，可以利用此对象向屏幕上输出信息，即OutputStream哪个子类为其实例化，就具备了向哪输出的能力；
System.err表示的是错误信息输出，如果程序出现错误，可以直接用System.err打印；
System.in是一个键盘的输入流，其本身是InputStream的对象，
#### System.out和System.err的区别
二者都可以输出错误信息，System.out一般是将信息显示给用户看，是正常的信息显示，System.err是不希望用户看到的，会直接在后台打印，专门打印错误信息
### BufferedReader类
BufferedReader类是从缓冲区中读取内容，所有的输入字节数据都将放在缓冲区中，类中定义的构造方法只能接收字符输入流的实例，所以必须使用字符输入流-字节输入流的转换类InputStreamReader类将字节输入流System.in变为字符流，
### Scanner
Scanner将空格看作间隔符，为了保证程序的正确，可以将间隔符改为'\n'；
### 对象序列化
是把一个对象变为二进制的数据流的一种方法，  使用对象输出流输出序列化对象也叫序列化；如果某个属性不希望被序列化可以使用transient关键字，

# 类集框架
Collection子接口：List接口（可以存放重复的内容）、Set接口（不能存放重复的内容）、Queue接口（队列接口）、SortSet接口（可以对集合中的数据进行排序）
## List接口
### ArrayList、vector、LinkedList
ArrayList是List的子类，可以直接通过对象的多态性为List接口实例化；toArray()将集合变为对象数组，但是在类集声明时已经通过泛型指定类集合中的元素类型，所以在接收时要使用泛型指定的类型；
#### ArrayList和vector的区别
ArrayList采用异步处理方式，性能更高，vector采用同步处理方式，性能低；
ArrayList等同于vector，ArrayList属于非线程安全的操作类，但效率高，vector属于线程安全的操作类；
创建ArrayList时，如果使用无参构造器，则elementData容量为0，第一次添加扩容为10，再次添加扩容为上次的1.5倍，如果使用指定大小的构造器，elementData容量为指定大小，扩容时为上次的1.5倍；
vector底层是对象数组，线程安全，效率低；vector类的操作方法有synchronized；扩容：如果无参，初始为10，然后2被扩容。如果指定大小按2倍扩容
### Queue接口
Queue接口是Collection的子接口，可以增加元素并输出；
## Set接口
不能添加重复的元素；Set接口的主要方法和Collection一致；Set接口的实例无法像List接口那样进行双向输出；
set接口无序（添加和取出的顺序不一致），但是取出的顺序是固定的，没有索引，不允许重复元素，最多包含一个null；set接口的遍历方式：迭代器、增强for；不能使用索引的方式获取元素
### 常用子类
Set接口中有HashSet（散列存放）和TreeSet（有序存放）；

#### HashSet
特点是不能存放重复元素，采用散列的存储方式；如果想要去掉重复元素，首先要进行对象是否重复的判断，要想进行这样的判断首先要重写Object类的equals()，才能完成是否相等的判断，需要重写equals和hashcode方法，hashcode可以将类中的全部属性进行适当的计算，求出一个不会重复的哈希码；

##### 底层原理
底层是HashMap，可以存放null，但是只能有一个；不保证元素有序，元素不重复，线程不安全；如果多个线程同时修改HashSet，最终结果不确定；
扩容：添加一个元素时，会将hash值转化为索引值，找到存储数据表table，查看索引值处是否存在元素，如果不存在元素则插入数据，如果有元素存在，使用equals比较，相同则不添加，不同则添加到最后；当链表长度>8且table大小>=64会进行树化
HashSet底层机制：第一次添加元素时，table数组扩容到16，临界值为16*0.75=12；当table大小达到12时，会按2倍扩容为32，新的临界值为32*0.75=24；HashSet扩容，当链表中元素总和>12时也会扩容

#### TreeSet
使用TreeSet可以对输入的数据进行有序排列；TreeSet中每个对象所在类都必须实现Comparable接口才可以正常使用；比较器操作的时候如果某个属性没有进行比较的指定的话，则会认为是同一个对象，
## SortedSet接口
实现此接口的子类都属于排序的子类；
## 集合的输出
Iterator：迭代输出；ListIterator：是Iterator的子接口，专门输出List中的内容；foreach:可以输出数组和集合；
### 迭代输出Iterator
依据指针依次判断是否有数据，如果有数据则进行数据的取出；
Iterator it=col.Iterator();
while(it.hasNext()){System.out.println(i.next());}
hasNext()判断是否还有下一个值；next()取出当前元素；remove():移除当前元素；
如果使用Iterator输出时，由集合对象调用了自身的删除方法，运行时会出现错误；
### 双向迭代输出ListIterator
为List子接口实现双向迭代操作；Iterator主要功能是实现从前向后单向输出，如果想实现双向输出，需要ListIterator；ListIterator只能通过List接口实例化，即只能输出List接口中的内容；由后向前输出时必先由前向后输出；
### foreach
foreach可以完成数组和集合的输出；
### 废弃的接口Enumeration
vector使用Enumeration接口进行输出；
### Map接口
Map.Entry接口是Map中内部定义的一个接口，专门用来保存'key->value'的内容,Map.Entry是使用static声明的内部接口，此接口可以通过'外部类.内部类'的形式直接调用;
在Map的操作中，所有内容都是通过'key->value'的形式存储数据的，对于集合来说，实际上是把'key->value'的数据保存在Map.Entry的实例之后，之后在Map集合中插入一个Map.Entry的实例化对象；
#### Map接口的常用子类
HashMap:无序存放，key不允许重复；Hashtable：无序存放，key不允许重复；TreeMap：可以排序的Map集合，按集合的key排序，key不允许重复；
HashMap本身是Map的子类，直接使用此类为Map接口实例化即可；在Map中提供了一个叫做keySet()的方法，可以将一个Map中的key变成一个Set集合，接收的Set集合里指定的泛型和Map中key的泛型类型保持一致；如果要输出全部的value，要使用values()，但是该方法的返回类型是Collection；
TreeMap子类的主要功能是可以按照key排序；如果使用自定义类做key，则此类必须实现Comparable接口，否则将出现类转换异常；
##### HashMap和Hashtable的区别
HashMap：采用异步处理方式，性能更高；属于非线程安全的操作类，key和value允许保存null；
Hashtable：采用同步处理方式，属于线程安全；key和value不允许保存null；
#### Map接口注意事项
##### 不能直接使用迭代输出Map中的全部内容
对于Map接口来说，其本身是不能直接使用迭代进行输出的，因为Map中存储的是一对值，而Iterator每次只能找到一个值，如果非要使用迭代进行输出，必须达成以下条件：将Map实例通过entrySet()变为Set接口对象、通过Set接口实例为Iterator实例化、通过Iterator迭代输出，每个内容都是Map.Entry、通过Map.Entry进行key->value的分离；
Map输出方式：1、Iterator输出Map2、foreach输出Map（输出时要将Map集合变为Set集合，Set集合中的每一个元素都是Map.Entry）
如果要使用一个自定义的对象表示Map中的key，则对象所在类一定要重写equals和hashcode，否则无法找到对应的value；（如果不重写equals和hashcode，就必须使用自定义类实例化对象）
key可以重复的集合IdentifyHashMap，使用此类只要地址不相等，就表示不重复的key，可以将相同的key添加到集合中；
### SortedMap
属于排序接口，只要是实现类该接口的子类，都属于排序的子类，TreeMap就属于该接口的子类；

### 其他集合类
Stack类是Vector类的子类；
Properties的主要功能是可以方便的实现修改资源文件的功能；
xml（可扩展的标志性语言）所有的属性内容可以通过storeToXML()和loadFormXML()以XML文件格式进行保存和读取；但是使用XML格式保存的时候将按照指定的文档格式进行存放；








### LinkedHashSet
LinkedHashSet是HashSet的子类，LinkedHashSet的底层是LinkedHashMap，底层维护了一个table数组和双向链表；LinkedHashSet根据元素的hashcode决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序存储的；LinkedHashSet不允许添加重复元素
添加元素时，先求hash值再求索引，确定该元素在hashtable表上的位置，然后将添加的元素加入双向链表（如果已经存在就不添加）；添加第一次，将table扩容到16，存放的节点类型时LinkedHashMap$Entry
## Map
Map和Collection并列存在，用于保存具有映射关系的key-value；map中的kv可以是任何类型的数据，保存在HashSet$Node对象中；map中的key不可以重复，value可以重复，key和value都可以是null，key只能有一个null，value可以有很多null；一对kv是放在node中的

### HashMap
HashMap是一个散列表，存储的内容是键值对映射；HashMap实现类Map接口，根据键的hash值存储数据，最多允许一条记录的键为null，不支持线程同步，HashMap的key和value类型可以相同也可以不同；

HashMap底层维护了node类型的table数组，默认null，当创建对象时，将加载因子初始化为0.75，当添加kv时，通过key的hash值得到table的索引，然后判断索引处是否有元素，如果没有元素直接添加，如果有元素，继续判断该索引处的key和要添加的key是否相同，如果相同直接替换value，如果不同还要判断是树结构还是链表结构；如果添加时发现容量不够还要扩容；

第一次添加时，table扩容为16，临界值为12，再次扩容为32，临界值为24；在java8中，如果数组长度达到8且链表元素个数>=64，就会树化，否则使用数组扩容机制

### Hashtable
Hashtable存放的元素是键值对，hashtable的键值对不能都是null；hashtable线程安全，hashmap线程不安全。
properties继承Hashtable类实现Map接口，使用键值对的形式保存数据，properties可以从xx.properties文件中加载数据到properties类对象并进行读取和修改；



## 反射
定义：在运行状态中，可以达到以下目的：对于任意的一个类，可以构造对象，获取此类的属性和方法；对于任意一个对象，可以获得其类，可以调用此对象的属性和方法
核心概念：一切操作都将使用Object完成，类、数组的引用都可以使用Object进行接收；
### Class类
Class类的功能：允许通过一个实例化对象找到一个类的完整信息
public final Class getClass()是从Object类继承来的，Class类是反射的源头；
正常方式：引入需要的包类名称，通过new实例化，取得实例化对象
反射方式：实例化对象，getClass()，得到完整的包类名称
所有类的对象实际上都是Class类的实例（在java中Object类是所有类的父类，那么所有类的对象也都是java.lang.Class类的实例，所以所有的对象都可以转变成java.lang.Class类型表示）
在Class类中本身没有定义任何构造方法，如果要使用首先必须通过forName()的静态方法实例化对象，此外，也可以用'类.class','对象.getClass()'方法实例化；
### Class类的使用
#### 通过无参构造实例化对象
如果想要通过Class类本身实例化其他类的对象，可以使用newInstance(),但是必须要保证被实例化的类中有无参构造方法；
#### 调用有参构造实例化对象
通过Class类的getConstructors()取得本类中的全部构造方法，象构造方法中传入一个对象数组，里面包含构造方法的所需的参数，之后通过Constructor实例化对象；
### 反射的应用
java.lang.reflect包中有以下功能：Constructor（表示类中的构造方法）、Field（表示类中的属性）、Method（表示类中的方法）
#### 取得所实现的全部接口
要取得一个类所实现的全部接口，必须使用Class类中的getInterfaces(),该方法返回一个Class类的对象数组，然后直接利用Class类的getName()取得类的名称；
#### 取得父类
一个类可以实现多个接口，但是只能继承一个父类，所以要想取得一个类的父类，可以直接使用Class类中的getSuperclass()方法，返回的是对象实例；
#### 取得全部构造方法
要取得一个类中的全部构造方法，必须使用Class类中的getConstructors();
#### 取得全部方法
要取得全部方法，可以使用Class类中的getMethod()，此方法返回一个Method类的对象数组；
#### 取得全部属性
取得属性有两种不同的操作
1、得到实现的接口或父类中的公共属性：public Field[] getField() throws SecurityException
2、得到本类中的全部属性public Field[] getDeclaredField() throws SecurityException
以上方法返回的都是Field的数组，每一个Field对象就表示类中的一个属性；
### 反射机制
#### 通过反射调用类中的方法
如果要通过反射调用类中的方法可以通过Method类完成：1、通过Class类的getMethod(String name,Class ParameterTypes)取得一个Method对象，并设置此方法操作时所需要的参数类型2、之后才可以使用invoke()进行调用，并向方法中传递要设置的参数；
在使用invoke()时必须传入一个类的实例化对象，调用方法时必须传递对象实例，同时传递参数值；
#### 调用setter和getter方法
1、设置方法名称2、调用setter方法3、调用getter方法
#### 通过反射操作属性
在反射机制中可以通过Field类操作类中的属性，通过Field类提供的set()和get()可以完成设置和取得属性内容的操作；操作前需要注意，在类中的所有属性已经被设置成私有的访问权限，所以在使用set()和get()的时候首先要先使用Field类中的setAccessible(true)方法将需要操作的属性设置成可以外部访问；
#### 通过反射操作数组
可以通过Class类的getComponentType()获得一个数组的Class对象；
### ClassLoader
功能是可以由用户自己设置类的加载路径；如果要定义属于自己的类加载器，可以直接继承ClassLoader类，该类是一个抽象类，但是没有抽象方法；
#### 能否利用自定义类加载器，加载自己的java.lang.String
ClassLoader使用双亲加载机制，不能够加载；即系统类库依然使用系统的类加载器，而只有非系统类库才可以使用自定义的ClassLoader，java.lang.String是系统类的名字，这个类只能被系统类加载器控制，用户无法定义与之一样的类来实现加载
### 动态代理
每一个代理类只能为一个接口服务，这样开发中必然会导致产生过多的代理，最好的做法是可以通过一个代理类完成全部的代理功能，这时就需要使用动态代理功能；

### 类的声明周期
### 工厂设计模式
### 反射机制
反射机制允许程序在执行期借助ReflectionAPI取得任何类的内部信息，并能操作对象的属性及方法；加载完类后，在堆中产生了一个class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息，通过这个对象得到类的结构，称之为反射
在运行时可以完成：判断任意一个对象所属的类，构造任意一个类的对象，得到任意一个类所具有的成员变量和方法，调用任意一个对象的成员变量和方法，生成动态代理
### java程序在计算机的三个阶段
代码阶段：java字节码通过类加载器加载成class对象；class类/加载阶段：class对象表示某个类加载后在堆中的对象；
runtime运行阶段
### class类
class类继承Object，class对象是系统创建的，不是new出来的，对于某个类的class对象，在内存中只有一份，因此类只加载一次，每个类的实例都会记得自己是由哪个class实例生成的；通过class可以完整的得到一个类的完整结构，class对象存放在堆中，类的字节码二进制数据放在方法区；
#### 获取Class对象
Class.forName() 
### 类加载
Dog dog=new Dog()是静态加载；反射是动态加载，只有动态加载该类时，才会报错；静态加载：编译时加载相关的类，如果没有就报错；动态加载：运行时加载需要的类，如果运行时不用该类，则不报错
#### 类加载的时机
new创建对象时；当子类被加载时，父类也被加载；调用类中的静态成员时；通过反射加载；
#### 加载的过程


### 反射技术的应用
jdbc加载驱动器连接，class.forName运用了反射技术；spring框架用反射来实例化对象；自定义注解生效（反射+aop）；第三方核心的框架；动态代理的场景



# javaweb


