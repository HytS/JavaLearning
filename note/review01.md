java中可以使用set classpath指定java类的运行路径
## 数据类型
### 基本数据类型
int、char、short、byte、float、double、long long声明的数据加L；float加F；boolean不能与其他类型相互转换
### 引用数据类型
## 内存
### 方法区
栈：方法在栈中执行，没运行一个方法就在栈中单独开一个空间
堆：存储数组和对象，new出来的对象放在堆中
方法区：存储可以运行的class文件
arr=null;数组不会存储数组的内存地址

javaBean可以理解为实体类，成员变量声明为private，内部实现get、set方法

## 类
创建对象时会加载类的信息，分配内存，最后把地址分配给引用；方法区的常量池中存放字符信息，方法区中加载类的信息
### 对象
对象使用前必须实例化，所有对象名称放在栈中（栈中存放对象的地址），真正的对象放在堆中（堆中存放对象属性信息），每个实例化的对象都会占据自己的堆、栈内存空间；类中的全部属性必须封装，封装后的属性必须通过setter和getter方法访问；
#### 匿名对象
一般匿名对象只使用一次，而且匿名对象只在堆内存中开辟空间，不存在栈的引用（new Person("aaa").tell();该对象使用一次后就等待被gc回收）；通常作为其他实例化对象的参数传递；


### 作用域
成员变量可以添加访问修饰符，可以在本类及其他类中使用，有默认值，属性随着对象创建而创建，随着对象的销毁而销毁；局部变量不能加访问修饰符，无默认值，只能在本类中使用，局部变量随着代码块的结束而结束；局部变量在栈上分配，必须初始化才能使用，若未初始化，则赋予默认值；局部变量只在声明它的方法、构造方法、语句块中可见；静态变量指在类中定义的变量，随着类的加载而加载，可以加访问修饰符，所有对象实例共享一个静态变量，静态变量与类相关，多个线程访问静态变量会有数据一致性问题，建议采用同步措施；
### 构造器
默认有无参构造器，如果声明了一个新的构造器，就会覆盖默认的无参构造器；构造器是完成对象的初始化，不是创造对象；
创造对象：加载类信息只会加载一次，在堆中分配空间，默认初始化，显式初始化，构造器初始化，将堆中的地址分配给引用
### this、super
this指代这个对象；this只能出现在构造器的第一行；

### 访问修饰符
public 本类、同包、子类、不同包 default：同一包内可见 protected：对同包的类和所有子类可见 private：同类
private、protected不能修饰类；类和接口不能被private修饰；子类和父类不在同一个包内，在子类中，子类实例可以访问从父类继承的protected方法，不能访问父类实例的protected方法；只有内部类才能用private、protected修饰
父类声明为public的方法，子类也要声明为public；父类声明为protected的方法，子类要么声明为protected要么public

## 特性
### 封装、继承、多态
#### 继承
子类可以继承父类的私有成员，但是不能访问父类的私有属性和方法，需要通过父类提供的公共方法区访问；子类不可以继承父类的构造器，只是显式/隐式的调用；创建子类对象时会先访问父类构造器，完成父类初始化，再去访问子类构造器
在创建子类对象时，无论调用哪个子类构造器都默认调用父类的无参构造器，如果父类没有无参构造器，则需要在子类构造器中用super调用相应的父类构造器完成父类的初始化
不同包下的类需要先导包才能使用，如果某个类使用不同包下的相同类名，而这时默认只能导入一个类的包，则另一个类要全名访问；如果父类的构造器带有参数，则在子类构造器中需要用super显式的调用构造器并附带参数；如果父类构造器没有参数，子类构造器不需要使用super调用父类构造器
#### 多态
向上转型 Animal ani=new Cat()（可以调用父类的所有成员，不可以调用子类的特有成员）; 向下转型 Cat cat =(Cat)ani;父类引用可以指向子类对象，子类引用不能指向父类对象
父类的引用可以指向子类的对象；访问属性要看编译类型；在编译阶段，能调用那些成员取决于编译类型，方法的调用取决于运行类型；向上转型时会遗失除与父类公有的其他方法；只能强制转换父类的引用，不能强制转换父类的对象；
子类之间不能互相转型，向下转型后，可以访问子类的所有成员；属性的值看编译类型；动态绑定机制：调用对象方法时，该方法会和该对象的运行地址绑定，调用属性时，哪里声明们那里使用
## final
final修饰的变量为常量，final修饰的方法不可以被重写；final修饰的类不可以被继承，final修饰的属性一定要赋值，赋值后不可以更改；final修饰的引用变量指的是地址不能变，地址指向的内容可以改变；常量在编译阶段会把使用常量的地方换成真实的字面量；
final可以修饰类、方法、属性，被final修饰，不可以继承父类、不可以重写父类方法、不可以修改类的属性值和局部变量；final赋值位置：构造器、代码块、定义时；final类不能被继承，但是可以实例化对象；如果类没有被final修饰但是又final方法，可以被继承但是不能被重写；如果一个类被final修饰，就没必要再修饰final方法；final不能修饰构造方法；final和static一起修饰不会导致类加载；包装类都是final，String也是final
## 重写、重载
### 重写
同名但是功能不同的方法；声明为final的方法不能被重写；声明为static不能被重写，但是可以被声明；子类和父类在一个包内，子类可以重写除private和final之外的所有方法。子类和父类不在一个包内，只能重写父类声明为protected和public的非final的方法
重写的方法可以抛出任何非强制异常，无论被重写的方法是否抛出异常。但是不能抛出新的强制性异常，或者比重写方法声明范围更广的强制性异常
重写时，子类不能缩小父类的访问权限，子类的访问类型只能是和父类相同或父类访问类型的子类；
### 重载
在同一个类中，同名但不同参数的方法是重载
#### 可变参数
java运行同一个类中同名同功能不同参数的方法封装为一个方法，实参参数可有可无，可变参数要放在形参列表的最后；一个形参列表只有一个可变参数

## ==、equals、hashcode、toString、finalize
==判断基本数据类型是否相等；equals比较引用数据类型是否相等；==和equals比较的都是值，==比较的是值，equals比较的是地址；toString返回的是全类名+@+哈希值的十六进制，一般用来返回对象的属性信息；hashcode：根据对象不同返回不同的数值，两个引用指向同一个对象则哈希值相等；finalize：对象被回收时，系统调用finalize，对象没有引用时，系统认为对象是垃圾
toString方法的基本作用是给子类继承，子类对象调用可以返回自己的地址；对象内容比较时建议使用equals

## 静态变量、方法
### 静态变量
静态变量是本类所有对象共有的变量；类加载时类方法会放在方法区，静态变量在类加载时就已经存在，无论是否创建对象；静态变量在jdk8以前放在方法区，8之后放在堆中类对应的class对象中，通过反射加载class对象；方法区的静态方法区
表示对象行为且要访问对象属性，建议声明为实例方法，该方法以执行一个单一功能为目的，声明为静态方法；静态方法中不允许使用和对象有关的关键字；

main方法由虚拟机调用；jvm调用main时不用创建对象；main方法中可以直接调用main所在类的静态变量和方法，但不能直接访问非静态成员
### 引用传递
在对象引用传递中，一个类可以接收本类对象的实例，而且接收完后，可以方便的通过此对象对私有属性进行访问；

## 代码块
代码块只有方法体，在类加载和创建对象时被隐式调用；代码块的调用顺序在构造器之前；静态代码块只随着类加载而加载一次，普通代码块创建一个对象就创建一次；类加载的时机：1、创建对象实例时2、创建子类对象实例时，会加载父类3、使用类的静态成员时
静态代码块作用：如果在系统启动时需要对静态资源进行初始化，建议使用静态代码块完成数据的初始化
创建一个对象调用的顺序：静态代码块和静态属性初始化、普通代码块和属性初始化、构造器；构造器的最前面隐含了super和调用普通代码块，静态代码块和静态属性的初始化早在类加载时就完成了
创建一个子类，调用顺序：父类静态代码块，父类普通代码块，子类静态代码块，父类构造器，子类普通代码块，子类构造器
## 接口、抽象类
### 接口
给出一些没有实现的方法封装到一起，到特定的类中需要使用时再具体实现；jdk8之后可以在接口中有具体实现；在接口中，抽象方法不声明为abstract；一个普通类实现接口，需要实现接口中所有方法，否则就要声明为抽象类；接口可以继承接口，不可以继承类；
接口访问属性：接口名.属性；接口属性类型 public static final；一个类实现多个接口，接口的规范不能冲突，多个接口有相同的静态方法不冲突；一个类实现接口又继承父类，父类中有和接口同样的方法，默认使用父类的;一个类实现多个接口，多个接口有同名的方法不冲突，可以让类重写该方法；接口中的方法必须是抽象方法，接口中成员变量必须用final和static修饰；接口中的方法被隐式的定义为public abstract；
#### 接口为什么不能实例化
实例化的意义就是jvm在堆中开辟一块空间用于存放对象；接口中存放的是静态属性和方法声明；接口中的数据都放在代码区和静态数据区，堆中没有数据需要存放；接口的多态：接口类型的变量可以指向实现接口的类的对象实例（IF if=new Cat()）
### 抽象类
一个类没有足够的信息去描述对象；抽象类不能被实例化，要被继承；使用场景：当子类需要完成一定功能，而每个子类功能又不同，可以将方法定义为抽象方法；构造方法和静态方法不能定义为抽象；抽象类可以没有抽象方法，类一旦包含抽象方法就要定义为抽象类；
abstract只能修饰方法和类；如果一个类继承了抽象类，就要实现抽象类的所有方法，除非声明为抽象类；抽象方法不能用final、static、private修饰；
### 接口和抽象类的区别
抽象类可以有静态代码块，接口不可以有；抽象类中普通方法必须有实现，抽象方法必须没有实现，接口中普通方法不能有实现，jdk8中static和默认方法必须有实现；抽象类中的抽象方法不能用private修饰，接口中默认控制符是public；抽象类中访问控制符无限制；
## 内部类**8
内部类可以直接访问私有属性；局部内部类定义在类中的局部位置，通常在方法和代码块中，可以访问外部类的所有成员，不可以添加访问修饰符；局部内部类访问外部类成员：直接访问；外部类访问局部内部类成员：先创建对象再访问；外部类其他类不能访问局部内部类；其他类访问外部类成员 外部类.this.成员变量
匿名内部类定义在外部类的局部位置（new 类或接口(参数){};），本质是没有名字的局部内部类，是一个对象；匿名内部类产生的对象类型是new的对象的子类类型；
成员内部类定义在外部类的成员位置，可以直接访问外部类的所有成员，不用static修饰，可以添加任何一个修饰符；Outer.Inner inner = new Outer().new Inner(); 成员内部类可以访问外部类的静态成员；成员内部类访问外部类：直接访问；成员内部类访问外部类方法和属性：外部类.this.成员方法/属性
静态内部类定义在外部类成员位置并用static修饰，可以直接访问外部类的静态成员，不可以访问非静态成员，可以添加任意访问修饰符；静态内部类可以直接访问外部类的静态成员，不可以访问非静态成员；

## 枚举
枚举是一种特殊的类，enum定义的枚举类继承了Enum类；枚举是final类，构造器是私有的，对外不能创建对象，枚举类的第一行默认都是罗列枚举对象的名称的；枚举类有自己的构造方法，变量，方法；枚举类只能使用private修饰，所以外部无法调用，枚举类可以有抽象方法和具体方法，如果枚举类包含抽象方法，则枚举类的每个实例都必须实现抽象方法；
自定义枚举：枚举对象需要使用static+final修饰，对象名要大写；自定义步骤：私有化构造器、本类创造一组对象】对外暴露对象、提供get方法
enum枚举类：如果使用enum实现枚举，需要将定义常量对象写在最前面，使用enum开发一个枚举类会默认继承Enum类
枚举对象必须放在枚举类的行首，如果使用无参构造器创建枚举对象，则实参和小括号可以省略；
## 异常
throw用于抛出异常，throws用于在方法声明处指定可能会抛出异常的类型；编译异常：如果不处理，程序无法通过；运行异常：不检查异常，由程序逻辑错误引起的；异常处理机制：如果没有显式处理异常，默认是throws
throws异常处理：如果语句执行中可能出现某种异常，但是不能确定如何处理异常，显式声明将异常抛出，表明该方法不对异常进行处理，由方法的调用者进行处理；throws后跟的可以是异常和异常类型的父类；
运行时异常，程序中没有处理默认throws；子类重写父类方法，子类返回的异常和父类相同或是父类异常的子类；
在throws过程中，有try-catch就不需要throws；自定义异常：当程序中出现错误，但错误信息不在Throwable类中，自己可以设计异常类，自定义异常继承RunTimeException，把自定义异常做成运行时异常可以使用throws在方法声明处添加异常类型
## 包装类
## String、StringBuffer、StringBuilder
### 创建字符串的方式
通过new创建的字符串对象，每一次new都会申请一个内存空间，内容相同，地址不同；以""方式给出的字符串，只要字符相同，无论出现几次，jvm只会建立一个String对象，在常量池中维护；
每个String对象都是存放在堆内存中；一个字符串就是一个String类的匿名对象；匿名对象就是开辟了堆内存并且可以直接使用的对象；String str1="hello" 在堆中开辟好的堆内存的使用权给了str1；String类所采用的模式是共享设计模式；使用new创建String类对象（String str1=new String("hello")），无论如何都会再开辟一个新空间，所以相当于开辟了两个空间，但是真正使用的只是用new开辟的空间，另一个是垃圾空间
字符串内容不可以更改，实际上是通过内存地址的'断开-连接'变化完成的，本身字符串内容没有变化；字符串的内容不可以改变，能改变的是其内存地址的指向；String作为类的属性存在时，可以改变类的属性内容；
#### 直接赋值和构造方法赋值的区别
直接赋值：只会开辟一片内存，并且会保存在对象池之中以供下次重复使用
构造方法：会开辟两片空间，其中有一块成为垃圾，并且不会自带入池，但是用户可以使用intern手动入池
#### 共享设计模式
在jvm底层实际上会有一个对象池（不一定只保存String对象），当代码中使用直接赋值的方式定义了一个String类对象时，会将字符串对象所使用的匿名对象入池保存，而后如果有其他String类对象也使用直接赋值的方式，并且设置了同样的内容时，那么就不会开辟新的堆内存空间，而是使用已有的对象进行分配

String调用intern()时，如果常量池中包含一个和Stirng对象内容相同的字符串，则返回池中的字符串，如果没有，将该String对象添加到对象池中，并返回此对象的引用；intern()返回的是常量池的地址
常量相加，发生在池中；变量相加，发生在堆中；
String、Stringxx都是final，不能被继承；String的字符串放在final char value[]，地址不能被修改；StringBuffer的字符内容放在char value[] ,所有变化不用依赖每次改变地址来完成；StringBuffer字符放在堆中
String创建的字符串放在常量池中，new创建的字符串在堆中；在堆中生成对象时不会检测该对象是否存在，因此通过new创建的对象，一定是不同的对象；对于字符串的+运算，当编译成class文件时，会自动编译成StringBuffer来进行字符串的连接操作；contact是通过复制数组再通过char数组进行拼接生成一个新的对象，地址会变动
Stringxx可以修饰字符串而不是创建新的对象；在使用StringBuffer时，每次都是对StringBuffer对象本身进行操作，不是产生新对象；StringBuilder不是线程安全，不能同步访问；String保存的是字符串常量，StringBuffer保存的是字符串变量，StringBuffer每次更新的是内容，不是内存地址；StringBuffer()创建了一个大小为16的char[]，参数可以是长度或字符串（总长度=字符串的长度+16）


### 如果自己写一个String类会发生什么
自己写一个String类，会加载不进内存；基于jvm双亲委派机制，类加载器会收到加载器的请求，会把这个请求委派给它的父类加载器。只有父类加载器自己无法完成加载请求时，子类才会自己加载。这样自定义的String类的加载请求就会到达最顶层的Bootstrap ClassLoader启动类加载器，启动类加载器加载的是系统的String对象，用户编写的java.lang.String不会被加载；
不可以自定义以java开头的类，要么由于类加载器的双亲委派机制不能加载进内存，要么即使使用自定义的类加载器去强行加载，也会收到SecurityException

## Iterator
Iterator it=col.Iterator();
while(it.hasNext()){System.out.println(i.next());}
hasNext()用于判断结合是否还有下一个元素可以访问
next()返回迭代器的下一个元素，并将迭代器的指针移到下一个位置
## ArrayList、vector、LinkedList
ArrayList等同于vector，ArrayList线程不安全，但效率高；创建ArrayList时，如果使用无参构造器，则elementData容量为0，第一次添加扩容为10，再次添加扩容为上次的1.5倍，如果使用指定大小的构造器，elementData容量为指定大小，扩容时为上次的1.5倍；
vector底层是对象数组，线程安全，效率低；vector类的操作方法有synchronized；扩容：如果无参，初始为10，然后2被扩容。如果指定大小按2倍扩容

## Set
set接口无序（添加和取出的顺序不一致），但是取出的顺序是固定的，没有索引，不允许重复元素，最多包含一个null；
set接口的遍历方式：迭代器、增强for；不能使用索引的方式获取元素
### HashSet
底层是HashMap，可以存放null，但是只能有一个；不保证元素有序，元素不重复，线程不安全；如果多个线程同时修改HashSet，最终结果不确定；
扩容：添加一个元素时，会将hash值转化为索引值，找到存储数据表table，查看索引值处是否存在元素，如果不存在元素则插入数据，如果有元素存在，使用equals比较，相同则不添加，不同则添加到最后；当链表长度>8且table大小>=64会进行树化
HashSet底层机制：第一次添加元素时，table数组扩容到16，临界值为16*0.75=12；当table大小达到12时，会按2倍扩容为32，新的临界值为32*0.75=24；HashSet扩容，当链表中元素总和>12时也会扩容

### LinkedHashSet
LinkedHashSet是HashSet的子类，LinkedHashSet的底层是LinkedHashMap，底层维护了一个table数组和双向链表；LinkedHashSet根据元素的hashcode决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序存储的；LinkedHashSet不允许添加重复元素
添加元素时，先求hash值再求索引，确定该元素在hashtable表上的位置，然后将添加的元素加入双向链表（如果已经存在就不添加）；添加第一次，将table扩容到16，存放的节点类型时LinkedHashMap$Entry
## Map
Map和Collection并列存在，用于保存具有映射关系的key-value；map中的kv可以是任何类型的数据，保存在HashSet$Node对象中；map中的key不可以重复，value可以重复，key和value都可以是null，key只能有一个null，value可以有很多null；一对kv是放在node中的

### HashMap
HashMap是一个散列表，存储的内容是键值对映射；HashMap实现类Map接口，根据键的hash值存储数据，最多允许一条记录的键为null，不支持线程同步，HashMap的key和value类型可以相同也可以不同；

HashMap底层维护了node类型的table数组，默认null，当创建对象时，将加载因子初始化为0.75，当添加kv时，通过key的hash值得到table的索引，然后判断索引处是否有元素，如果没有元素直接添加，如果有元素，继续判断该索引处的key和要添加的key是否相同，如果相同直接替换value，如果不同还要判断是树结构还是链表结构；如果添加时发现容量不够还要扩容；

第一次添加时，table扩容为16，临界值为12，再次扩容为32，临界值为24；在java8中，如果数组长度达到8且链表元素个数>=64，就会树化，否则使用数组扩容机制

### Hashtable
Hashtable存放的元素是键值对，hashtable的键值对不能都是null；hashtable线程安全，hashmap线程不安全。
properties继承Hashtable类实现Map接口，使用键值对的形式保存数据，properties可以从xx.properties文件中加载数据到properties类对象并进行读取和修改；
## 泛型
类型通配符一般使用?代替具体的类型参数；<? extends T>表示该通配符所代表的类型是T类型的子类；<? super T>表示该通配符代表的类型是T类型的父类；泛型在类声明和实例化时要指定好需要的类型；泛型可以包装只要编译正常，运行时不会抛出类型异常；如果在创建对象时没有指定类型，默认Object；自定义泛型接口，泛型接口的类型在继承接口或实现接口时确定；自定义泛型方法，可以定义在普通类中，也可以定义在泛型类中，当泛型方法被调用时，类型被确定

泛型不具有继承性，<?> 支持任意泛型类型 <? extends A> 支持A类和A的子类 <? super A> 支持A类和A的父类，不限于直接父类


## 反射
基本概念：使用反射机制可以构造类对象，动态获取当前class的信息比如方法的信息、注解信息、方法的参数、属性
实现反射的类库：construct、field、method分别获取类的构造方法、成员变量、方法信息
### 反射机制
反射机制允许程序在执行期借助ReflectionAPI取得任何类的内部信息，并能操作对象的属性及方法；加载完类后，在堆中产生了一个class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息，通过这个对象得到类的结构，称之为反射
在运行时可以完成：判断任意一个对象所属的类，构造任意一个类的对象，得到任意一个类所具有的成员变量和方法，调用任意一个对象的成员变量和方法，生成动态代理
### java程序在计算机的三个阶段
代码阶段：java字节码通过类加载器加载成class对象；class类/加载阶段：class对象表示某个类加载后在堆中的对象；
runtime运行阶段
### class类
class类继承Object，class对象是系统创建的，不是new出来的，对于某个类的class对象，在内存中只有一份，因此类只加载一次，每个类的实例都会记得自己是由哪个class实例生成的；通过class可以完整的得到一个类的完整结构，class对象存放在堆中，类的字节码二进制数据放在方法区；
#### 获取Class对象
Class.forName() 
### 类加载
Dog dog=new Dog()是静态加载；反射是动态加载，只有动态加载该类时，才会报错；静态加载：编译时加载相关的类，如果没有就报错；动态加载：运行时加载需要的类，如果运行时不用该类，则不报错
#### 类加载的时机
new创建对象时；当子类被加载时，父类也被加载；调用类中的静态成员时；通过反射加载；
#### 加载的过程


### 反射技术的应用
jdbc加载驱动器连接，class.forName运用了反射技术；spring框架用反射来实例化对象；自定义注解生效（反射+aop）；第三方核心的框架；动态代理的场景

## io

# javaweb


