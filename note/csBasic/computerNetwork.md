### osi七层模型
应用、表示、会话、传输、网络、数字链路、物理
每一层都专注做一件事，并且每一次都需要使用下一层提供的功能

### tcp四层模型
应用、传输、网络、网络接口层

### 为什么网络要分层
复杂的系统需要分层，因为每一层都要专注一类事情

各层之间相互独立：只需要直到自己如何调用下层提供好的功能就可以了
提高了灵活性和可替换性：每一层都需要最合适的技术来实现，你只需要保证提供的功能和暴露的接口的规则没有改变就行了，并且每一层可以根据需要进行修改或替换，而不会影响到整个网络的结构
大问题化小

### 常见的网络协议
http 超文本传输协议 主要用于web浏览器和web服务器的通信
smtp 简单邮件发送协议 只负责邮件的发送，而不是接收
pop3/imap 邮件接收协议 两者都是负责邮件接收的协议，imap比pop3性能更好
ftp 文件传输协议 用于在计算机之间传输文件的协议，ftp是不安全协议，在传输过程中不会对数据加密，传输敏感数据用sftp
telent 远程登陆协议 用于通过一个终端登陆到其他服务器，缺点是所有数据均已明文传输
ssh 安全的网络传输协议 通过加密和认证机制实现安全的访问和文件传输等业务
rtp 实时传输协议 提供了端到端的实时传输数据的功能
dns 域名管理系统 用于解决域名和ip地址的映射问题

### 传输层常见的协议
tcp 传输控制协议 提供面向连接、可靠的服务
udp 用户数据协议 提供无连接、尽最大努力的数据传输服务（不保证数据传输的可靠性）

### 网络层有哪些常见的协议
ip 网际协议 属于网络层的协议，作用：定义数据包的格式，对数据包进行路由和寻址，以便它们可以跨网络传播并达到正确的目的地，
arp 地址解析协议 解决的是网络层和数据链路层之间的转换问题，因为一个ip数据报在物理上传输的过程中，总需要知道物理上的下一个地址，但ip地址属于逻辑地址，而mac地址才是物理地址，arp解决了ip地址转mac地址的一些问题
icmp 互联网控制报文协议 一种用于传输网络状态和错误消息的协议
nat 网络地址转换协议 在一个小的子网（LAN）内，各主机使用的是同一个LAN的ip地址，在该LAN外，在WAN中，需要一个同一的ip地址来标识该LAN在internet上的地址
ospf 开放式最短路径优先 基于链路状态算法，考虑了链路带宽、延迟等因素来选择路径
rip 路由信息协议 基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。
bgp 边界网关协议 一种用来在路由选择域之间交换网络层可达性信息的路由选择协议

### 从输入url到页面展示发生了什么
1、浏览器查找域名的ip地址（dns查找过程：浏览器缓存、路由器缓存、dns缓存）
    dns：获取域名对应ip
2、浏览器向web服务器发送一个http请求（cookies会随着请求发送给服务器）
3、服务器处理请求（请求处理请求&它的参数、cookies、生成一个html响应）
4、服务器发回一个html响应
5、浏览器开始显示html
    tcp：与服务器建立tcp连接；ip：建立tcp连接，需要发送数据，发送数据在网络层使用ip协议；ospf：IP数据包在路由器之间，路由选择ospf协议；arp：路由器与服务器通信时，需要将ip转换为mac地址，需要使用arp协议
    http：在tcp建立完成后，使用http协议访问网页
dns解析--tcp连接--发送http请求--服务器处理请求并返回http报文--浏览器解析渲染画面--连接结束

### http状态码
1xx 信息性状态码        接受的请求正在处理
2xx 成功状态码          请求正常处理完毕
3xx 重定向状态码        需要进行附加操作以完成请求
4xx 客户端错误状态码    服务器无法处理请求
5xx 服务器错误状态码    服务器处理请求出错

### http和https区别
端口号 http 默认80 https 默认443
安全性和资源消耗：http协议运行在tcp之上，所有传输的内容都是明文，客户端和服务器无法检验对方的身份，https时运行在ssl/tls之上的http协议，ssl/tls运行在tcp之上。所有的传输内容都经过加密，加密采取对称加密，但对称加密的密钥用服务器放的证书进行非对称加密，即http安全性没有https高，但https比http耗费更多服务器资源
seo（搜索引擎优化）：搜索引擎通常更青睐使用https协议的网站，因为https能提供更高的安全性和用户隐私保护，使用https协议的网站在搜索结果中可能会被优先显示

### http/1.0和http/1.1有什么区别
连接方式 http/1.0短连接 http/1.1长连接
状态响应码 http/1.1中新加入了大量的状态码
缓存机制：在http/1.0中主要使用header里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
带宽：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
Host 头（Host Header）处理 :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

### http/1.1和http/2.0有什么区别
多路复用：http/2.0在同一连接上可以同时传输多个请求和响应，互不干扰。http/1.1则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会由6-8各tcp连接都限制，这使得http/2.0在处理多个请求时更高效
二进制帧：http/2.0使用二进制帧进行数据传输，而http/1.1则使用文本格式的报文，二进制帧更加紧凑和高效
头部压缩：http/1.1支持body压缩，header不支持压缩。http/2.0支持header压缩，使用了专门为header压缩而设计的hpack算法，减少了网络开销
服务器推送：http/2.0支持服务器推送，可以在客户端请求一个资源时，将其他资源一并推送给客户端，从而减少客户端的请求次数和延迟；而http/1.1需要客户端自己发送请求获取资源

http/2.0的多路复用使得不同请求可以共用一个tcp连接，避免建立多个连接带来不必要的额外开销，而http/1.1中的每个请求都会建立一个单独的连接

### http/2.0和http/3.0有什么区别
传输协议：http/2.0是基于tcp协议实现的，http/3.0新增了quic协议实现可靠传输，提供与tls/ssl相当的安全性，可以将quic看做udp的升级版，
连接建立：http/2.0需要经过经典的tcp三次握手（由于安全的https连接建立需要tls握手共需要大约3个rtt）；quic在最佳情况下 不需要任何往返时间就可以建立新连接
队头阻塞：http/2.0多请求复用一个tcp连接，一旦发生丢包，就会阻塞住所有的http请求，http/3.0在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包，其他数据流不受影响
错误恢复：http/3.0有更好的错误恢复机制。http/2.0更需要依赖tcp的错误恢复机制
安全性：http/2.0和http/3.0在安全性上有较高要求，支持加密通信，但实现不同；http/2.0使用tls加密，http/3.0基于quic协议，包含了内置的加密和身份验证机制；

### http是不保存状态的协议，如何保存用户状态
http是一种不保存状态，即无状态协议，也就是说http协议自身不对请求和响应之间的通信状态进行保存。
那么我们如何保存用户状态呢？
Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

### Cookie 被禁用怎么办?
最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。

### uri和url的区别
uri是同一资源标识符，可以唯一标识一个资源
url是统一资源定位符，可以提供该资源的路径，即url可以用来标识一个资源，而且指明了如何locate这个资源

uri的作用像身份证，url像家庭住址，url是具体的uri

### cookie和session区别

### get和post区别
语义：get用于获取或查询资源，post用于创建或修改资源
幂等：get请求是幂等的，即多次重复执行不会改变资源状态，post请求是不幂等的，即每次请求可能会产生不同的结果或影响资源的状态
格式：get请求的参数通常放在url中，形成查询字符串，post请求的参数通常放在请求体中，可以有多种编码格式，如application/x-www-form-urlencoded;get请求的url长度受浏览器和服务器的限制
缓存：因为get请求是幂等的，它可以被浏览器或其他中间节点缓存起来，以提高性能和效率；post请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应
安全性：get请求和post请求如果需要使用http协议的话，都是不安全的，因为http协议本身是明文传输的，必须使用https协议来加密传输数据，另外get请求比post请求更容易泄漏敏感数据，所以get请求的参数通常放在url中

### ping命令的作用
常用来检测网络中主机之间的连通性和网络延迟

ping命令的输出结果
icmp请求报文信息：序列号、ttl值
目标主机的域名或ip：输出结果的第一行
往返时间rtt：从发送icmp请求报文到接收到icmp响应报文的总时间
统计结果：包括发送的icmp请求数据包数量、接收到的icmp响应数据包数量、丢包率、rtt的最小、平均、最大、标准偏差值


### ping命令的工作原理
ping基于网络层的icmp（互联网控制报文协议），其主要原理是通过再网络上发送和接收icmp报文实现的
icmp报文包含了类型字段，分为查询报文类型（向目标主机发送请求并期望得到响应）、差错报文类型（向源主机发送错误信息，用于报告网络中的错误情况）
### dns的作用
dns域名管理系统，主要解决的是域名和IP地址的映射问题
1、域名请求2、返回源站服务器ip地址3、访问源站服务器 
目前dns的设计采用的是分布式、层次数据库结构，dns是应用层协议，它可以再udp或tcp协议之上运行，端口53
### dns服务器有哪些
dns服务器自底向上可以分为以下几个层级
根dns服务器：
顶级域dns服务器
权威dns服务器
本地dns服务器

### tcp与udp的区别
                tcp     udp
是否面向连接：   是      否
是否是可靠传输： 是      否  
是否有状态：    是      否
传输效率：      较慢      较快
传输形式：      字节流      数据报文段
首部开销：      20~60byte      8byte
是否提供广播或多播服务： 否      是

udp在传输数据前不需要先建立连接，tcp提供面向连接的服务，在传送数据前必须先建立连接，数据传送结束后要释放连接
远地主机接收到udp报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否按时到达，tcp在传输数据之前，会有三次握手来确立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制
tcp只支持点对点通信，udp支持一对一，一对多，多对多，多对一


### tcp和udp的选择
udp一般永远高于即时通信；tcp要求对传输准确性要求特别高的场景，比如文件传输

http/2中存在的队头阻塞问题：多个http请求和响应共享一个tcp连接，如果其中一个请求或响应因为网络阻塞或丢包而被阻塞，那么后续的请求和响应也无法发送，导致整个连接的效率降低。http/3在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包，其他数据流不受影响

在http/2中，如果要建立一个安全的https连接，需要经过tcp三次握手和tls握手
tcp三次握手：客户端和服务器交换syn和ack包，建立一个tcp连接，这个过程需要1.5个rtt，即一个数据包从发送到接收的时间
tls握手：客户端和服务器交换密钥和证书，建立一个tls加密层，这个过程至少需要1个rtt（tls1.3）或2个rtt（tls1.2）
所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。

### 运行在tcp上的协议
http、https、ftp、smtp、pop3/imap、telent、ssh

### 运行在udp上的协议
dhcp协议：动态主机配置协议，动态配置ip地址
dns域名系统：将人类可读的域名转换为机器可读的ip地址，dns同时支持udp和tcp协议

### ip协议的作用
ip（网际协议）属于网络层协议，主要作用是定义数据包的格式，对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地

### 什么是ip地址？ip寻址如何工作
每个连入互联网的设备或域都被分配一个ip地址，作为唯一标识符。每个ip地址都是一个字符序列

当网络设备发送ip数据包时，数据包中包含了源ip地址和目的ip地址，源ip地址用于标识数据包的发送方设备或域，目的ip地址用于标识数据包的接收放设备或域

网络设备根据目的ip地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现设备间的通信

这种基于ip地址的寻址方式时互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现全球范围的网络互联

### 什么时ip地址过滤
ip地址过滤就是限制或阻止ip地址或ip地址范围的访问，比如一个图片服务被一个ip地址攻击，就可以禁止这个ip地址访问图片服务

### nat的作用
nat（网络地址转换）主要用于在不同网络之间转换ip地址，它允许将私有ip地址（如在局域网中使用的ip）映射为公有ip地址（在互联网中使用的ip）或者反向映射，从而实现局域网内的多个设备通过单一公有ip地址访问互联网

nat不仅缓解ipv4地址资源短缺问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络的设备。

### 什么是mac地址
mac地址的全称是媒体访问控制地址，可以理解为mac地址是一个网络设备真正的身份证号，ip地址只是一种不重复的定位方式（比如某省份的张三，这种逻辑定位是ip地址，他的身份证号才是mac地址 ），也可以理解为IP地址是邮政地址，mac地址也叫lan地址、物理地址、以太网地址

不仅网络资源有ip地址，网络设备也有ip地址。从结构上说路由器等网络设备的作用是组成一个网络；内网的设备在与内网以外的设备进行通信时，需要用到nat协议

mac地址具有可携带性、永久性 ，无论到哪里都不会变；当一台设备换了网络，他的ip地址也就可能发生改变

mac特殊地址 FF-FF-FF-FF（全1地址），该地址表示广播地址

### arp协议解决了什么问题
arp，全称地址解析协议，解决了网络层地址和链路层地址之间的转换问题，因为一个ip数据报在物理上传输的过程中，总需要知道下一跳（物理上的下一个目的地址）该网何处，但ip地址属于逻辑地址，mac地址属于物理地址，arp协议解决了ip地址转mac地址的问题

## osi和tcp/ip网络分层模型详解
### osi七层
应用层：为计算机用户提供服务
表示层：数据处理（编解码、加密解密、压缩解压缩）
会话层：管理（建立、维护、重连）
传输层：为两台主机进程之间的通信提供通用的数据传输服务
网络层：路由和寻址（决定数据在网络中的游走路径）
数据链路层：帧编码和误差纠正机制
物理层：透明地传送比特流

### tcp/ip
我们并不能将osi七层模型和tcp/ip四层模型精确的对应起来，但是可以简单的对应
#### 应用层
应用层位于传输层之上，主要提供两个设备终端上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。我们把应用层交互的数据单元称为报文

#### 传输层
传输层主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。‘通用的’是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务

#### 网络层
网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在tcp/ip体系结构中，由于网络层使用ip协议，因此分组也叫ip数据报，简称数据报。

网络层还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机

互联网是由大量的异构网络通过路由器相互连接起来的，互联网使用的网络层协议是无连接的网际协议和许多路由选择协议，因此互联网的网络层也叫网际层


#### 网络接口层
我们把网络接口层看作数据链路层和物理层的合体

数据链路层的作用是把网络层交下来的ip数据报组装成帧，在两个相邻节点间的链路上传送
帧，每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制）

物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异

### tcp三次握手和四次挥手
为了准确无误的把数据送到目标处，tcp协议采用了三次握手策略

建立一个tcp连接需要“三次握手”，缺一不可：
一次握手：客户端发送带有syn（seq=x）的数据包->服务端，然后客户端进入syn_send的状态，等待服务器的确认
二次握手:服务端发送带有syn+ack（seq=y，ack=x+1）标志的数据报->客户端，然后服务端进入syn_recv状态
三次握手：客户端发送带有ack（ack=y+1）标志的数据包->服务端，然后客户端和服务端都进入established状态，完成tcp三次握手
当建立了3次握手之后，客户端和服务端就可以传输数据了

#### 为什么要三次握手