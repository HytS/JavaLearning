




























































# hello-algo
## 复杂度
## 数据结构
### 数据结构分类
#### 逻辑结构：线性与非线性
逻辑结构解释了数据元素之间的逻辑关系
线性数据结构：链表、栈、队列、哈希表、数组
非线性数据结构：树、图、堆
非线性数据结构可以进一步被分为树形结构和网状结构

#### 物理结构：连续和分散
物理结构反映了数据在计算机内存中的存储方式  ，可分为连续存储和分散存储
所有数据结构都是基于数组和链表或二者组合而成的；基于数组实现的数据结构被称为静态数据结构；基于链表实现的数据结构被称为动态数据结构

#### 基本数据类型
数据结构是在计算机中组织和存储数据的方式
#### 数字编码
整数在计算机中以补码存储。在补码的表示下，计算机对加法和减法一视同仁

## 数组和链表
### 数组
#### 初始化数组
```
//存储在栈上
int nums[5] {1,2,3,4,5}
//存储在堆上，需要手动释放空间
int* nums=new int[5]{1,2,3,4,5}
```
### 小结
#### 为什么哈希表同时包含线性数据结构和非线性数据结构
哈希表底层是数组，为了解决哈希冲突，可能会使用链式地址。在拉链法中，数组中的每个地址指向一个链表，当链表的长度超过一定阈值时，又可能被转化成树，所以哈希表可能同时包含线性数据结构和非线性数据结构
#### char类型的长度是1byte吗
char类型的数据长度由编程语言的编码方法决定，java（utf-16）的char是2byte
### 链表
#### 初始化链表
初始化各节点对象，构建引用关系
插入节点
访问节点
删除节点：只需改变一个节点的引用就好
查找
### 列表 
list表示元素的有序集合
#### 初始化列表
vector<int> nums1;//无初始值
vector<int> nums={1,2,3,4,5}//有初始值
#### 访问元素
列表本质上是数组，可以在O（1）的时间里访问和更新元素
#### 小结

## 栈与队列
### 栈
#### 基于链表的实现 
使用链表实现栈时，可以将头节点看作栈顶，将尾节点看作栈底
#### 基于数组的实现
使用数组实现栈时，可以将数组的尾部作为栈顶
#### 栈典型应用
浏览器中的后退与前进、软件中的撤销和反撤销
程序内存管理
### 队列
#### 队列实现
##### 基于链表的实现
可以将链表的头节点和尾节点看作队首和队尾，规定队尾仅可插入节点，队头仅可删除节点
##### 基于数组的实现
数组删除元素时间复杂度为O(n),出队效率低
可以使用front指向队首元素的索引，维护一个size它用于记录队列长度，rear=front+size，得出rear指向队尾元素的下一个位置，基于此设计，数组中包含元素的有效区间是[front,rear-1]
* 入队操作：将输入元素赋值给rear索引处，size+1
* 出队操作： 将front+1，size-1
##### 队列典型应用
* 淘宝订单
* 各类待办事项
### 双向队列
允许在头部和尾部增删节点    
#### 双向队列实现
基于双向链表的实现
将双向链表的头节点对应队头，尾节点对应队尾
基于数组的实现
使用环形数组实现双向队列
### 小结
## 哈希表
### 哈希表
又叫散列表，通过建立key与value之间的映射，实现高效的元素查询。输入一个key，可以在O(1)时间内找到value
哈希表中进行增删改查的时杂都是O(1)
#### 哈希表常用操作
初始化、查询操作、添加键值对和删除键值对
##### 初始化
* Map<Integer,String> map=new HashMap();
##### 遍历
三种常用的遍历方式：遍历键值对、遍历键、遍历值
#### 哈希表简单实现
最简单的情况，使用数组实现哈希表。在哈希表中，数组中的每个空位称为桶（bucket），每个桶可以存储一个键值对，因此，查询操作就是找到key对应的桶，并在桶中获取value
通过hash函数可以基于key定位对应的桶，哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间

哈希函数的计算过程
1、通过某种哈希算法计算得到哈希值
2、将哈希值对桶数量（数组长度）capacity取模，从而获得key对应的数组索引index
然后，利用index在哈希表中访问对应的桶，从而获取value
#### 哈希冲突和扩容
哈希函数的作用是将所有key组成的输入空间全部映射到数组所有索引构成的输出空间。而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况。

哈希表容量n越大，多个key被分配到同一个桶的概率就低，冲突就越少。可以通过扩容哈希表来减少哈希冲突

哈希表扩容需要将所有键值对从原哈希表迁移到新哈希表，非常耗时

### 哈希冲突
### 哈希算法
### 小结


