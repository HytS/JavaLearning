songshupi\shanshipi\helipi

### 行级锁的使用有什么注意事项
InnoDB的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行delete、update语句时，如果where条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。
不过很多时候即使使用了索引也有可能会走全表扫描，这是mysql优化器的原因

### InnoDB有哪几类锁
InnoDB行锁是通过对索引数据页上的记录加锁实现的，mysql InnoDB支持三种行锁定方式：
* 记录所：属于单个行记录上的锁
* 间隙锁：锁定一个范围，不包括记录本身
* 临键锁：record lock+gap lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录所只能锁住已经存在的记录，为了避免插入新纪录，需要依赖间隙锁

在InnoDB默认的隔离级别repeatable-read下，行锁默认使用的是next-key lock。但是，如果操作的索引是唯一索引或主键，InnoDB会对next-key lock进行优化，将其降级为record lock，即仅锁住索引本身，而不是范围。


### 共享锁和排他锁
不论是表级锁还是行级锁，都存在共享锁（s锁）和排他锁（x锁）这两类：
排他锁和任何锁都不兼容；共享锁仅和共享锁兼容
由于MVCC的存在，对于一般的select语句，InnoDB不会加任何锁，可以通过下面的语句显示加共享锁或排他锁
```
# 共享锁 可以在5.7和8.0中使用
select ... lock in share mode;
# 共享锁 可以在8.0中使用
select ... for share
# 排他锁
select ... for update
```

### 意向锁有什么用
如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行的遍历性能太差，我们需要用到一个叫意向锁的东西来快速判断是否可以对某个表使用表锁
意向锁是表级锁，共有两种：
* 意向共享锁（is锁）：事务有意向对表中某些记录加共享锁，加共享锁前必须获得该表的is锁
* 意向排他锁（ix锁）：事务有意向对表中的某些记录加排他锁，加排他锁前必须获得该表的ix锁

意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁
意向锁之间是互相兼容的
意向锁和共享锁和排他锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）

### 当前度和快照读有什么区别
快照读（一致性非锁定读）就是单纯的select语句，但不包括下面的这两类select语句
```
select ... for update
select ... lock in share mode
select ... for share
```
快照即记录的历史版本，每行记录可能存在多个历史版本
快照读的情况下，如果读取的记录正在执行update/delete操作，读取操作不会因此去等待记录上x锁的释放，而是会去读取行的一个快照
只有在事务隔离级别rc（读取已提交）和rr（可重复读）下，InnoDB才会使用一致性非锁定读：
* 在rc级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据
* 在rr级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本

快照读比较适合数据一致性要求不是特别高且追求机制性能的业务场景

当前读（一致性锁定读）就是给行记录加x锁或s锁
当前读的一些常见sql语句如下：
```
# 对读的记录加一个x锁
select ... for update
# 对读的记录加一个s锁
select ... lock in share mode
# 对读的记录加一个s锁
select ... for share
# 对修改的记录加一个x锁
insert ...
update ...
```

### 自增锁（了解即可）
关系型数据库设计表的时候，通常会由一列作为自增主键。InnoDB中的自增主键会涉及一种比较特殊的表级锁-自增锁
```
CREATE TABLE `sequence_id` (
  `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `stub` CHAR(10) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `stub` (`stub`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
不仅仅是自增主键，auto_increment的列都会涉及到自增锁，毕竟非主键也可以设置自增长

如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能被阻塞住，这里的阻塞行为只是自增锁行为的一种，可以理解为自增锁就是一个接口，其具体实现有多种，具体的配置项为innodb_autoinc_lock_mode(5.1.22引入)，可以选择的值如下：
|innodb_autoinc_lock_mode|介绍|
|:----:|:----:|
|0|传统模式|
|1|连续模式(8.0之前默认)|
|2|交错模式(8.0之后默认)|

交错模式下，所有的insert-like语句（所有的插入语句，包括：insert、replace、insert..select）都不是表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行

如果你的mysql数据库有主从同步需求并且Binlog存储格式为statement的话，不要将InnoDB自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序无法得到保障
如果mysql采用的格式是statement，那么mysql的主从同步实际上同步的就是一条一条的sql语句

## mysql性能优化
mysql高性能优化规范

### 能使用mysql直接存储文件吗？
可以，直接存储文件对应的二进制数据即可；不建议在数据库中存储文件，会严重影响数据库性能。
可以选择使用云服务厂商提供的开箱即用的文件存储服务；也可以选择自建文件存储服务
数据库只存储文件地址信息，文件由文件存储服务负责存储

### mysql如何存储ip地址？
可以将ip地址转换成整形数据存储，性能更好，占用空间更小
mysql提供两种方法处理ip地址
* inet_aton()：把ip转为无符号整型（4-8位）
* inet_ntoa()：把整型的ip转为地址

插入数据前，先用inet_aton()转换为整型，显示数据时，使用inet_ntoa()把整型的ip转为地址显示即可

### sql优化手段


### 如何分析sql性能
我们可以使用explain命令来分析sql的执行计划。执行计划是指一条sql语句在经过mysql查询优化器的优化后，具体的执行方式
explain并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找到最优的查询方案，并显示对应的信息
explain适用于select、delete、update、insert、replace语句；


# mysql索引详解
## 索引介绍
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构
索引底层数据结构存在很多类型，常见的索引结构有：b树，b+树和hash、红黑树。在mysql中，无论是innodb还是myisam，都是用b+树作为索引结构

## 索引的优缺点
### 优点
* 使用索引可以加快数据的检索速度
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
### 缺点
* 创建索引和维护索引需要耗费很多时间，当对表中的数据进行删改时，如果数据有索引，那么索引也需要动态修改，会降低sql执行效率
* 索引需要使用物理文件存储，会耗费一定空间

### 使用索引一定能提高性能吗
大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也带不来很大提升

## 索引底层数据结构选型
### Hash表
哈希表是键值对的集合，通过键即可快速取出对应的值，因此哈希表可以快速检索数据
为什么能够通过key快速取出value呢，原因在于哈希算法（散列算法）。通过哈希算法，可以快速找到key对应的index，找到了index也就找到了对应的value。

但是，哈希算法有个哈希冲突问题，就是说多个不同的key最后得到的index相同，通常情况下，我们的解决办法就是链地址法。链地址法就是将哈希冲突数据存放在链表中。

为了减少哈希冲突的发生，一个好的哈希函数应该均匀娥将数据分布在整个可能的哈希值中

innoDB引擎不直接支持常规的哈希索引，但是，innoDB存储引擎中存在一种特殊的自适应哈希索引，自适应哈希索引不是传统的哈希索引，而是结合了b+树和哈希索引的特点，以便更好的适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上就是一个小型的b+树结构，这个b+树结构可以存储多个键值对，而不仅仅是一个键，这有助于减少哈希冲突链的长度，提高索引的效率

#### 为什么mysql没有使用哈希表作为索引的数据结果
hash索引不支持顺序和范围查询，