songshupi\shanshipi\helipi

### 行级锁的使用有什么注意事项
InnoDB的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行delete、update语句时，如果where条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。
不过很多时候即使使用了索引也有可能会走全表扫描，这是mysql优化器的原因

### InnoDB有哪几类锁
InnoDB行锁是通过对索引数据页上的记录加锁实现的，mysql InnoDB支持三种行锁定方式：
* 记录所：属于单个行记录上的锁
* 间隙锁：锁定一个范围，不包括记录本身
* 临键锁：record lock+gap lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录所只能锁住已经存在的记录，为了避免插入新纪录，需要依赖间隙锁

在InnoDB默认的隔离级别repeatable-read下，行锁默认使用的是next-key lock。但是，如果操作的索引是唯一索引或主键，InnoDB会对next-key lock进行优化，将其降级为record lock，即仅锁住索引本身，而不是范围。


### 共享锁和排他锁
不论是表级锁还是行级锁，都存在共享锁（s锁）和排他锁（x锁）这两类：
排他锁和任何锁都不兼容；共享锁仅和共享锁兼容
由于MVCC的存在，对于一般的select语句，InnoDB不会加任何锁，可以通过下面的语句显示加共享锁或排他锁
```
# 共享锁 可以在5.7和8.0中使用
select ... lock in share mode;
# 共享锁 可以在8.0中使用
select ... for share
# 排他锁
select ... for update
```

### 意向锁有什么用
如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行的遍历性能太差，我们需要用到一个叫意向锁的东西来快速判断是否可以对某个表使用表锁
意向锁是表级锁，共有两种：
* 意向共享锁（is锁）：事务有意向对表中某些记录加共享锁，加共享锁前必须获得该表的is锁
* 意向排他锁（ix锁）：事务有意向对表中的某些记录加排他锁，加排他锁前必须获得该表的ix锁

意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁
意向锁之间是互相兼容的
意向锁和共享锁和排他锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）

### 当前度和快照读有什么区别
快照读（一致性非锁定读）就是单纯的select语句，但不包括下面的这两类select语句
```
select ... for update
select ... lock in share mode
select ... for share
```
快照即记录的历史版本，每行记录可能存在多个历史版本
快照读的情况下，如果读取的记录正在执行update/delete操作，读取操作不会因此去等待记录上x锁的释放，而是会去读取行的一个快照
只有在事务隔离级别rc（读取已提交）和rr（可重复读）下，InnoDB才会使用一致性非锁定读：
* 在rc级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据
* 在rr级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本

快照读比较适合数据一致性要求不是特别高且追求机制性能的业务场景

当前读（一致性锁定读）就是给行记录加x锁或s锁
当前读的一些常见sql语句如下：
```
# 对读的记录加一个x锁
select ... for update
# 对读的记录加一个s锁
select ... lock in share mode
# 对读的记录加一个s锁
select ... for share
# 对修改的记录加一个x锁
insert ...
update ...
```

### 自增锁（了解即可）
关系型数据库设计表的时候，通常会由一列作为自增主键。InnoDB中的自增主键会涉及一种比较特殊的表级锁-自增锁
```
CREATE TABLE `sequence_id` (
  `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `stub` CHAR(10) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `stub` (`stub`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
不仅仅是自增主键，auto_increment的列都会涉及到自增锁，毕竟非主键也可以设置自增长

如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能被阻塞住，这里的阻塞行为只是自增锁行为的一种，可以理解为自增锁就是一个接口，其具体实现有多种，具体的配置项为innodb_autoinc_lock_mode(5.1.22引入)，可以选择的值如下：
|innodb_autoinc_lock_mode|介绍|
|:----:|:----:|
|0|传统模式|
|1|连续模式(8.0之前默认)|
|2|交错模式(8.0之后默认)|

交错模式下，所有的insert-like语句（所有的插入语句，包括：insert、replace、insert..select）都不是表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行

如果你的mysql数据库有主从同步需求并且Binlog存储格式为statement的话，不要将InnoDB自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序无法得到保障
如果mysql采用的格式是statement，那么mysql的主从同步实际上同步的就是一条一条的sql语句