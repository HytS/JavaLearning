## 什么是数据库、数据库管理系统、数据库系统、数据库管理员
数据库：就是信息的集合，或者说数据库是由数据库管理系统管理的数据的集合
数据库管理系统：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库
数据库系统：通常由软件、数据库和数据管理员组成
数据库管理员：负责全面管理和控制数据库系统

## 什么是元组、码、候选码、主码、外码、主属性、非主属性


# MYSQL
## 基础
### 什么是关系数据库
是一种建立在关系模型的基础上的数据库，关系模型表明数据库中所存的数据之间的联系

### 什么是mysql
mysql是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据。mysql默认端口号3306

### mysql字段类型
数值类型:整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、 浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

### 整数类型的unsigned属性有什么用
unsigned属性表示不允许负值的无符号整数。使用unsigned属性可以将正整数的上限提高一倍，因为它不需要存储负值
对于从0开始递增的id列，使用unsigned属性非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的id值可用

### char和varchar的区别是什么
char和varchar是最常用到的字符串类型，区别是char是定长字符串，varchar是变长字符串
char更适合存储长度较短或长度都差不多的字符串，varchar适合存储长度不确定或者差异较大的字符串
char(M)和varchar(M)的M都代表能够保存的字符数的最大值，无论是数字、字母还是中文，都只占一个字符

### varchar(10)和varchar(100)的区别是什么
varchar(100)可以满足更大范围的字符存储需求，varchar(10)存储超过10个字符时，就需要修改表结构
varchar(10)和varchar(100)存储的字符范围不同，但是二者存储相同的字符串，所占用磁盘的存储空间是一样的
varchar(100)会消耗更多的内存，因为varchar类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度

### decimal和float/double的区别
decimal与float的区别：decimal是定点数，float/double是浮点数，decimal可以存储精确的小数值，float/double只能存储近似的小数值
decimal用于存储具有精度要求的小数

### 为什么不推荐使用text和blob
text类似于char和varchar，但可以存储更长文本的字符串，例如博客内容；blon类型主要用于存储二进制大对象，例如照片，音视频文件   
缺点：不能有默认值；在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表；检索效率低；不能直接创建索引，需要指定前缀长度；可能会消耗大量网络和io带宽；可能导致表上的dml操作变慢


### datetime和timestamp的区别
datetime类型没有时区信息，timestamp与时区有关
timestamp只需要使用4个字节的存储空间，但是datetime需要耗费8个字节的存储空间，导致timestamp表示的时间范围更小

### null和''的区别
null代币哎一个不确定的值，就算是两个null，他俩也不一定相等，比如select null = null的结果为false，但是当使用distinct、group by、order by时，null又被认为是相等的
''的长度为0，不占用空间，null需要占用空间
null会影响聚合函数，比如sum、avg、min等聚合函数会忽略null值。count的处理方式取决于参数类型。如果参数是*，则会统计所有的记录数，包括null值；如果参数是某个字段名（count(列名)），则会忽略null值，只统计非空值的个数
查询null值时，必须使用is null或is not null来判断，不能使用>、<之类的比较运算符，而''可以使用这些比较运算符

### Boolean类型如何表示
mysql中没有专门的布尔类型，使用tinyint(1)来表示布尔值，tinyint(1)类型可以用来存储0或1，分别对应false或true


## SQL在mysql中的执行过程
### mysql基础架构分析
连接器：身份认证和权限相关（登陆mysql的时候）
查询缓存:执行查询语句的时候，会先查询缓存（8.0之后移除）
分析器：没有命中缓存的话，sql语句就会经过分析器，分析器需要先看sql语句要做什么，再检查你的sql语句语法是否正确
优化器：按照mysql认为最优的方案去执行
执行器：执行语句，然后从存储引擎返回数据
![图片](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

mysql主要分为server层和存储引擎层：
server层：主要包括连接器、查询缓存、分析器、优化器、执行器等所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图，函数。
存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持innoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog模块，现在最常用的存储引擎是InnoDB，它从5.5开始就被当作默认存储引擎了

#### Server层基本组件介绍
1)连接器
连接器主要和身份认证和权限相关的功能相关，主要负责用户登陆数据库，进行用户的身份认证，包括校验用户密码，权限等操作，如果用户账户密码校验通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都会是依赖此时读到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也不受影响
2)查询缓存（8.0以后移除）
查询缓存主要是用来缓存所执行的select语句以及该语句的结果集。
连接建立后，执行查询语句时，会先查询缓存，mysql会先校验这个sql语句是否执行过，以k-v的形式缓存在内存中，k是查询语句，v是结果集。如果缓存k被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件

mysql查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会很频繁，假如对一个表更新的话，这个表上的所有查询缓存都会被清空；所以大多数情况下，不推荐使用查询缓存
3)分析器
mysql没有命中缓存，就会进入分析器，分析器主要分析sql用来干嘛
第一步：词法分析，首先提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。
第二步：语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。
4)优化器
优化器的作用就是它认为的最优的执行方案去执行(有时候可能不是最佳方案)，比如多个索引时如何选择索引，多表查询时如何选择关联顺序；经过优化器之后之歌语句具体该如何执行就已经定下来了
5)执行器
当选择了执行方案，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限就会返回错误信息，如果有权限，就会调用引擎的接口，返回接口执行的结果

### 语句分析
#### 查询语句
sql语句执行流程
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
* 先检查该语句是否有权限，如果没有权限直接返回错误信息，如果有权限，在8.0之前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有执行下一步
* 通过分析器进行词法分析，提取sql语句关键元素，然后判断这个sql语句是否有语法错误，如果检查没问题就进入下一步
* 优化器根据自己的优化算法进行选择执行效率最好的一个方案
* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果

#### 更新语句
update tb_student A set A.age='19' where A.name=' 张三 ';
我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

* 先查询到张三这一条数据，如果有缓存，也会用到缓存
* 然后拿到查询语句，把age改为19，然后调用引擎api接口，写入这一行数据，innoDB引擎把数据保存到内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成，随时可以提交
* 执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态
* 更新完成

> 这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?

这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？
* 先写redo log直接提交，然后写binlog，假设写完redo log后，机器挂了，binlog日志没有写入，那么机器重启后，会通过redo log恢复数据，但是这个时候的binlog并没有记录该数据，后续进行数备份的时候，就会丢失这条数据，同时主从同步也会丢失这一条数据
* 先写binlog，然后写redo log，假设写完binlog，机器异常重启了，由于没有redo log，本机无法恢复数据，但是binlog又有记录，那么和上面同样的道理，就会产生数据不一致的情况

如果采用redo log两阶段提交的方式就不一样了，写完binlog后，然后在提交redo log就会防止上述的问题，从而保证数据的一致性。

如果redo log处于预提交状态，binlog也写完了，这时发生异常重启会怎么样？
这就要依赖mysql的处理机制了，处理过程如下：
* 判断redo log是否完整，如果判断是完整的，就立即提交
* 如果redo log只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交redo log，不完整就回滚事务

查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)

