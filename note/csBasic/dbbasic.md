## 什么是数据库、数据库管理系统、数据库系统、数据库管理员
数据库：就是信息的集合，或者说数据库是由数据库管理系统管理的数据的集合
数据库管理系统：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库
数据库系统：通常由软件、数据库和数据管理员组成
数据库管理员：负责全面管理和控制数据库系统

## 什么是元组、码、候选码、主码、外码、主属性、非主属性


# MYSQL
## 基础
### 什么是关系数据库
是一种建立在关系模型的基础上的数据库，关系模型表明数据库中所存的数据之间的联系

### 什么是mysql
mysql是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据。mysql默认端口号3306

### mysql字段类型
数值类型:整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、 浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

### 整数类型的unsigned属性有什么用
unsigned属性表示不允许负值的无符号整数。使用unsigned属性可以将正整数的上限提高一倍，因为它不需要存储负值
对于从0开始递增的id列，使用unsigned属性非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的id值可用

### char和varchar的区别是什么
char和varchar是最常用到的字符串类型，区别是char是定长字符串，varchar是变长字符串
char更适合存储长度较短或长度都差不多的字符串，varchar适合存储长度不确定或者差异较大的字符串
char(M)和varchar(M)的M都代表能够保存的字符数的最大值，无论是数字、字母还是中文，都只占一个字符

### varchar(10)和varchar(100)的区别是什么
varchar(100)可以满足更大范围的字符存储需求，varchar(10)存储超过10个字符时，就需要修改表结构
varchar(10)和varchar(100)存储的字符范围不同，但是二者存储相同的字符串，所占用磁盘的存储空间是一样的
varchar(100)会消耗更多的内存，因为varchar类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度

### decimal和float/double的区别
decimal与float的区别：decimal是定点数，float/double是浮点数，decimal可以存储精确的小数值，float/double只能存储近似的小数值
decimal用于存储具有精度要求的小数

### 为什么不推荐使用text和blob
text类似于char和varchar，但可以存储更长文本的字符串，例如博客内容；blon类型主要用于存储二进制大对象，例如照片，音视频文件   
缺点：不能有默认值；在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表；检索效率低；不能直接创建索引，需要指定前缀长度；可能会消耗大量网络和io带宽；可能导致表上的dml操作变慢


### datetime和timestamp的区别
datetime类型没有时区信息，timestamp与时区有关
timestamp只需要使用4个字节的存储空间，但是datetime需要耗费8个字节的存储空间，导致timestamp表示的时间范围更小

### null和''的区别
null代币哎一个不确定的值，就算是两个null，他俩也不一定相等，比如select null = null的结果为false，但是当使用distinct、group by、order by时，null又被认为是相等的
''的长度为0，不占用空间，null需要占用空间
null会影响聚合函数，比如sum、avg、min等聚合函数会忽略null值。count的处理方式取决于参数类型。如果参数是*，则会统计所有的记录数，包括null值；如果参数是某个字段名（count(列名)），则会忽略null值，只统计非空值的个数
查询null值时，必须使用is null或is not null来判断，不能使用>、<之类的比较运算符，而''可以使用这些比较运算符

### Boolean类型如何表示
mysql中没有专门的布尔类型，使用tinyint(1)来表示布尔值，tinyint(1)类型可以用来存储0或1，分别对应false或true


## SQL在mysql中的执行过程
### mysql基础架构分析
连接器：身份认证和权限相关（登陆mysql的时候）
查询缓存:执行查询语句的时候，会先查询缓存（8.0之后移除）
分析器：没有命中缓存的话，sql语句就会经过分析器，分析器需要先看sql语句要做什么，再检查你的sql语句语法是否正确
优化器：按照mysql认为最优的方案去执行
执行器：执行语句，然后从存储引擎返回数据。执行语句前会先判断是否有权限，如果美哟权限就会报错
插件式存储引擎：主要负责数据的存储与读取，采用的是插件式架构，支持InnoDB、MyISAM、Memory 等多种存储引擎
![图片](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

mysql主要分为server层和存储引擎层：
server层：主要包括连接器、查询缓存、分析器、优化器、执行器等所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图，函数。
存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持innoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog模块，现在最常用的存储引擎是InnoDB，它从5.5开始就被当作默认存储引擎了

#### Server层基本组件介绍
1)连接器
连接器主要和身份认证和权限相关的功能相关，主要负责用户登陆数据库，进行用户的身份认证，包括校验用户密码，权限等操作，如果用户账户密码校验通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都会是依赖此时读到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也不受影响
2)查询缓存（8.0以后移除）
查询缓存主要是用来缓存所执行的select语句以及该语句的结果集。
连接建立后，执行查询语句时，会先查询缓存，mysql会先校验这个sql语句是否执行过，以k-v的形式缓存在内存中，k是查询语句，v是结果集。如果缓存k被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件

mysql查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会很频繁，假如对一个表更新的话，这个表上的所有查询缓存都会被清空；所以大多数情况下，不推荐使用查询缓存
3)分析器
mysql没有命中缓存，就会进入分析器，分析器主要分析sql用来干嘛
第一步：词法分析，首先提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。
第二步：语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。
4)优化器
优化器的作用就是它认为的最优的执行方案去执行(有时候可能不是最佳方案)，比如多个索引时如何选择索引，多表查询时如何选择关联顺序；经过优化器之后之歌语句具体该如何执行就已经定下来了
5)执行器
当选择了执行方案，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限就会返回错误信息，如果有权限，就会调用引擎的接口，返回接口执行的结果

### 语句分析
#### 查询语句
sql语句执行流程
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
* 先检查该语句是否有权限，如果没有权限直接返回错误信息，如果有权限，在8.0之前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有执行下一步
* 通过分析器进行词法分析，提取sql语句关键元素，然后判断这个sql语句是否有语法错误，如果检查没问题就进入下一步
* 优化器根据自己的优化算法进行选择执行效率最好的一个方案
* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果

#### 更新语句
update tb_student A set A.age='19' where A.name=' 张三 ';
我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

* 先查询到张三这一条数据，如果有缓存，也会用到缓存
* 然后拿到查询语句，把age改为19，然后调用引擎api接口，写入这一行数据，innoDB引擎把数据保存到内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成，随时可以提交
* 执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态
* 更新完成

> 这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?

这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？
* 先写redo log直接提交，然后写binlog，假设写完redo log后，机器挂了，binlog日志没有写入，那么机器重启后，会通过redo log恢复数据，但是这个时候的binlog并没有记录该数据，后续进行数备份的时候，就会丢失这条数据，同时主从同步也会丢失这一条数据
* 先写binlog，然后写redo log，假设写完binlog，机器异常重启了，由于没有redo log，本机无法恢复数据，但是binlog又有记录，那么和上面同样的道理，就会产生数据不一致的情况

如果采用redo log两阶段提交的方式就不一样了，写完binlog后，然后在提交redo log就会防止上述的问题，从而保证数据的一致性。

如果redo log处于预提交状态，binlog也写完了，这时发生异常重启会怎么样？
这就要依赖mysql的处理机制了，处理过程如下：
* 判断redo log是否完整，如果判断是完整的，就立即提交
* 如果redo log只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交redo log，不完整就回滚事务

查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)


### Mysql存储引擎
#### mysql支持哪个存储引擎？默认使用哪个？
mysql支持多种存储引擎，可以使用show engines命令查看mysql支持的存储引擎；mysql当前默认引擎是innoDB，并且所有存储引擎中只有innoDB是事务性存储引擎，即只有innoDB支持事务；5.5.5之前，MyISAM是默认存储引擎，5.5.5之后，InnoDB是默认存储引擎

#### Mysql存储引擎架构
mysql存储引擎采用的是插件式架构，支持多种存储引擎，我们可以为不同的数据表设置不同的存储引擎以适应不同场景的需要；存储式引擎是基于表的，不是数据库

可以根据mysql定义的存储引擎实现标准接口来编写一个属于自己的存储引擎

#### MyISAM和InnoDB有什么区别
MyISAM不支持事务和行级锁，最大的缺陷是崩溃后无法安全恢复
1、是否支持行级锁
MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁；即MyISAM一锁就是锁住了整张表，这在并发写的情况下很糟糕
2、是否支持事务
MyISAM不提供事务支持；InnoDB提供事务支持，实现了sql标准定义了四个隔离级别，具有提交和回滚事务的能力，InnoDB默认使用的repeatable-read（可重读）隔离级别是可以解决幻读问题的发生的
3、是否支持外键
MyISAM不支持，InnoDB支持
外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此，通常不建议在生产项目中使用外键，在业务代码中进行约束即可
注：不得使用外键与级联，一切外键概念必须在应用层解决
学生表中的student_id是主键，那么成绩表中的student_id则为外键，如果更新学生表中的student_id,同时触发成绩表中的student_id更新，即为级联更新，外键和级联更新更适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

4、是否支持数据库异常崩溃后的安全恢复
MyISAM不支持，InnoDB支持

5、是否支持MVCC
MyISAM不支持，InnoDB支持
MyISAM连行级锁都不支持，MVCC可以看作行级锁的升级，可以有效减少加锁操作

6、索引实现不一样
MyISAM引擎和InnoDB引擎都是使用B+tree作为索引结构，但是两者的实现方式不太一样
InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照B+tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录
7、性能有差别
InnoDB性能比MyISAM更强，不管是在读写混合模式还是只读模式下，随着cpu核数的增加，InnoDB的读写能力线性增长

#### MyISAM和InnoDB如何选择
大多数情况，选择InnoDB存储引擎，在某些读密集的情况下，使用MyISAM也合适
《mysql高性能》中有一句话：不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论不绝对，在聚簇索引中，InnoDB速度快于MyISAM
一般情况下选择InnoDB没有问题，但是某些情况下你可能并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也不错

## mysql查询缓存
执行查询语句的时候会先查询缓存，但是在8.0之后移除；开启查询缓存后再同样的查询条件以及数据情况下，会直接在缓存中返回结果，
查询缓存不命中的情况：
1.任何两个查询在任何字符上的不同都会导致缓存不命中
2.如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql中的系统表，其查询结果也不会被缓存
3.缓存建立后，mysql的查询缓存系统会跟踪设计的每张表，如果这些表发生变化，那么和这张表相关的所有缓存数据都将失效

缓存虽然能提升数据库的查询性能，但是缓存同时也带来了额外开销，每次查询后都要做一次缓存操作，失效后还要销毁，因此，开启查询缓存要谨慎，尤其对于写密集的应用更是如此。如果开启，要注意控制缓存空间大小
## mysql日志
### 什么是事务
事务是逻辑上的一组操作，要么都执行，要么都不执行
事务案例：假如小明给小红转1000元，这个转账涉及到两个关键操作，这两个操作必须都成功或者都失败
1.将小明的余额减少1000
2.将小红的余额增加1000
事务会把这两个操作看作一个逻辑上的整体，这个整体要包含的操作要么都成功，要么都失败，这样就不会出现小明余额减少而小红的余额没有增加的情况了

### 什么是数据库事务
大多数情况，在谈论事务的时候，如果没有特指分布式事务，往往指的就是数据库事务
如果项目属于单体架构，接触的就是数据库事务
#### 数据库事务有什么作用
数据库事务可以保证多个对数据库的操作（就是sql语句）构成一个逻辑上的整体，购车给逻辑上的整体的这些数据库操作遵循：要么全部执行成功，要么全部不执行
```
# 开启一个事务
start transaction;
## 提交事务
commit;
```
关系型数据库事务都有acid特性；a：原子性；c：一致性；i：隔离性；d：持久性
原子性：事务是最小的执行单位，不允许分割。事务的原子性要保证动作要么全部完成，要么完全不起作用
一致性：执行事务前后，数据保持一致，例如转账业务，无论事务是否成功，收款人与转账人的总额不变
隔离性：并发访问数据库时，一个用户的事务不被其他事务干扰，各并发事务之间数据库是独立的
持久性：一个事务被提交后，它对数据库中数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响
只有保证了事务的持久性、隔离性、原子性，才能保障一致性，也就是说adi是手段，c是目的

### 并发事务带来了那些问题
在典型的应用程序中，多个事务并发允许，经常会操作相同的数据完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题
#### 脏读
一个事务读取数据并对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有被提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据没有同步到数据库，那第二个事务读取到的就是脏数据。
例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。
![图片](https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-ee15b0b9.png)

#### 丢失修改
在一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失
例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
![图片](https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-5b2e2bd8.png)

#### 不可重复读
指在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问了该数据。那么，在第一个事务的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个事务内两次读到的数据是不一样的情况
例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。

#### 幻读
幻读和不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读
例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。

### 不可重复读和幻读的区别
* 不可重复读的重点是内容修改或记录减少比如多次读取一条记录发现其中某些记录的值被修改
* 幻读的重点在于记录新增比如多次执行同一条查询时，发现查到的记录增加了

幻读可以看作不可重复读的一种特殊情况，单独把区分幻读的原因是解决幻读和不可重复读的方案不一样
举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。

### 并发事务的控制方式有那些
mysql中并发事务的控制方式有两种：锁和MVCC。锁可以看作是悲观控制的模式，多版本并发控制（MVCC）可以看作是乐观控制的模式
所控制方式下会通过锁来显示控制共享资源而不是通过调度手段，mysql主要通过读写锁来实现并发控制
* 共享锁(s锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）
* 排他锁(x锁)：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取，如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）

读写锁可以做到读读并行，但是无法做到写读，写写并行。另外，根据锁粒度的不同，又被分为表级锁和行级锁。InnoDB不光支持表级锁，也支持行级锁，默认为行级锁。行级锁的锁粒度更小，仅对相关的记录上锁即可（对一行或多行记录加锁），所以对于并发写入操作来说，InnoDB的性能更高。不论是表级锁还是行级锁，都存在共享锁和排他锁。

MVCC在mysql中实现所依赖的手段主要是：隐藏字段、read view、undo log
* undo log：用于记录某行数据的多个版本的数据
* read view和隐藏字段：用于判断当前版本数据的可见性

### sql标准定义了那些事务隔离级别
sql标准定义了四个隔离级别：
read-uncommitted(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读、幻读
read-committed(读取已提交)：允许读取的并发事务已经提交的数据，可以阻止脏读，但是不可重复读和幻读仍有可能发生
repeatable-read(可重复读)：对同一字段的多次读取结果都是一致的，除非数据本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
serializable(可串行化)：最高的隔离级别，完全服从acid的隔离级别。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，即该级别可以防止幻读、脏读、不可重复读

### mysql的隔离级别是基于锁实现的吗？
mysql的隔离级别基于锁和MVCC机制共同实现的
serializable隔离级别是通过锁实现的，read-committed和repeatable-read隔离级别是基于MVCC实现的。不过，serializable之外的其他隔离级别可能也需要用到锁机制，比如repeatable-read在当前读情况下需要使用加锁读来保证不会出现幻读

### mysql的默认隔离级别是什么？
mysql InnoDB存储引擎的默认支持的隔离级别是repeatable-read级别，可以通过select @@tx_isolation;命令查看，8.0后该命令改为select @@transaction_isolation;

## mysql锁
锁是一种常见的并发事务的控制方式

### 表级锁和行级锁有什么区别
MyISAM仅仅支持表级锁，一锁就是一张表，这在并发写的情况下性能很差，InnoDB不光支持表级锁，也支持行级锁，默认为行级锁
行级锁的粒度更小，进队相关的记录上锁即可，所以对并发写入操作来说，InnoDB的性能更高
#### 表级锁和行级锁对比
* 表级锁：mysql中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM和InnoDB引擎都支持表级锁
* 行级锁：mysql中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的

### 行级锁的使用有什么注意事项
InnoDB的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行delete、update语句时，如果where条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。
不过很多时候即使使用了索引也有可能会走全表扫描，这是mysql优化器的原因

### InnoDB有哪几类锁
InnoDB行锁是通过对索引数据页上的记录加锁实现的，mysql InnoDB支持三种行锁定方式：
* 记录所：属于单个行记录上的锁
* 间隙锁：锁定一个范围，不包括记录本身
* 临键锁：record lock+gap lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录所只能锁住已经存在的记录，为了避免插入新纪录，需要依赖间隙锁

在InnoDB默认的隔离级别repeatable-read下，行锁默认使用的是next-key lock。但是，如果操作的索引是唯一索引或主键，InnoDB会对next-key lock进行优化，将其降级为record lock，即仅锁住索引本身，而不是范围。


### 共享锁和排他锁
不论是表级锁还是行级锁，都存在共享锁（s锁）和排他锁（x锁）这两类：
排他锁和任何锁都不兼容；共享锁仅和共享锁兼容
由于MVCC的存在，对于一般的select语句，InnoDB不会加任何锁，可以通过下面的语句显示加共享锁或排他锁
```
# 共享锁 可以在5.7和8.0中使用
select ... lock in share mode;
# 共享锁 可以在8.0中使用
select ... for share
# 排他锁
select ... for update
```

### 意向锁有什么用
如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行的遍历性能太差，我们需要用到一个叫意向锁的东西来快速判断是否可以对某个表使用表锁
意向锁是表级锁，共有两种：
* 意向共享锁（is锁）：事务有意向对表中某些记录加共享锁，加共享锁前必须获得该表的is锁
* 意向排他锁（ix锁）：事务有意向对表中的某些记录加排他锁，加排他锁前必须获得该表的ix锁

意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁
意向锁之间是互相兼容的
意向锁和共享锁和排他锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）


### 当前度和快照读有什么区别
快照读（一致性非锁定读）就是单纯的select语句，但不包括下面的这两类select语句
```
select ... for update
select ... lock in share mode
select ... for share
```
快照即记录的历史版本，每行记录可能存在多个历史版本
快照读的情况下，如果读取的记录正在执行update/delete操作，读取操作不会因此去等待记录上x锁的释放，而是会去读取行的一个快照
只有在事务隔离级别rc（读取已提交）和rr（可重复读）下，InnoDB才会使用一致性非锁定读：
* 在rc级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据
* 在rr级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本

快照读比较适合数据一致性要求不是特别高且追求机制性能的业务场景

当前读（一致性锁定读）就是给行记录加x锁或s锁
当前读的一些常见sql语句如下：
```
# 对读的记录加一个x锁
select ... for update
# 对读的记录加一个s锁
select ... lock in share mode
# 对读的记录加一个s锁
select ... for share
# 对修改的记录加一个x锁
insert ...
update ...
```


### 自增锁（了解即可）
关系型数据库设计表的时候，通常会由一列作为自增主键。InnoDB中的自增主键会涉及一种比较特殊的表级锁-自增锁
```
CREATE TABLE `sequence_id` (
  `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `stub` CHAR(10) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `stub` (`stub`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
不仅仅是自增主键，auto_increment的列都会涉及到自增锁，毕竟非主键也可以设置自增长

如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能被阻塞住，这里的阻塞行为只是自增锁行为的一种，可以理解为自增锁就是一个接口，其具体实现有多种，具体的配置项为innodb_autoinc_lock_mode(5.1.22引入)，可以选择的值如下：
|innodb_autoinc_lock_mode|介绍|
|:----:|:----:|
|0|传统模式|
|1|连续模式(8.0之前默认)|
|2|交错模式(8.0之后默认)|

交错模式下，所有的insert-like语句（所有的插入语句，包括：insert、replace、insert..select）都不是表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行

如果你的mysql数据库有主从同步需求并且Binlog存储格式为statement的话，不要将InnoDB自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序无法得到保障
如果mysql采用的格式是statement，那么mysql的主从同步实际上同步的就是一条一条的sql语句

## mysql性能优化
mysql高性能优化规范

### 能使用mysql直接存储文件吗？
可以，直接存储文件对应的二进制数据即可；不建议在数据库中存储文件，会严重影响数据库性能。
可以选择使用云服务厂商提供的开箱即用的文件存储服务；也可以选择自建文件存储服务
数据库只存储文件地址信息，文件由文件存储服务负责存储

### mysql如何存储ip地址？
可以将ip地址转换成整形数据存储，性能更好，占用空间更小
mysql提供两种方法处理ip地址
* inet_aton()：把ip转为无符号整型（4-8位）
* inet_ntoa()：把整型的ip转为地址

插入数据前，先用inet_aton()转换为整型，显示数据时，使用inet_ntoa()把整型的ip转为地址显示即可

### sql优化手段

### 如何分析sql性能
我们可以使用explain命令来分析sql的执行计划。执行计划是指一条sql语句在经过mysql查询优化器的优化后，具体的执行方式
explain并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找到最优的查询方案，并显示对应的信息
explain适用于select、delete、update、insert、replace语句；


# mysql索引详解
## 索引介绍
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构
索引底层数据结构存在很多类型，常见的索引结构有：b树，b+树和hash、红黑树。在mysql中，无论是innodb还是myisam，都是用b+树作为索引结构

## 索引的优缺点
### 优点
* 使用索引可以加快数据的检索速度
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
### 缺点
* 创建索引和维护索引需要耗费很多时间，当对表中的数据进行删改时，如果数据有索引，那么索引也需要动态修改，会降低sql执行效率
* 索引需要使用物理文件存储，会耗费一定空间

### 使用索引一定能提高性能吗
大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也带不来很大提升

## 索引底层数据结构选型
### Hash表
哈希表是键值对的集合，通过键即可快速取出对应的值，因此哈希表可以快速检索数据
为什么能够通过key快速取出value呢，原因在于哈希算法（散列算法）。通过哈希算法，可以快速找到key对应的index，找到了index也就找到了对应的value。

但是，哈希算法有个哈希冲突问题，就是说多个不同的key最后得到的index相同，通常情况下，我们的解决办法就是链地址法。链地址法就是将哈希冲突数据存放在链表中。

为了减少哈希冲突的发生，一个好的哈希函数应该均匀娥将数据分布在整个可能的哈希值中

innoDB引擎不直接支持常规的哈希索引，但是，innoDB存储引擎中存在一种特殊的自适应哈希索引，自适应哈希索引不是传统的哈希索引，而是结合了b+树和哈希索引的特点，以便更好的适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上就是一个小型的b+树结构，这个b+树结构可以存储多个键值对，而不仅仅是一个键，这有助于减少哈希冲突链的长度，提高索引的效率

#### 为什么mysql没有使用哈希表作为索引的数据结果
hash索引不支持顺序和范围查询

### 二叉查找树
二叉查找树是一宗基于二叉树的数据结构，具有一下特点：
1.左子树所有节点的值小于根节点的值
2.右子树所有节点的值大于根节点的值
3.左右子树也分别为二叉查找树

当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过1的时候，查询的时间复杂度为O(log2(n)),然而，当二叉查找树不平衡的时候，比如在最坏情况下（有序插入节点），树会退化称线性链表，导致查询效率下降，时间复杂度为O(n)

也就是说，二叉查找树的性能非常依赖它的平衡程度，这就导致其不适合作为mysql底层索引的数据结构


### avl树
avl树是计算机科学中最早发现的自平衡二叉查找树，avl树特点是保证任何节点的左右子树高度差不超过1，因此也被称为高度平衡二叉树。它的查找、插入、删除在平均和最坏情况下的时间复杂度都是O(logn)

avl树采用了旋转操作来保持平衡，主要有四种旋转操作：ll旋转、rr旋转、lr旋转、rl旋转。其中ll旋转和rr旋转分别用于处理左左和右右失衡，而lr旋转和rl旋转用于处理左右平衡和右左平衡

由于avl树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销而降低了查询性能。并且，在使用avl树时，每个树节点仅存储一个数据，而每次进行磁盘io时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘io。磁盘io是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘io操作的次数

### 红黑树
红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行    颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：
* 它的节点非红即黑
* 根节点总是黑色的
* 每个叶子节点都是黑色的空节点（NIL节点）
* 如果节点是红色的，则它的子节点必须是黑色的（反之则不一定）
* 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即想通过的黑色高度）

和avl树不同，红黑树并不追求严格的平衡，而是大致的平衡。所以，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘io操作才能查询到，这也是mysql没有选择红黑树的主要原因。正因如此，红黑树的插入和删除效率提高了，因为红黑树在插入和删除节点时只需进行O(1)次数的旋转和变色操作，即可保持基本平衡状态，不需要像avl树一样进行O(logn)次数的旋转操作

treeMap、treeSet、HashMap底层使用红黑树

### b树、b+树
b树也叫b-树，全称多路平衡查找树，b+树是b树的变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。
目前大部分数据库系统及文件系统都采用b-tree或b+tree作为索引结构

#### b树和b+树有什么区别
* b树的所有节点既存放key也存放data，而b+树只有叶子节点存放key和data，其他节点只存放key
* b树的叶子节点都是独立的；b+树的叶子节点有一条引用链指向与它相邻的叶子节点
* b树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而b+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索就很明显。
* 在b树中进行范围查询时，首先找到查找的下限，然后对b树进行中序遍历，直到找到查找的上限；而b+树的范围查询，只需要对链表进行遍历即可

综上，b+树和b树相比，具备更少的io次数、更稳定的查询效率和更适于范围查找

在mysql中，myisam引擎和innoDB引擎都是使用b+树作为索引结构，但是，二者的实现方式不太一样


myisam引擎中，b+树叶节点的data域放的是数据记录的地址。在索引检索的时候，首先按照b+树搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取响应的数据记录。这被称为非聚簇索引
InnoDB引擎中，其数据文件本身就是索引文件。相比myisam，索引文件和数据文件是分离的，其表数据文件本身就是按b+树组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为聚簇索引，而其他的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和myisam不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁断裂。

## 索引类型总结
按照数据结构维度划分
* btree索引：mysql中默认和最常用的索引类型。只有叶子节点存储value，非叶子节点只有指针和key。存储引擎myisam和innoDB实现btree索引都是使用b+tree，但二者的实现方式不一样
* 哈希索引：类似键值对的形式，一次即可定位
* rtree：一般不会使用，仅支持geometry数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如ElasticSearch替代
* 全文索引：对文本的内容进行分词，进行搜索。目前只有char、varchar、text列上可以创建索引。一般不会使用，效率较低，通常使用搜索引擎如ElasticSearch替代

按照底层存储方式角度划分：
* 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，innoDB中的主键索引就是聚簇索引
* 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就是非聚集索引。mysql的myisam引擎，不管主键还是非主键，使用的都是非聚簇索引


按照应用维度划分：
* 主键索引：加快查询+列值唯一（不可以有null）+表中只有一个
* 普通索引：仅加查询
* 唯一索引：加快查询+列值唯一（可以有null）
* 覆盖索引：一个索引包含（或覆盖）所有需要查询的字段的值
* 联合索引：多列值组成索引，专门用于组合搜索，其效率大于索引合并
* 全文索引：对文本的内容进行分词，进行搜索。目前只有char、varchar、text列上可以创建索引。一般不会使用，效率较低，通常使用搜索引擎如ElasticSearch替代

mysql 8.x中实现的索引新特性：
* 隐藏索引：也称不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏
* 降序索引：之前的版本就支持通过desc来指定索引为降序，但实际上创建的仍然是常规的升序索引
* 函数索引：索引中可以包含函数或者表达式


## 主键索引
数据表的主键列使用的就是主键索引；一张数据表只能有一个主键，并且主键不能为null，不能重复。
在mysql的innoDB的表中，当没有显式的指定表的主键时，innoDB会自动检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则innoDB将会自动创建一个6B的自增主键


## 二级索引
二级索引有称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以确定主键的位置

唯一索引，普通索引，前缀索引等索引属于二级索引

* 唯一索引:唯一索引也是一种约束，唯一索引的属性列不能出现重复数据，但是允许数据为null，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候是为了该属性的数据的唯一性，而不是为了查询效率
* 普通索引：普通索引的唯一作用是为了快速查询数据。一张表允许创建多个普通索引，并允许数据重复和null
* 前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符
* 全文索引：全文索引主要是为了检索大文本数据中关键字的信息，是目前搜索引擎数据库使用的一种技术。5.6前只有myisam支持全文索引，5.6之后innoDB也支持全文索引


## 聚簇索引和非聚簇索引
### 聚簇索引
#### 介绍
聚簇索引就是索引结构和数据一起存放的索引，并不是一种单独的索引类型。innoDB中的主键索引就是聚簇索引
在mysql中，innoDB引擎的表的.ibd文件就包含了该表的索引和数据，对于innoDB引擎表来说，该表的索引（b+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

#### 优缺点
优点：
* 查询速度非常快：聚簇索引查询速度很快，因为整个b+树是一个多叉平衡树，叶子节点也是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的io操作
* 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快
缺点：
* 依赖有序的数据：因为b+树是多叉平衡树，如果索引的数据不是有序的，那么就需要插入时排序，如果数据是整型的还好，否则类似于字符串或uuid这种又长又难比较的数据，插入或查找的速度很慢
* 更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放者数据，修改代价很大，所以对主键索引时，主键一般都是不可更改的


