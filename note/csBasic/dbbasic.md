## 什么是数据库、数据库管理系统、数据库系统、数据库管理员
数据库：就是信息的集合，或者说数据库是由数据库管理系统管理的数据的集合
数据库管理系统：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库
数据库系统：通常由软件、数据库和数据管理员组成
数据库管理员：负责全面管理和控制数据库系统

## 什么是元组、码、候选码、主码、外码、主属性、非主属性


# MYSQL
## 基础
### 什么是关系数据库
是一种建立在关系模型的基础上的数据库，关系模型表明数据库中所存的数据之间的联系

### 什么是mysql
mysql是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据。mysql默认端口号3306

### mysql字段类型
数值类型:整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、 浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

### 整数类型的unsigned属性有什么用
unsigned属性表示不允许负值的无符号整数。使用unsigned属性可以将正整数的上限提高一倍，因为它不需要存储负值
对于从0开始递增的id列，使用unsigned属性非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的id值可用

### char和varchar的区别是什么
char和varchar是最常用到的字符串类型，区别是char是定长字符串，varchar是变长字符串
char更适合存储长度较短或长度都差不多的字符串，varchar适合存储长度不确定或者差异较大的字符串
char(M)和varchar(M)的M都代表能够保存的字符数的最大值，无论是数字、字母还是中文，都只占一个字符

### varchar(10)和varchar(100)的区别是什么
varchar(100)可以满足更大范围的字符存储需求，varchar(10)存储超过10个字符时，就需要修改表结构
varchar(10)和varchar(100)存储的字符范围不同，但是二者存储相同的字符串，所占用磁盘的存储空间是一样的
varchar(100)会消耗更多的内存，因为varchar类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度

### decimal和float/double的区别
decimal与float的区别：decimal是定点数，float/double是浮点数，decimal可以存储精确的小数值，float/double只能存储近似的小数值
decimal用于存储具有精度要求的小数

### 为什么不推荐使用text和blob
text类似于char和varchar，但可以存储更长文本的字符串，例如博客内容；blon类型主要用于存储二进制大对象，例如照片，音视频文件   
缺点：不能有默认值；在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表；检索效率低；不能直接创建索引，需要指定前缀长度；可能会消耗大量网络和io带宽；可能导致表上的dml操作变慢


### datetime和timestamp的区别
datetime类型没有时区信息，timestamp与时区有关
timestamp只需要使用4个字节的存储空间，但是datetime需要耗费8个字节的存储空间，导致timestamp表示的时间范围更小

### null和''的区别
null代币哎一个不确定的值，就算是两个null，他俩也不一定相等，比如select null = null的结果为false，但是当使用distinct、group by、order by时，null又被认为是相等的
''的长度为0，不占用空间，null需要占用空间
null会影响聚合函数，比如sum、avg、min等聚合函数会忽略null值。count的处理方式取决于参数类型。如果参数是*，则会统计所有的记录数，包括null值；如果参数是某个字段名（count(列名)），则会忽略null值，只统计非空值的个数
查询null值时，必须使用is null或is not null来判断，不能使用>、<之类的比较运算符，而''可以使用这些比较运算符

### Boolean类型如何表示
mysql中没有专门的布尔类型，使用tinyint(1)来表示布尔值，tinyint(1)类型可以用来存储0或1，分别对应false或true


## SQL在mysql中的执行过程
### mysql基础架构分析
连接器：身份认证和权限相关（登陆mysql的时候）
查询缓存:执行查询语句的时候，会先查询缓存（8.0之后移除）
分析器：没有命中缓存的话，sql语句就会经过分析器，分析器需要先看sql语句要做什么，再检查你的sql语句语法是否正确
优化器：按照mysql认为最优的方案去执行
执行器：执行语句，然后从存储引擎返回数据。执行语句前会先判断是否有权限，如果美哟权限就会报错
插件式存储引擎：主要负责数据的存储与读取，采用的是插件式架构，支持InnoDB、MyISAM、Memory 等多种存储引擎
![图片](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

mysql主要分为server层和存储引擎层：
server层：主要包括连接器、查询缓存、分析器、优化器、执行器等所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图，函数。
存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持innoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog模块，现在最常用的存储引擎是InnoDB，它从5.5开始就被当作默认存储引擎了

#### Server层基本组件介绍
1)连接器
连接器主要和身份认证和权限相关的功能相关，主要负责用户登陆数据库，进行用户的身份认证，包括校验用户密码，权限等操作，如果用户账户密码校验通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都会是依赖此时读到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也不受影响
2)查询缓存（8.0以后移除）
查询缓存主要是用来缓存所执行的select语句以及该语句的结果集。
连接建立后，执行查询语句时，会先查询缓存，mysql会先校验这个sql语句是否执行过，以k-v的形式缓存在内存中，k是查询语句，v是结果集。如果缓存k被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件

mysql查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会很频繁，假如对一个表更新的话，这个表上的所有查询缓存都会被清空；所以大多数情况下，不推荐使用查询缓存
3)分析器
mysql没有命中缓存，就会进入分析器，分析器主要分析sql用来干嘛
第一步：词法分析，首先提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。
第二步：语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。
4)优化器
优化器的作用就是它认为的最优的执行方案去执行(有时候可能不是最佳方案)，比如多个索引时如何选择索引，多表查询时如何选择关联顺序；经过优化器之后之歌语句具体该如何执行就已经定下来了
5)执行器
当选择了执行方案，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限就会返回错误信息，如果有权限，就会调用引擎的接口，返回接口执行的结果

### 语句分析
#### 查询语句
sql语句执行流程
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
* 先检查该语句是否有权限，如果没有权限直接返回错误信息，如果有权限，在8.0之前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有执行下一步
* 通过分析器进行词法分析，提取sql语句关键元素，然后判断这个sql语句是否有语法错误，如果检查没问题就进入下一步
* 优化器根据自己的优化算法进行选择执行效率最好的一个方案
* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果

#### 更新语句
update tb_student A set A.age='19' where A.name=' 张三 ';
我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

* 先查询到张三这一条数据，如果有缓存，也会用到缓存
* 然后拿到查询语句，把age改为19，然后调用引擎api接口，写入这一行数据，innoDB引擎把数据保存到内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成，随时可以提交
* 执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态
* 更新完成

> 这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?

这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？
* 先写redo log直接提交，然后写binlog，假设写完redo log后，机器挂了，binlog日志没有写入，那么机器重启后，会通过redo log恢复数据，但是这个时候的binlog并没有记录该数据，后续进行数备份的时候，就会丢失这条数据，同时主从同步也会丢失这一条数据
* 先写binlog，然后写redo log，假设写完binlog，机器异常重启了，由于没有redo log，本机无法恢复数据，但是binlog又有记录，那么和上面同样的道理，就会产生数据不一致的情况

如果采用redo log两阶段提交的方式就不一样了，写完binlog后，然后在提交redo log就会防止上述的问题，从而保证数据的一致性。

如果redo log处于预提交状态，binlog也写完了，这时发生异常重启会怎么样？
这就要依赖mysql的处理机制了，处理过程如下：
* 判断redo log是否完整，如果判断是完整的，就立即提交
* 如果redo log只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交redo log，不完整就回滚事务

查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)


### Mysql存储引擎
#### mysql支持哪个存储引擎？默认使用哪个？
mysql支持多种存储引擎，可以使用show engines命令查看mysql支持的存储引擎；mysql当前默认引擎是innoDB，并且所有存储引擎中只有innoDB是事务性存储引擎，即只有innoDB支持事务；5.5.5之前，MyISAM是默认存储引擎，5.5.5之后，InnoDB是默认存储引擎

#### Mysql存储引擎架构
mysql存储引擎采用的是插件式架构，支持多种存储引擎，我们可以为不同的数据表设置不同的存储引擎以适应不同场景的需要；存储式引擎是基于表的，不是数据库

可以根据mysql定义的存储引擎实现标准接口来编写一个属于自己的存储引擎

#### MyISAM和InnoDB有什么区别
MyISAM不支持事务和行级锁，最大的缺陷是崩溃后无法安全恢复
1、是否支持行级锁
MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁；即MyISAM一锁就是锁住了整张表，这在并发写的情况下很糟糕
2、是否支持事务
MyISAM不提供事务支持；InnoDB提供事务支持，实现了sql标准定义了四个隔离级别，具有提交和回滚事务的能力，InnoDB默认使用的repeatable-read（可重读）隔离级别是可以解决幻读问题的发生的
3、是否支持外键
MyISAM不支持，InnoDB支持
外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此，通常不建议在生产项目中使用外键，在业务代码中进行约束即可
注：不得使用外键与级联，一切外键概念必须在应用层解决
学生表中的student_id是主键，那么成绩表中的student_id则为外键，如果更新学生表中的student_id,同时触发成绩表中的student_id更新，即为级联更新，外键和级联更新更适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

4、是否支持数据库异常崩溃后的安全恢复
MyISAM不支持，InnoDB支持

5、是否支持MVCC
MyISAM不支持，InnoDB支持
MyISAM连行级锁都不支持，MVCC可以看作行级锁的升级，可以有效减少加锁操作

6、索引实现不一样
MyISAM引擎和InnoDB引擎都是使用B+tree作为索引结构，但是两者的实现方式不太一样
InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照B+tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录
7、性能有差别
InnoDB性能比MyISAM更强，不管是在读写混合模式还是只读模式下，随着cpu核数的增加，InnoDB的读写能力线性增长

#### MyISAM和InnoDB如何选择
大多数情况，选择InnoDB存储引擎，在某些读密集的情况下，使用MyISAM也合适
《mysql高性能》中有一句话：不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论不绝对，在聚簇索引中，InnoDB速度快于MyISAM
一般情况下选择InnoDB没有问题，但是某些情况下你可能并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也不错

## mysql查询缓存
执行查询语句的时候会先查询缓存，但是在8.0之后移除；开启查询缓存后再同样的查询条件以及数据情况下，会直接在缓存中返回结果，
查询缓存不命中的情况：
1.任何两个查询在任何字符上的不同都会导致缓存不命中
2.如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql中的系统表，其查询结果也不会被缓存
3.缓存建立后，mysql的查询缓存系统会跟踪设计的每张表，如果这些表发生变化，那么和这张表相关的所有缓存数据都将失效

缓存虽然能提升数据库的查询性能，但是缓存同时也带来了额外开销，每次查询后都要做一次缓存操作，失效后还要销毁，因此，开启查询缓存要谨慎，尤其对于写密集的应用更是如此。如果开启，要注意控制缓存空间大小
## mysql日志
### 什么是事务
事务是逻辑上的一组操作，要么都执行，要么都不执行
事务案例：假如小明给小红转1000元，这个转账涉及到两个关键操作，这两个操作必须都成功或者都失败
1.将小明的余额减少1000
2.将小红的余额增加1000
事务会把这两个操作看作一个逻辑上的整体，这个整体要包含的操作要么都成功，要么都失败，这样就不会出现小明余额减少而小红的余额没有增加的情况了

### 什么是数据库事务
