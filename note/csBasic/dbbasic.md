## 什么是数据库、数据库管理系统、数据库系统、数据库管理员
数据库：就是信息的集合，或者说数据库是由数据库管理系统管理的数据的集合
数据库管理系统：是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库
数据库系统：通常由软件、数据库和数据管理员组成
数据库管理员：负责全面管理和控制数据库系统

## 什么是元组、码、候选码、主码、外码、主属性、非主属性


# MYSQL
## 基础
### 什么是关系数据库
是一种建立在关系模型的基础上的数据库，关系模型表明数据库中所存的数据之间的联系

### 什么是mysql
mysql是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据。mysql默认端口号3306

### mysql字段类型
数值类型:整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、 浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

### 整数类型的unsigned属性有什么用
unsigned属性表示不允许负值的无符号整数。使用unsigned属性可以将正整数的上限提高一倍，因为它不需要存储负值
对于从0开始递增的id列，使用unsigned属性非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的id值可用

### char和varchar的区别是什么
char和varchar是最常用到的字符串类型，区别是char是定长字符串，varchar是变长字符串
char更适合存储长度较短或长度都差不多的字符串，varchar适合存储长度不确定或者差异较大的字符串
char(M)和varchar(M)的M都代表能够保存的字符数的最大值，无论是数字、字母还是中文，都只占一个字符

### varchar(10)和varchar(100)的区别是什么
varchar(100)可以满足更大范围的字符存储需求，varchar(10)存储超过10个字符时，就需要修改表结构
varchar(10)和varchar(100)存储的字符范围不同，但是二者存储相同的字符串，所占用磁盘的存储空间是一样的
varchar(100)会消耗更多的内存，因为varchar类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度

### decimal和float/double的区别
decimal与float的区别：decimal是定点数，float/double是浮点数，decimal可以存储精确的小数值，float/double只能存储近似的小数值
decimal用于存储具有精度要求的小数

### 为什么不推荐使用text和blob
text类似于char和varchar，但可以存储更长文本的字符串，例如博客内容；blon类型主要用于存储二进制大对象，例如照片，音视频文件   
缺点：不能有默认值；在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表；检索效率低；不能直接创建索引，需要指定前缀长度；可能会消耗大量网络和io带宽；可能导致表上的dml操作变慢


### datetime和timestamp的区别
datetime类型没有时区信息，timestamp与时区有关
timestamp只需要使用4个字节的存储空间，但是datetime需要耗费8个字节的存储空间，导致timestamp表示的时间范围更小

### null和''的区别
null代币哎一个不确定的值，就算是两个null，他俩也不一定相等，比如select null = null的结果为false，但是当使用distinct、group by、order by时，null又被认为是相等的
''的长度为0，不占用空间，null需要占用空间
null会影响聚合函数，比如sum、avg、min等聚合函数会忽略null值。count的处理方式取决于参数类型。如果参数是*，则会统计所有的记录数，包括null值；如果参数是某个字段名（count(列名)），则会忽略null值，只统计非空值的个数
查询null值时，必须使用is null或is not null来判断，不能使用>、<之类的比较运算符，而''可以使用这些比较运算符

### Boolean类型如何表示
mysql中没有专门的布尔类型，使用tinyint(1)来表示布尔值，tinyint(1)类型可以用来存储0或1，分别对应false或true


## SQL在mysql中的执行过程
### mysql基础架构分析
连接器：身份认证和权限相关（登陆mysql的时候）
查询缓存:执行查询语句的时候，会先查询缓存（8.0之后移除）
分析器：没有命中缓存的话，sql语句就会经过分析器，分析器需要先看sql语句要做什么，再检查你的sql语句语法是否正确
优化器：按照mysql认为最优的方案去执行
执行器：执行语句，然后从存储引擎返回数据。执行语句前会先判断是否有权限，如果美哟权限就会报错
插件式存储引擎：主要负责数据的存储与读取，采用的是插件式架构，支持InnoDB、MyISAM、Memory 等多种存储引擎
![图片](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

mysql主要分为server层和存储引擎层：
server层：主要包括连接器、查询缓存、分析器、优化器、执行器等所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图，函数。
存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持innoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog模块，现在最常用的存储引擎是InnoDB，它从5.5开始就被当作默认存储引擎了

#### Server层基本组件介绍
1)连接器
连接器主要和身份认证和权限相关的功能相关，主要负责用户登陆数据库，进行用户的身份认证，包括校验用户密码，权限等操作，如果用户账户密码校验通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都会是依赖此时读到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也不受影响
2)查询缓存（8.0以后移除）
查询缓存主要是用来缓存所执行的select语句以及该语句的结果集。
连接建立后，执行查询语句时，会先查询缓存，mysql会先校验这个sql语句是否执行过，以k-v的形式缓存在内存中，k是查询语句，v是结果集。如果缓存k被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件

mysql查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会很频繁，假如对一个表更新的话，这个表上的所有查询缓存都会被清空；所以大多数情况下，不推荐使用查询缓存
3)分析器
mysql没有命中缓存，就会进入分析器，分析器主要分析sql用来干嘛
第一步：词法分析，首先提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。
第二步：语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。
4)优化器
优化器的作用就是它认为的最优的执行方案去执行(有时候可能不是最佳方案)，比如多个索引时如何选择索引，多表查询时如何选择关联顺序；经过优化器之后之歌语句具体该如何执行就已经定下来了
5)执行器
当选择了执行方案，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限就会返回错误信息，如果有权限，就会调用引擎的接口，返回接口执行的结果

### 语句分析
#### 查询语句
sql语句执行流程
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
* 先检查该语句是否有权限，如果没有权限直接返回错误信息，如果有权限，在8.0之前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有执行下一步
* 通过分析器进行词法分析，提取sql语句关键元素，然后判断这个sql语句是否有语法错误，如果检查没问题就进入下一步
* 优化器根据自己的优化算法进行选择执行效率最好的一个方案
* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果

#### 更新语句
update tb_student A set A.age='19' where A.name=' 张三 ';
我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

* 先查询到张三这一条数据，如果有缓存，也会用到缓存
* 然后拿到查询语句，把age改为19，然后调用引擎api接口，写入这一行数据，innoDB引擎把数据保存到内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成，随时可以提交
* 执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态
* 更新完成

> 这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?

这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？
* 先写redo log直接提交，然后写binlog，假设写完redo log后，机器挂了，binlog日志没有写入，那么机器重启后，会通过redo log恢复数据，但是这个时候的binlog并没有记录该数据，后续进行数备份的时候，就会丢失这条数据，同时主从同步也会丢失这一条数据
* 先写binlog，然后写redo log，假设写完binlog，机器异常重启了，由于没有redo log，本机无法恢复数据，但是binlog又有记录，那么和上面同样的道理，就会产生数据不一致的情况

如果采用redo log两阶段提交的方式就不一样了，写完binlog后，然后在提交redo log就会防止上述的问题，从而保证数据的一致性。

如果redo log处于预提交状态，binlog也写完了，这时发生异常重启会怎么样？
这就要依赖mysql的处理机制了，处理过程如下：
* 判断redo log是否完整，如果判断是完整的，就立即提交
* 如果redo log只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交redo log，不完整就回滚事务

查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)


### Mysql存储引擎
#### mysql支持哪个存储引擎？默认使用哪个？
mysql支持多种存储引擎，可以使用show engines命令查看mysql支持的存储引擎；mysql当前默认引擎是innoDB，并且所有存储引擎中只有innoDB是事务性存储引擎，即只有innoDB支持事务；5.5.5之前，MyISAM是默认存储引擎，5.5.5之后，InnoDB是默认存储引擎

#### Mysql存储引擎架构
mysql存储引擎采用的是插件式架构，支持多种存储引擎，我们可以为不同的数据表设置不同的存储引擎以适应不同场景的需要；存储式引擎是基于表的，不是数据库

可以根据mysql定义的存储引擎实现标准接口来编写一个属于自己的存储引擎

#### MyISAM和InnoDB有什么区别
MyISAM不支持事务和行级锁，最大的缺陷是崩溃后无法安全恢复
1、是否支持行级锁
MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁；即MyISAM一锁就是锁住了整张表，这在并发写的情况下很糟糕
2、是否支持事务
MyISAM不提供事务支持；InnoDB提供事务支持，实现了sql标准定义了四个隔离级别，具有提交和回滚事务的能力，InnoDB默认使用的repeatable-read（可重读）隔离级别是可以解决幻读问题的发生的
3、是否支持外键
MyISAM不支持，InnoDB支持
外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此，通常不建议在生产项目中使用外键，在业务代码中进行约束即可
注：不得使用外键与级联，一切外键概念必须在应用层解决
学生表中的student_id是主键，那么成绩表中的student_id则为外键，如果更新学生表中的student_id,同时触发成绩表中的student_id更新，即为级联更新，外键和级联更新更适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

4、是否支持数据库异常崩溃后的安全恢复
MyISAM不支持，InnoDB支持

5、是否支持MVCC
MyISAM不支持，InnoDB支持
MyISAM连行级锁都不支持，MVCC可以看作行级锁的升级，可以有效减少加锁操作

6、索引实现不一样
MyISAM引擎和InnoDB引擎都是使用B+tree作为索引结构，但是两者的实现方式不太一样
InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按照B+tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录
7、性能有差别
InnoDB性能比MyISAM更强，不管是在读写混合模式还是只读模式下，随着cpu核数的增加，InnoDB的读写能力线性增长

#### MyISAM和InnoDB如何选择
大多数情况，选择InnoDB存储引擎，在某些读密集的情况下，使用MyISAM也合适
《mysql高性能》中有一句话：不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论不绝对，在聚簇索引中，InnoDB速度快于MyISAM
一般情况下选择InnoDB没有问题，但是某些情况下你可能并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也不错

## mysql查询缓存
执行查询语句的时候会先查询缓存，但是在8.0之后移除；开启查询缓存后再同样的查询条件以及数据情况下，会直接在缓存中返回结果，
查询缓存不命中的情况：
1.任何两个查询在任何字符上的不同都会导致缓存不命中
2.如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql中的系统表，其查询结果也不会被缓存
3.缓存建立后，mysql的查询缓存系统会跟踪设计的每张表，如果这些表发生变化，那么和这张表相关的所有缓存数据都将失效

缓存虽然能提升数据库的查询性能，但是缓存同时也带来了额外开销，每次查询后都要做一次缓存操作，失效后还要销毁，因此，开启查询缓存要谨慎，尤其对于写密集的应用更是如此。如果开启，要注意控制缓存空间大小
## mysql日志
### 什么是事务
事务是逻辑上的一组操作，要么都执行，要么都不执行
事务案例：假如小明给小红转1000元，这个转账涉及到两个关键操作，这两个操作必须都成功或者都失败
1.将小明的余额减少1000
2.将小红的余额增加1000
事务会把这两个操作看作一个逻辑上的整体，这个整体要包含的操作要么都成功，要么都失败，这样就不会出现小明余额减少而小红的余额没有增加的情况了

### 什么是数据库事务
大多数情况，在谈论事务的时候，如果没有特指分布式事务，往往指的就是数据库事务
如果项目属于单体架构，接触的就是数据库事务
#### 数据库事务有什么作用
数据库事务可以保证多个对数据库的操作（就是sql语句）构成一个逻辑上的整体，购车给逻辑上的整体的这些数据库操作遵循：要么全部执行成功，要么全部不执行
```
# 开启一个事务
start transaction;
## 提交事务
commit;
```
关系型数据库事务都有acid特性；a：原子性；c：一致性；i：隔离性；d：持久性
原子性：事务是最小的执行单位，不允许分割。事务的原子性要保证动作要么全部完成，要么完全不起作用
一致性：执行事务前后，数据保持一致，例如转账业务，无论事务是否成功，收款人与转账人的总额不变
隔离性：并发访问数据库时，一个用户的事务不被其他事务干扰，各并发事务之间数据库是独立的
持久性：一个事务被提交后，它对数据库中数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响
只有保证了事务的持久性、隔离性、原子性，才能保障一致性，也就是说adi是手段，c是目的

### 并发事务带来了那些问题
在典型的应用程序中，多个事务并发允许，经常会操作相同的数据完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题
#### 脏读
一个事务读取数据并对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有被提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据没有同步到数据库，那第二个事务读取到的就是脏数据。
例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。
![图片](https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-ee15b0b9.png)

#### 丢失修改
在一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失
例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
![图片](https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications-5b2e2bd8.png)

#### 不可重复读
指在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问了该数据。那么，在第一个事务的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个事务内两次读到的数据是不一样的情况
例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。

#### 幻读
幻读和不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读
例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。

### 不可重复读和幻读的区别
* 不可重复读的重点是内容修改或记录减少比如多次读取一条记录发现其中某些记录的值被修改
* 幻读的重点在于记录新增比如多次执行同一条查询时，发现查到的记录增加了

幻读可以看作不可重复读的一种特殊情况，单独把区分幻读的原因是解决幻读和不可重复读的方案不一样
举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。

### 并发事务的控制方式有那些
mysql中并发事务的控制方式有两种：锁和MVCC。锁可以看作是悲观控制的模式，多版本并发控制（MVCC）可以看作是乐观控制的模式
所控制方式下会通过锁来显示控制共享资源而不是通过调度手段，mysql主要通过读写锁来实现并发控制
* 共享锁(s锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）
* 排他锁(x锁)：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取，如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）

读写锁可以做到读读并行，但是无法做到写读，写写并行。另外，根据锁粒度的不同，又被分为表级锁和行级锁。InnoDB不光支持表级锁，也支持行级锁，默认为行级锁。行级锁的锁粒度更小，仅对相关的记录上锁即可（对一行或多行记录加锁），所以对于并发写入操作来说，InnoDB的性能更高。不论是表级锁还是行级锁，都存在共享锁和排他锁。

MVCC在mysql中实现所依赖的手段主要是：隐藏字段、read view、undo log
* undo log：用于记录某行数据的多个版本的数据
* read view和隐藏字段：用于判断当前版本数据的可见性

### sql标准定义了那些事务隔离级别
sql标准定义了四个隔离级别：
read-uncommitted(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读、幻读
read-committed(读取已提交)：允许读取的并发事务已经提交的数据，可以阻止脏读，但是不可重复读和幻读仍有可能发生
repeatable-read(可重复读)：对同一字段的多次读取结果都是一致的，除非数据本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
serializable(可串行化)：最高的隔离级别，完全服从acid的隔离级别。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，即该级别可以防止幻读、脏读、不可重复读

### mysql的隔离级别是基于锁实现的吗？
mysql的隔离级别基于锁和MVCC机制共同实现的
serializable隔离级别是通过锁实现的，read-committed和repeatable-read隔离级别是基于MVCC实现的。不过，serializable之外的其他隔离级别可能也需要用到锁机制，比如repeatable-read在当前读情况下需要使用加锁读来保证不会出现幻读

### mysql的默认隔离级别是什么？
mysql InnoDB存储引擎的默认支持的隔离级别是repeatable-read级别，可以通过select @@tx_isolation;命令查看，8.0后该命令改为select @@transaction_isolation;

## mysql锁
锁是一种常见的并发事务的控制方式

### 表级锁和行级锁有什么区别
MyISAM仅仅支持表级锁，一锁就是一张表，这在并发写的情况下性能很差，InnoDB不光支持表级锁，也支持行级锁，默认为行级锁
行级锁的粒度更小，进队相关的记录上锁即可，所以对并发写入操作来说，InnoDB的性能更高
#### 表级锁和行级锁对比
* 表级锁：mysql中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM和InnoDB引擎都支持表级锁
* 行级锁：mysql中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的

### 行级锁的使用有什么注意事项
InnoDB的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行delete、update语句时，如果where条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。
不过很多时候即使使用了索引也有可能会走全表扫描，这是mysql优化器的原因

### InnoDB有哪几类锁
InnoDB行锁是通过对索引数据页上的记录加锁实现的，mysql InnoDB支持三种行锁定方式：
* 记录所：属于单个行记录上的锁
* 间隙锁：锁定一个范围，不包括记录本身
* 临键锁：record lock+gap lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录所只能锁住已经存在的记录，为了避免插入新纪录，需要依赖间隙锁

在InnoDB默认的隔离级别repeatable-read下，行锁默认使用的是next-key lock。但是，如果操作的索引是唯一索引或主键，InnoDB会对next-key lock进行优化，将其降级为record lock，即仅锁住索引本身，而不是范围。


### 共享锁和排他锁
不论是表级锁还是行级锁，都存在共享锁（s锁）和排他锁（x锁）这两类：
排他锁和任何锁都不兼容；共享锁仅和共享锁兼容
由于MVCC的存在，对于一般的select语句，InnoDB不会加任何锁，可以通过下面的语句显示加共享锁或排他锁
```
# 共享锁 可以在5.7和8.0中使用
select ... lock in share mode;
# 共享锁 可以在8.0中使用
select ... for share
# 排他锁
select ... for update
```

### 意向锁有什么用
如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行的遍历性能太差，我们需要用到一个叫意向锁的东西来快速判断是否可以对某个表使用表锁
意向锁是表级锁，共有两种：
* 意向共享锁（is锁）：事务有意向对表中某些记录加共享锁，加共享锁前必须获得该表的is锁
* 意向排他锁（ix锁）：事务有意向对表中的某些记录加排他锁，加排他锁前必须获得该表的ix锁

意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁
意向锁之间是互相兼容的
意向锁和共享锁和排他锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）


### 当前度和快照读有什么区别
快照读（一致性非锁定读）就是单纯的select语句，但不包括下面的这两类select语句
```
select ... for update
select ... lock in share mode
select ... for share
```
快照即记录的历史版本，每行记录可能存在多个历史版本
快照读的情况下，如果读取的记录正在执行update/delete操作，读取操作不会因此去等待记录上x锁的释放，而是会去读取行的一个快照
只有在事务隔离级别rc（读取已提交）和rr（可重复读）下，InnoDB才会使用一致性非锁定读：
* 在rc级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据
* 在rr级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本

快照读比较适合数据一致性要求不是特别高且追求机制性能的业务场景

当前读（一致性锁定读）就是给行记录加x锁或s锁
当前读的一些常见sql语句如下：
```
# 对读的记录加一个x锁
select ... for update
# 对读的记录加一个s锁
select ... lock in share mode
# 对读的记录加一个s锁
select ... for share
# 对修改的记录加一个x锁
insert ...
update ...
```


### 自增锁（了解即可）
关系型数据库设计表的时候，通常会由一列作为自增主键。InnoDB中的自增主键会涉及一种比较特殊的表级锁-自增锁
```
CREATE TABLE `sequence_id` (
  `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `stub` CHAR(10) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `stub` (`stub`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
不仅仅是自增主键，auto_increment的列都会涉及到自增锁，毕竟非主键也可以设置自增长

如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能被阻塞住，这里的阻塞行为只是自增锁行为的一种，可以理解为自增锁就是一个接口，其具体实现有多种，具体的配置项为innodb_autoinc_lock_mode(5.1.22引入)，可以选择的值如下：
|innodb_autoinc_lock_mode|介绍|
|:----:|:----:|
|0|传统模式|
|1|连续模式(8.0之前默认)|
|2|交错模式(8.0之后默认)|

交错模式下，所有的insert-like语句（所有的插入语句，包括：insert、replace、insert..select）都不是表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行

如果你的mysql数据库有主从同步需求并且Binlog存储格式为statement的话，不要将InnoDB自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序无法得到保障
如果mysql采用的格式是statement，那么mysql的主从同步实际上同步的就是一条一条的sql语句

## mysql性能优化
mysql高性能优化规范